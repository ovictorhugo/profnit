import {
  require_react
} from "./chunk-6CE3F7YD.js";
import {
  __commonJS
} from "./chunk-TFWDKVI3.js";

// node_modules/react-highcharts/node_modules/highcharts/highcharts.js
var require_highcharts = __commonJS({
  "node_modules/react-highcharts/node_modules/highcharts/highcharts.js"(exports, module) {
    (function(S, K) {
      "object" === typeof module && module.exports ? module.exports = S.document ? K(S) : K : "function" === typeof define && define.amd ? define(function() {
        return K(S);
      }) : S.Highcharts = K(S);
    })("undefined" !== typeof window ? window : exports, function(S) {
      var K = function() {
        var a = "undefined" === typeof S ? window : S, C = a.document, F = a.navigator && a.navigator.userAgent || "", I = C && C.createElementNS && !!C.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect, n = /(edge|msie|trident)/i.test(F) && !a.opera, f = -1 !== F.indexOf("Firefox"), e = -1 !== F.indexOf("Chrome"), u = f && 4 > parseInt(F.split("Firefox/")[1], 10);
        return a.Highcharts ? a.Highcharts.error(16, true) : { product: "Highcharts", version: "6.2.0", deg2rad: 2 * Math.PI / 360, doc: C, hasBidiBug: u, hasTouch: C && void 0 !== C.documentElement.ontouchstart, isMS: n, isWebKit: -1 !== F.indexOf("AppleWebKit"), isFirefox: f, isChrome: e, isSafari: !e && -1 !== F.indexOf("Safari"), isTouchDevice: /(Mobile|Android|Windows Phone)/.test(F), SVG_NS: "http://www.w3.org/2000/svg", chartCount: 0, seriesTypes: {}, symbolSizes: {}, svg: I, win: a, marginNames: [
          "plotTop",
          "marginRight",
          "marginBottom",
          "plotLeft"
        ], noop: function() {
        }, charts: [] };
      }();
      (function(a) {
        a.timers = [];
        var C = a.charts, F = a.doc, I = a.win;
        a.error = function(n, f) {
          n = a.isNumber(n) ? "Highcharts error #" + n + ": www.highcharts.com/errors/" + n : n;
          if (f)
            throw Error(n);
          I.console && console.log(n);
        };
        a.Fx = function(a2, f, e) {
          this.options = f;
          this.elem = a2;
          this.prop = e;
        };
        a.Fx.prototype = { dSetter: function() {
          var a2 = this.paths[0], f = this.paths[1], e = [], u = this.now, x = a2.length, t;
          if (1 === u)
            e = this.toD;
          else if (x === f.length && 1 > u)
            for (; x--; )
              t = parseFloat(a2[x]), e[x] = isNaN(t) ? f[x] : u * parseFloat(f[x] - t) + t;
          else
            e = f;
          this.elem.attr("d", e, null, true);
        }, update: function() {
          var a2 = this.elem, f = this.prop, e = this.now, u = this.options.step;
          if (this[f + "Setter"])
            this[f + "Setter"]();
          else
            a2.attr ? a2.element && a2.attr(f, e, null, true) : a2.style[f] = e + this.unit;
          u && u.call(a2, e, this);
        }, run: function(n, f, e) {
          var u = this, x = u.options, t = function(a2) {
            return t.stopped ? false : u.step(a2);
          }, w = I.requestAnimationFrame || function(a2) {
            setTimeout(a2, 13);
          }, y = function() {
            for (var c = 0; c < a.timers.length; c++)
              a.timers[c]() || a.timers.splice(
                c--,
                1
              );
            a.timers.length && w(y);
          };
          n !== f || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = n, this.end = f, this.unit = e, this.now = this.start, this.pos = 0, t.elem = this.elem, t.prop = this.prop, t() && 1 === a.timers.push(t) && w(y)) : (delete x.curAnim[this.prop], x.complete && 0 === a.keys(x.curAnim).length && x.complete.call(this.elem));
        }, step: function(n) {
          var f = +/* @__PURE__ */ new Date(), e, u = this.options, x = this.elem, t = u.complete, w = u.duration, y = u.curAnim;
          x.attr && !x.element ? n = false : n || f >= w + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), e = y[this.prop] = true, a.objectEach(y, function(a2) {
            true !== a2 && (e = false);
          }), e && t && t.call(x), n = false) : (this.pos = u.easing((f - this.startTime) / w), this.now = this.start + (this.end - this.start) * this.pos, this.update(), n = true);
          return n;
        }, initPath: function(n, f, e) {
          function u(a2) {
            var b2, k2;
            for (d = a2.length; d--; )
              b2 = "M" === a2[d] || "L" === a2[d], k2 = /[a-zA-Z]/.test(a2[d + 3]), b2 && k2 && a2.splice(d + 1, 0, a2[d + 1], a2[d + 2], a2[d + 1], a2[d + 2]);
          }
          function x(a2, h2) {
            for (; a2.length < k; ) {
              a2[0] = h2[k - a2.length];
              var c2 = a2.slice(0, p);
              [].splice.apply(a2, [0, 0].concat(c2));
              b && (c2 = a2.slice(a2.length - p), [].splice.apply(a2, [a2.length, 0].concat(c2)), d--);
            }
            a2[0] = "M";
          }
          function t(a2, d2) {
            for (var c2 = (k - a2.length) / p; 0 < c2 && c2--; )
              q = a2.slice().splice(a2.length / v - p, p * v), q[0] = d2[k - p - c2 * p], h && (q[p - 6] = q[p - 2], q[p - 5] = q[p - 1]), [].splice.apply(a2, [a2.length / v, 0].concat(q)), b && c2--;
          }
          f = f || "";
          var w, y = n.startX, c = n.endX, h = -1 < f.indexOf("C"), p = h ? 7 : 3, k, q, d;
          f = f.split(" ");
          e = e.slice();
          var b = n.isArea, v = b ? 2 : 1, J;
          h && (u(f), u(e));
          if (y && c) {
            for (d = 0; d < y.length; d++)
              if (y[d] === c[0]) {
                w = d;
                break;
              } else if (y[0] === c[c.length - y.length + d]) {
                w = d;
                J = true;
                break;
              }
            void 0 === w && (f = []);
          }
          f.length && a.isNumber(w) && (k = e.length + w * v * p, J ? (x(f, e), t(e, f)) : (x(e, f), t(f, e)));
          return [f, e];
        }, fillSetter: function() {
          a.Fx.prototype.strokeSetter.apply(this, arguments);
        }, strokeSetter: function() {
          this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, true);
        } };
        a.merge = function() {
          var n, f = arguments, e, u = {}, x = function(e2, n2) {
            "object" !== typeof e2 && (e2 = {});
            a.objectEach(n2, function(y, c) {
              !a.isObject(y, true) || a.isClass(y) || a.isDOMElement(y) ? e2[c] = n2[c] : e2[c] = x(
                e2[c] || {},
                y
              );
            });
            return e2;
          };
          true === f[0] && (u = f[1], f = Array.prototype.slice.call(f, 2));
          e = f.length;
          for (n = 0; n < e; n++)
            u = x(u, f[n]);
          return u;
        };
        a.pInt = function(a2, f) {
          return parseInt(a2, f || 10);
        };
        a.isString = function(a2) {
          return "string" === typeof a2;
        };
        a.isArray = function(a2) {
          a2 = Object.prototype.toString.call(a2);
          return "[object Array]" === a2 || "[object Array Iterator]" === a2;
        };
        a.isObject = function(n, f) {
          return !!n && "object" === typeof n && (!f || !a.isArray(n));
        };
        a.isDOMElement = function(n) {
          return a.isObject(n) && "number" === typeof n.nodeType;
        };
        a.isClass = function(n) {
          var f = n && n.constructor;
          return !(!a.isObject(n, true) || a.isDOMElement(n) || !f || !f.name || "Object" === f.name);
        };
        a.isNumber = function(a2) {
          return "number" === typeof a2 && !isNaN(a2) && Infinity > a2 && -Infinity < a2;
        };
        a.erase = function(a2, f) {
          for (var e = a2.length; e--; )
            if (a2[e] === f) {
              a2.splice(e, 1);
              break;
            }
        };
        a.defined = function(a2) {
          return void 0 !== a2 && null !== a2;
        };
        a.attr = function(n, f, e) {
          var u;
          a.isString(f) ? a.defined(e) ? n.setAttribute(f, e) : n && n.getAttribute && ((u = n.getAttribute(f)) || "class" !== f || (u = n.getAttribute(f + "Name"))) : a.defined(f) && a.isObject(f) && a.objectEach(f, function(a2, e2) {
            n.setAttribute(e2, a2);
          });
          return u;
        };
        a.splat = function(n) {
          return a.isArray(n) ? n : [n];
        };
        a.syncTimeout = function(a2, f, e) {
          if (f)
            return setTimeout(a2, f, e);
          a2.call(0, e);
        };
        a.clearTimeout = function(n) {
          a.defined(n) && clearTimeout(n);
        };
        a.extend = function(a2, f) {
          var e;
          a2 || (a2 = {});
          for (e in f)
            a2[e] = f[e];
          return a2;
        };
        a.pick = function() {
          var a2 = arguments, f, e, u = a2.length;
          for (f = 0; f < u; f++)
            if (e = a2[f], void 0 !== e && null !== e)
              return e;
        };
        a.css = function(n, f) {
          a.isMS && !a.svg && f && void 0 !== f.opacity && (f.filter = "alpha(opacity=" + 100 * f.opacity + ")");
          a.extend(n.style, f);
        };
        a.createElement = function(n, f, e, u, x) {
          n = F.createElement(n);
          var t = a.css;
          f && a.extend(n, f);
          x && t(n, { padding: 0, border: "none", margin: 0 });
          e && t(n, e);
          u && u.appendChild(n);
          return n;
        };
        a.extendClass = function(n, f) {
          var e = function() {
          };
          e.prototype = new n();
          a.extend(e.prototype, f);
          return e;
        };
        a.pad = function(a2, f, e) {
          return Array((f || 2) + 1 - String(a2).replace("-", "").length).join(e || 0) + a2;
        };
        a.relativeLength = function(a2, f, e) {
          return /%$/.test(a2) ? f * parseFloat(a2) / 100 + (e || 0) : parseFloat(a2);
        };
        a.wrap = function(a2, f, e) {
          var n = a2[f];
          a2[f] = function() {
            var a3 = Array.prototype.slice.call(arguments), t = arguments, w = this;
            w.proceed = function() {
              n.apply(w, arguments.length ? arguments : t);
            };
            a3.unshift(n);
            a3 = e.apply(this, a3);
            w.proceed = null;
            return a3;
          };
        };
        a.datePropsToTimestamps = function(n) {
          a.objectEach(n, function(f, e) {
            a.isObject(f) && "function" === typeof f.getTime ? n[e] = f.getTime() : (a.isObject(f) || a.isArray(f)) && a.datePropsToTimestamps(f);
          });
        };
        a.formatSingle = function(n, f, e) {
          var u = /\.([0-9])/, x = a.defaultOptions.lang;
          /f$/.test(n) ? (e = (e = n.match(u)) ? e[1] : -1, null !== f && (f = a.numberFormat(f, e, x.decimalPoint, -1 < n.indexOf(",") ? x.thousandsSep : ""))) : f = (e || a.time).dateFormat(n, f);
          return f;
        };
        a.format = function(n, f, e) {
          for (var u = "{", x = false, t, w, y, c, h = [], p; n; ) {
            u = n.indexOf(u);
            if (-1 === u)
              break;
            t = n.slice(0, u);
            if (x) {
              t = t.split(":");
              w = t.shift().split(".");
              c = w.length;
              p = f;
              for (y = 0; y < c; y++)
                p && (p = p[w[y]]);
              t.length && (p = a.formatSingle(t.join(":"), p, e));
              h.push(p);
            } else
              h.push(t);
            n = n.slice(u + 1);
            u = (x = !x) ? "}" : "{";
          }
          h.push(n);
          return h.join("");
        };
        a.getMagnitude = function(a2) {
          return Math.pow(
            10,
            Math.floor(Math.log(a2) / Math.LN10)
          );
        };
        a.normalizeTickInterval = function(n, f, e, u, x) {
          var t, w = n;
          e = a.pick(e, 1);
          t = n / e;
          f || (f = x ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], false === u && (1 === e ? f = a.grep(f, function(a2) {
            return 0 === a2 % 1;
          }) : 0.1 >= e && (f = [1 / e])));
          for (u = 0; u < f.length && !(w = f[u], x && w * e >= n || !x && t <= (f[u] + (f[u + 1] || f[u])) / 2); u++)
            ;
          return w = a.correctFloat(w * e, -Math.round(Math.log(1e-3) / Math.LN10));
        };
        a.stableSort = function(a2, f) {
          var e = a2.length, n, x;
          for (x = 0; x < e; x++)
            a2[x].safeI = x;
          a2.sort(function(a3, e2) {
            n = f(a3, e2);
            return 0 === n ? a3.safeI - e2.safeI : n;
          });
          for (x = 0; x < e; x++)
            delete a2[x].safeI;
        };
        a.arrayMin = function(a2) {
          for (var f = a2.length, e = a2[0]; f--; )
            a2[f] < e && (e = a2[f]);
          return e;
        };
        a.arrayMax = function(a2) {
          for (var f = a2.length, e = a2[0]; f--; )
            a2[f] > e && (e = a2[f]);
          return e;
        };
        a.destroyObjectProperties = function(n, f) {
          a.objectEach(n, function(a2, u) {
            a2 && a2 !== f && a2.destroy && a2.destroy();
            delete n[u];
          });
        };
        a.discardElement = function(n) {
          var f = a.garbageBin;
          f || (f = a.createElement("div"));
          n && f.appendChild(n);
          f.innerHTML = "";
        };
        a.correctFloat = function(a2, f) {
          return parseFloat(a2.toPrecision(f || 14));
        };
        a.setAnimation = function(n, f) {
          f.renderer.globalAnimation = a.pick(n, f.options.chart.animation, true);
        };
        a.animObject = function(n) {
          return a.isObject(n) ? a.merge(n) : { duration: n ? 500 : 0 };
        };
        a.timeUnits = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 };
        a.numberFormat = function(n, f, e, u) {
          n = +n || 0;
          f = +f;
          var x = a.defaultOptions.lang, t = (n.toString().split(".")[1] || "").split("e")[0].length, w, y, c = n.toString().split("e");
          -1 === f ? f = Math.min(t, 20) : a.isNumber(f) ? f && c[1] && 0 > c[1] && (w = f + +c[1], 0 <= w ? (c[0] = (+c[0]).toExponential(w).split("e")[0], f = w) : (c[0] = c[0].split(".")[0] || 0, n = 20 > f ? (c[0] * Math.pow(10, c[1])).toFixed(f) : 0, c[1] = 0)) : f = 2;
          y = (Math.abs(c[1] ? c[0] : n) + Math.pow(10, -Math.max(f, t) - 1)).toFixed(f);
          t = String(a.pInt(y));
          w = 3 < t.length ? t.length % 3 : 0;
          e = a.pick(e, x.decimalPoint);
          u = a.pick(u, x.thousandsSep);
          n = (0 > n ? "-" : "") + (w ? t.substr(0, w) + u : "");
          n += t.substr(w).replace(/(\d{3})(?=\d)/g, "$1" + u);
          f && (n += e + y.slice(-f));
          c[1] && 0 !== +n && (n += "e" + c[1]);
          return n;
        };
        Math.easeInOutSine = function(a2) {
          return -0.5 * (Math.cos(Math.PI * a2) - 1);
        };
        a.getStyle = function(n, f, e) {
          if ("width" === f)
            return Math.max(0, Math.min(n.offsetWidth, n.scrollWidth) - a.getStyle(n, "padding-left") - a.getStyle(n, "padding-right"));
          if ("height" === f)
            return Math.max(0, Math.min(n.offsetHeight, n.scrollHeight) - a.getStyle(n, "padding-top") - a.getStyle(n, "padding-bottom"));
          I.getComputedStyle || a.error(27, true);
          if (n = I.getComputedStyle(n, void 0))
            n = n.getPropertyValue(f), a.pick(e, "opacity" !== f) && (n = a.pInt(n));
          return n;
        };
        a.inArray = function(n, f, e) {
          return (a.indexOfPolyfill || Array.prototype.indexOf).call(f, n, e);
        };
        a.grep = function(n, f) {
          return (a.filterPolyfill || Array.prototype.filter).call(n, f);
        };
        a.find = Array.prototype.find ? function(a2, f) {
          return a2.find(f);
        } : function(a2, f) {
          var e, u = a2.length;
          for (e = 0; e < u; e++)
            if (f(a2[e], e))
              return a2[e];
        };
        a.some = function(n, f, e) {
          return (a.somePolyfill || Array.prototype.some).call(n, f, e);
        };
        a.map = function(a2, f) {
          for (var e = [], u = 0, x = a2.length; u < x; u++)
            e[u] = f.call(a2[u], a2[u], u, a2);
          return e;
        };
        a.keys = function(n) {
          return (a.keysPolyfill || Object.keys).call(void 0, n);
        };
        a.reduce = function(n, f, e) {
          return (a.reducePolyfill || Array.prototype.reduce).apply(n, 2 < arguments.length ? [f, e] : [f]);
        };
        a.offset = function(a2) {
          var f = F.documentElement;
          a2 = a2.parentElement || a2.parentNode ? a2.getBoundingClientRect() : { top: 0, left: 0 };
          return { top: a2.top + (I.pageYOffset || f.scrollTop) - (f.clientTop || 0), left: a2.left + (I.pageXOffset || f.scrollLeft) - (f.clientLeft || 0) };
        };
        a.stop = function(n, f) {
          for (var e = a.timers.length; e--; )
            a.timers[e].elem !== n || f && f !== a.timers[e].prop || (a.timers[e].stopped = true);
        };
        a.each = function(n, f, e) {
          return (a.forEachPolyfill || Array.prototype.forEach).call(n, f, e);
        };
        a.objectEach = function(a2, f, e) {
          for (var u in a2)
            a2.hasOwnProperty(u) && f.call(e || a2[u], a2[u], u, a2);
        };
        a.addEvent = function(n, f, e, u) {
          var x, t = n.addEventListener || a.addEventListenerPolyfill;
          x = "function" === typeof n && n.prototype ? n.prototype.protoEvents = n.prototype.protoEvents || {} : n.hcEvents = n.hcEvents || {};
          a.Point && n instanceof a.Point && n.series && n.series.chart && (n.series.chart.runTrackerClick = true);
          t && t.call(n, f, e, false);
          x[f] || (x[f] = []);
          x[f].push(e);
          u && a.isNumber(u.order) && (e.order = u.order, x[f].sort(function(a2, e2) {
            return a2.order - e2.order;
          }));
          return function() {
            a.removeEvent(n, f, e);
          };
        };
        a.removeEvent = function(n, f, e) {
          function u(e2, c) {
            var h = n.removeEventListener || a.removeEventListenerPolyfill;
            h && h.call(n, e2, c, false);
          }
          function x(e2) {
            var c, h;
            n.nodeName && (f ? (c = {}, c[f] = true) : c = e2, a.objectEach(c, function(a2, k) {
              if (e2[k])
                for (h = e2[k].length; h--; )
                  u(k, e2[k][h]);
            }));
          }
          var t, w;
          a.each(["protoEvents", "hcEvents"], function(y) {
            var c = n[y];
            c && (f ? (t = c[f] || [], e ? (w = a.inArray(e, t), -1 < w && (t.splice(w, 1), c[f] = t), u(f, e)) : (x(c), c[f] = [])) : (x(c), n[y] = {}));
          });
        };
        a.fireEvent = function(n, f, e, u) {
          var x, t, w, y, c;
          e = e || {};
          F.createEvent && (n.dispatchEvent || n.fireEvent) ? (x = F.createEvent("Events"), x.initEvent(f, true, true), a.extend(x, e), n.dispatchEvent ? n.dispatchEvent(x) : n.fireEvent(f, x)) : a.each(["protoEvents", "hcEvents"], function(h) {
            if (n[h])
              for (t = n[h][f] || [], w = t.length, e.target || a.extend(e, { preventDefault: function() {
                e.defaultPrevented = true;
              }, target: n, type: f }), y = 0; y < w; y++)
                (c = t[y]) && false === c.call(n, e) && e.preventDefault();
          });
          u && !e.defaultPrevented && u.call(
            n,
            e
          );
        };
        a.animate = function(n, f, e) {
          var u, x = "", t, w, y;
          a.isObject(e) || (y = arguments, e = { duration: y[2], easing: y[3], complete: y[4] });
          a.isNumber(e.duration) || (e.duration = 400);
          e.easing = "function" === typeof e.easing ? e.easing : Math[e.easing] || Math.easeInOutSine;
          e.curAnim = a.merge(f);
          a.objectEach(f, function(c, h) {
            a.stop(n, h);
            w = new a.Fx(n, e, h);
            t = null;
            "d" === h ? (w.paths = w.initPath(n, n.d, f.d), w.toD = f.d, u = 0, t = 1) : n.attr ? u = n.attr(h) : (u = parseFloat(a.getStyle(n, h)) || 0, "opacity" !== h && (x = "px"));
            t || (t = c);
            t && t.match && t.match("px") && (t = t.replace(/px/g, ""));
            w.run(u, t, x);
          });
        };
        a.seriesType = function(n, f, e, u, x) {
          var t = a.getOptions(), w = a.seriesTypes;
          t.plotOptions[n] = a.merge(t.plotOptions[f], e);
          w[n] = a.extendClass(w[f] || function() {
          }, u);
          w[n].prototype.type = n;
          x && (w[n].prototype.pointClass = a.extendClass(a.Point, x));
          return w[n];
        };
        a.uniqueKey = function() {
          var a2 = Math.random().toString(36).substring(2, 9), f = 0;
          return function() {
            return "highcharts-" + a2 + "-" + f++;
          };
        }();
        I.jQuery && (I.jQuery.fn.highcharts = function() {
          var n = [].slice.call(arguments);
          if (this[0])
            return n[0] ? (new a[a.isString(n[0]) ? n.shift() : "Chart"](this[0], n[0], n[1]), this) : C[a.attr(this[0], "data-highcharts-chart")];
        });
      })(K);
      (function(a) {
        var C = a.each, F = a.isNumber, I = a.map, n = a.merge, f = a.pInt;
        a.Color = function(e) {
          if (!(this instanceof a.Color))
            return new a.Color(e);
          this.init(e);
        };
        a.Color.prototype = { parsers: [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function(a2) {
          return [f(a2[1]), f(a2[2]), f(a2[3]), parseFloat(a2[4], 10)];
        } }, {
          regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
          parse: function(a2) {
            return [f(a2[1]), f(a2[2]), f(a2[3]), 1];
          }
        }], names: { white: "#ffffff", black: "#000000" }, init: function(e) {
          var f2, x, t, w;
          if ((this.input = e = this.names[e && e.toLowerCase ? e.toLowerCase() : ""] || e) && e.stops)
            this.stops = I(e.stops, function(e2) {
              return new a.Color(e2[1]);
            });
          else if (e && e.charAt && "#" === e.charAt() && (f2 = e.length, e = parseInt(e.substr(1), 16), 7 === f2 ? x = [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255, 1] : 4 === f2 && (x = [(e & 3840) >> 4 | (e & 3840) >> 8, (e & 240) >> 4 | e & 240, (e & 15) << 4 | e & 15, 1])), !x)
            for (t = this.parsers.length; t-- && !x; )
              w = this.parsers[t], (f2 = w.regex.exec(e)) && (x = w.parse(f2));
          this.rgba = x || [];
        }, get: function(a2) {
          var e = this.input, f2 = this.rgba, t;
          this.stops ? (t = n(e), t.stops = [].concat(t.stops), C(this.stops, function(e2, y) {
            t.stops[y] = [t.stops[y][0], e2.get(a2)];
          })) : t = f2 && F(f2[0]) ? "rgb" === a2 || !a2 && 1 === f2[3] ? "rgb(" + f2[0] + "," + f2[1] + "," + f2[2] + ")" : "a" === a2 ? f2[3] : "rgba(" + f2.join(",") + ")" : e;
          return t;
        }, brighten: function(a2) {
          var e, x = this.rgba;
          if (this.stops)
            C(this.stops, function(e2) {
              e2.brighten(a2);
            });
          else if (F(a2) && 0 !== a2)
            for (e = 0; 3 > e; e++)
              x[e] += f(255 * a2), 0 > x[e] && (x[e] = 0), 255 < x[e] && (x[e] = 255);
          return this;
        }, setOpacity: function(a2) {
          this.rgba[3] = a2;
          return this;
        }, tweenTo: function(a2, f2) {
          var e = this.rgba, t = a2.rgba;
          t.length && e && e.length ? (a2 = 1 !== t[3] || 1 !== e[3], f2 = (a2 ? "rgba(" : "rgb(") + Math.round(t[0] + (e[0] - t[0]) * (1 - f2)) + "," + Math.round(t[1] + (e[1] - t[1]) * (1 - f2)) + "," + Math.round(t[2] + (e[2] - t[2]) * (1 - f2)) + (a2 ? "," + (t[3] + (e[3] - t[3]) * (1 - f2)) : "") + ")") : f2 = a2.input || "none";
          return f2;
        } };
        a.color = function(e) {
          return new a.Color(e);
        };
      })(K);
      (function(a) {
        var C, F, I = a.addEvent, n = a.animate, f = a.attr, e = a.charts, u = a.color, x = a.css, t = a.createElement, w = a.defined, y = a.deg2rad, c = a.destroyObjectProperties, h = a.doc, p = a.each, k = a.extend, q = a.erase, d = a.grep, b = a.hasTouch, v = a.inArray, J = a.isArray, l = a.isFirefox, L = a.isMS, B = a.isObject, D = a.isString, m = a.isWebKit, G = a.merge, A = a.noop, N = a.objectEach, E = a.pick, g = a.pInt, r = a.removeEvent, M = a.stop, O = a.svg, H = a.SVG_NS, R = a.symbolSizes, Q = a.win;
        C = a.SVGElement = function() {
          return this;
        };
        k(C.prototype, {
          opacity: 1,
          SVG_NS: H,
          textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),
          init: function(a2, g2) {
            this.element = "span" === g2 ? t(g2) : h.createElementNS(this.SVG_NS, g2);
            this.renderer = a2;
          },
          animate: function(z, g2, r2) {
            g2 = a.animObject(E(g2, this.renderer.globalAnimation, true));
            0 !== g2.duration ? (r2 && (g2.complete = r2), n(this, z, g2)) : (this.attr(z, null, r2), g2.step && g2.step.call(this));
            return this;
          },
          complexColor: function(z, g2, r2) {
            var b2 = this.renderer, k2, m2, d2, H2, c2, h2, q2, A2, v2, P, l2, O2 = [], M2;
            a.fireEvent(this.renderer, "complexColor", { args: arguments }, function() {
              z.radialGradient ? m2 = "radialGradient" : z.linearGradient && (m2 = "linearGradient");
              m2 && (d2 = z[m2], c2 = b2.gradients, q2 = z.stops, P = r2.radialReference, J(d2) && (z[m2] = d2 = { x1: d2[0], y1: d2[1], x2: d2[2], y2: d2[3], gradientUnits: "userSpaceOnUse" }), "radialGradient" === m2 && P && !w(d2.gradientUnits) && (H2 = d2, d2 = G(d2, b2.getRadialAttr(P, H2), { gradientUnits: "userSpaceOnUse" })), N(d2, function(a2, z2) {
                "id" !== z2 && O2.push(z2, a2);
              }), N(q2, function(a2) {
                O2.push(a2);
              }), O2 = O2.join(","), c2[O2] ? l2 = c2[O2].attr("id") : (d2.id = l2 = a.uniqueKey(), c2[O2] = h2 = b2.createElement(m2).attr(d2).add(b2.defs), h2.radAttr = H2, h2.stops = [], p(q2, function(z2) {
                0 === z2[1].indexOf("rgba") ? (k2 = a.color(z2[1]), A2 = k2.get("rgb"), v2 = k2.get("a")) : (A2 = z2[1], v2 = 1);
                z2 = b2.createElement("stop").attr({ offset: z2[0], "stop-color": A2, "stop-opacity": v2 }).add(h2);
                h2.stops.push(z2);
              })), M2 = "url(" + b2.url + "#" + l2 + ")", r2.setAttribute(g2, M2), r2.gradient = O2, z.toString = function() {
                return M2;
              });
            });
          },
          applyTextOutline: function(z) {
            var g2 = this.element, r2, b2, d2, m2, k2;
            -1 !== z.indexOf("contrast") && (z = z.replace(/contrast/g, this.renderer.getContrast(g2.style.fill)));
            z = z.split(" ");
            b2 = z[z.length - 1];
            if ((d2 = z[0]) && "none" !== d2 && a.svg) {
              this.fakeTS = true;
              z = [].slice.call(g2.getElementsByTagName("tspan"));
              this.ySetter = this.xSetter;
              d2 = d2.replace(/(^[\d\.]+)(.*?)$/g, function(a2, z2, g3) {
                return 2 * z2 + g3;
              });
              for (k2 = z.length; k2--; )
                r2 = z[k2], "highcharts-text-outline" === r2.getAttribute("class") && q(z, g2.removeChild(r2));
              m2 = g2.firstChild;
              p(z, function(a2, z2) {
                0 === z2 && (a2.setAttribute("x", g2.getAttribute("x")), z2 = g2.getAttribute("y"), a2.setAttribute("y", z2 || 0), null === z2 && g2.setAttribute("y", 0));
                a2 = a2.cloneNode(1);
                f(a2, { "class": "highcharts-text-outline", fill: b2, stroke: b2, "stroke-width": d2, "stroke-linejoin": "round" });
                g2.insertBefore(a2, m2);
              });
            }
          },
          attr: function(a2, g2, r2, b2) {
            var z, d2 = this.element, m2, k2 = this, c2, H2;
            "string" === typeof a2 && void 0 !== g2 && (z = a2, a2 = {}, a2[z] = g2);
            "string" === typeof a2 ? k2 = (this[a2 + "Getter"] || this._defaultGetter).call(this, a2, d2) : (N(a2, function(z2, g3) {
              c2 = false;
              b2 || M(this, g3);
              this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(g3) && (m2 || (this.symbolAttr(a2), m2 = true), c2 = true);
              !this.rotation || "x" !== g3 && "y" !== g3 || (this.doTransform = true);
              c2 || (H2 = this[g3 + "Setter"] || this._defaultSetter, H2.call(this, z2, g3, d2), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(g3) && this.updateShadows(g3, z2, H2));
            }, this), this.afterSetters());
            r2 && r2.call(this);
            return k2;
          },
          afterSetters: function() {
            this.doTransform && (this.updateTransform(), this.doTransform = false);
          },
          updateShadows: function(a2, g2, r2) {
            for (var z = this.shadows, d2 = z.length; d2--; )
              r2.call(z[d2], "height" === a2 ? Math.max(g2 - (z[d2].cutHeight || 0), 0) : "d" === a2 ? this.d : g2, a2, z[d2]);
          },
          addClass: function(a2, g2) {
            var z = this.attr("class") || "";
            -1 === z.indexOf(a2) && (g2 || (a2 = (z + (z ? " " : "") + a2).replace("  ", " ")), this.attr("class", a2));
            return this;
          },
          hasClass: function(a2) {
            return -1 !== v(a2, (this.attr("class") || "").split(" "));
          },
          removeClass: function(a2) {
            return this.attr("class", (this.attr("class") || "").replace(a2, ""));
          },
          symbolAttr: function(a2) {
            var z = this;
            p("x y r start end width height innerR anchorX anchorY".split(" "), function(g2) {
              z[g2] = E(a2[g2], z[g2]);
            });
            z.attr({ d: z.renderer.symbols[z.symbolName](z.x, z.y, z.width, z.height, z) });
          },
          clip: function(a2) {
            return this.attr("clip-path", a2 ? "url(" + this.renderer.url + "#" + a2.id + ")" : "none");
          },
          crisp: function(a2, g2) {
            var z;
            g2 = g2 || a2.strokeWidth || 0;
            z = Math.round(g2) % 2 / 2;
            a2.x = Math.floor(a2.x || this.x || 0) + z;
            a2.y = Math.floor(a2.y || this.y || 0) + z;
            a2.width = Math.floor((a2.width || this.width || 0) - 2 * z);
            a2.height = Math.floor((a2.height || this.height || 0) - 2 * z);
            w(a2.strokeWidth) && (a2.strokeWidth = g2);
            return a2;
          },
          css: function(a2) {
            var z = this.styles, r2 = {}, d2 = this.element, b2, m2 = "", c2, H2 = !z, h2 = ["textOutline", "textOverflow", "width"];
            a2 && a2.color && (a2.fill = a2.color);
            z && N(a2, function(a3, g2) {
              a3 !== z[g2] && (r2[g2] = a3, H2 = true);
            });
            H2 && (z && (a2 = k(z, r2)), a2 && (null === a2.width || "auto" === a2.width ? delete this.textWidth : "text" === d2.nodeName.toLowerCase() && a2.width && (b2 = this.textWidth = g(a2.width))), this.styles = a2, b2 && !O && this.renderer.forExport && delete a2.width, d2.namespaceURI === this.SVG_NS ? (c2 = function(a3, z2) {
              return "-" + z2.toLowerCase();
            }, N(a2, function(a3, z2) {
              -1 === v(z2, h2) && (m2 += z2.replace(/([A-Z])/g, c2) + ":" + a3 + ";");
            }), m2 && f(d2, "style", m2)) : x(d2, a2), this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), a2 && a2.textOutline && this.applyTextOutline(a2.textOutline)));
            return this;
          },
          strokeWidth: function() {
            return this["stroke-width"] || 0;
          },
          on: function(a2, g2) {
            var z = this, r2 = z.element;
            b && "click" === a2 ? (r2.ontouchstart = function(a3) {
              z.touchEventFired = Date.now();
              a3.preventDefault();
              g2.call(r2, a3);
            }, r2.onclick = function(a3) {
              (-1 === Q.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (z.touchEventFired || 0)) && g2.call(r2, a3);
            }) : r2["on" + a2] = g2;
            return this;
          },
          setRadialReference: function(a2) {
            var z = this.renderer.gradients[this.element.gradient];
            this.element.radialReference = a2;
            z && z.radAttr && z.animate(this.renderer.getRadialAttr(a2, z.radAttr));
            return this;
          },
          translate: function(a2, g2) {
            return this.attr({
              translateX: a2,
              translateY: g2
            });
          },
          invert: function(a2) {
            this.inverted = a2;
            this.updateTransform();
            return this;
          },
          updateTransform: function() {
            var a2 = this.translateX || 0, g2 = this.translateY || 0, r2 = this.scaleX, d2 = this.scaleY, b2 = this.inverted, m2 = this.rotation, k2 = this.matrix, c2 = this.element;
            b2 && (a2 += this.width, g2 += this.height);
            a2 = ["translate(" + a2 + "," + g2 + ")"];
            w(k2) && a2.push("matrix(" + k2.join(",") + ")");
            b2 ? a2.push("rotate(90) scale(-1,1)") : m2 && a2.push("rotate(" + m2 + " " + E(this.rotationOriginX, c2.getAttribute("x"), 0) + " " + E(this.rotationOriginY, c2.getAttribute("y") || 0) + ")");
            (w(r2) || w(d2)) && a2.push("scale(" + E(r2, 1) + " " + E(d2, 1) + ")");
            a2.length && c2.setAttribute("transform", a2.join(" "));
          },
          toFront: function() {
            var a2 = this.element;
            a2.parentNode.appendChild(a2);
            return this;
          },
          align: function(a2, g2, r2) {
            var z, d2, b2, m2, k2 = {};
            d2 = this.renderer;
            b2 = d2.alignedObjects;
            var c2, H2;
            if (a2) {
              if (this.alignOptions = a2, this.alignByTranslate = g2, !r2 || D(r2))
                this.alignTo = z = r2 || "renderer", q(b2, this), b2.push(this), r2 = null;
            } else
              a2 = this.alignOptions, g2 = this.alignByTranslate, z = this.alignTo;
            r2 = E(r2, d2[z], d2);
            z = a2.align;
            d2 = a2.verticalAlign;
            b2 = (r2.x || 0) + (a2.x || 0);
            m2 = (r2.y || 0) + (a2.y || 0);
            "right" === z ? c2 = 1 : "center" === z && (c2 = 2);
            c2 && (b2 += (r2.width - (a2.width || 0)) / c2);
            k2[g2 ? "translateX" : "x"] = Math.round(b2);
            "bottom" === d2 ? H2 = 1 : "middle" === d2 && (H2 = 2);
            H2 && (m2 += (r2.height - (a2.height || 0)) / H2);
            k2[g2 ? "translateY" : "y"] = Math.round(m2);
            this[this.placed ? "animate" : "attr"](k2);
            this.placed = true;
            this.alignAttr = k2;
            return this;
          },
          getBBox: function(a2, g2) {
            var z, r2 = this.renderer, d2, b2 = this.element, m2 = this.styles, c2, H2 = this.textStr, h2, q2 = r2.cache, A2 = r2.cacheKeys, v2 = b2.namespaceURI === this.SVG_NS, l2;
            g2 = E(g2, this.rotation);
            d2 = g2 * y;
            c2 = m2 && m2.fontSize;
            w(H2) && (l2 = H2.toString(), -1 === l2.indexOf("<") && (l2 = l2.replace(/[0-9]/g, "0")), l2 += ["", g2 || 0, c2, this.textWidth, m2 && m2.textOverflow].join());
            l2 && !a2 && (z = q2[l2]);
            if (!z) {
              if (v2 || r2.forExport) {
                try {
                  (h2 = this.fakeTS && function(a3) {
                    p(b2.querySelectorAll(".highcharts-text-outline"), function(g3) {
                      g3.style.display = a3;
                    });
                  }) && h2("none"), z = b2.getBBox ? k({}, b2.getBBox()) : { width: b2.offsetWidth, height: b2.offsetHeight }, h2 && h2("");
                } catch (X) {
                }
                if (!z || 0 > z.width)
                  z = { width: 0, height: 0 };
              } else
                z = this.htmlGetBBox();
              r2.isSVG && (a2 = z.width, r2 = z.height, v2 && (z.height = r2 = { "11px,17": 14, "13px,20": 16 }[m2 && m2.fontSize + "," + Math.round(r2)] || r2), g2 && (z.width = Math.abs(r2 * Math.sin(d2)) + Math.abs(a2 * Math.cos(d2)), z.height = Math.abs(r2 * Math.cos(d2)) + Math.abs(a2 * Math.sin(d2))));
              if (l2 && 0 < z.height) {
                for (; 250 < A2.length; )
                  delete q2[A2.shift()];
                q2[l2] || A2.push(l2);
                q2[l2] = z;
              }
            }
            return z;
          },
          show: function(a2) {
            return this.attr({ visibility: a2 ? "inherit" : "visible" });
          },
          hide: function() {
            return this.attr({ visibility: "hidden" });
          },
          fadeOut: function(a2) {
            var g2 = this;
            g2.animate({ opacity: 0 }, { duration: a2 || 150, complete: function() {
              g2.attr({ y: -9999 });
            } });
          },
          add: function(a2) {
            var g2 = this.renderer, z = this.element, r2;
            a2 && (this.parentGroup = a2);
            this.parentInverted = a2 && a2.inverted;
            void 0 !== this.textStr && g2.buildText(this);
            this.added = true;
            if (!a2 || a2.handleZ || this.zIndex)
              r2 = this.zIndexSetter();
            r2 || (a2 ? a2.element : g2.box).appendChild(z);
            if (this.onAdd)
              this.onAdd();
            return this;
          },
          safeRemoveChild: function(a2) {
            var g2 = a2.parentNode;
            g2 && g2.removeChild(a2);
          },
          destroy: function() {
            var a2 = this, g2 = a2.element || {}, r2 = a2.renderer.isSVG && "SPAN" === g2.nodeName && a2.parentGroup, d2 = g2.ownerSVGElement, b2 = a2.clipPath;
            g2.onclick = g2.onmouseout = g2.onmouseover = g2.onmousemove = g2.point = null;
            M(a2);
            b2 && d2 && (p(d2.querySelectorAll("[clip-path],[CLIP-PATH]"), function(a3) {
              var g3 = a3.getAttribute("clip-path"), z = b2.element.id;
              (-1 < g3.indexOf("(#" + z + ")") || -1 < g3.indexOf('("#' + z + '")')) && a3.removeAttribute("clip-path");
            }), a2.clipPath = b2.destroy());
            if (a2.stops) {
              for (d2 = 0; d2 < a2.stops.length; d2++)
                a2.stops[d2] = a2.stops[d2].destroy();
              a2.stops = null;
            }
            a2.safeRemoveChild(g2);
            for (a2.destroyShadows(); r2 && r2.div && 0 === r2.div.childNodes.length; )
              g2 = r2.parentGroup, a2.safeRemoveChild(r2.div), delete r2.div, r2 = g2;
            a2.alignTo && q(a2.renderer.alignedObjects, a2);
            N(a2, function(g3, z) {
              delete a2[z];
            });
            return null;
          },
          shadow: function(a2, g2, r2) {
            var z = [], d2, b2, m2 = this.element, k2, c2, H2, h2;
            if (!a2)
              this.destroyShadows();
            else if (!this.shadows) {
              c2 = E(a2.width, 3);
              H2 = (a2.opacity || 0.15) / c2;
              h2 = this.parentInverted ? "(-1,-1)" : "(" + E(a2.offsetX, 1) + ", " + E(a2.offsetY, 1) + ")";
              for (d2 = 1; d2 <= c2; d2++)
                b2 = m2.cloneNode(0), k2 = 2 * c2 + 1 - 2 * d2, f(b2, { stroke: a2.color || "#000000", "stroke-opacity": H2 * d2, "stroke-width": k2, transform: "translate" + h2, fill: "none" }), b2.setAttribute("class", (b2.getAttribute("class") || "") + " highcharts-shadow"), r2 && (f(b2, "height", Math.max(f(b2, "height") - k2, 0)), b2.cutHeight = k2), g2 ? g2.element.appendChild(b2) : m2.parentNode && m2.parentNode.insertBefore(b2, m2), z.push(b2);
              this.shadows = z;
            }
            return this;
          },
          destroyShadows: function() {
            p(this.shadows || [], function(a2) {
              this.safeRemoveChild(a2);
            }, this);
            this.shadows = void 0;
          },
          xGetter: function(a2) {
            "circle" === this.element.nodeName && ("x" === a2 ? a2 = "cx" : "y" === a2 && (a2 = "cy"));
            return this._defaultGetter(a2);
          },
          _defaultGetter: function(a2) {
            a2 = E(this[a2 + "Value"], this[a2], this.element ? this.element.getAttribute(a2) : null, 0);
            /^[\-0-9\.]+$/.test(a2) && (a2 = parseFloat(a2));
            return a2;
          },
          dSetter: function(a2, g2, r2) {
            a2 && a2.join && (a2 = a2.join(" "));
            /(NaN| {2}|^$)/.test(a2) && (a2 = "M 0 0");
            this[g2] !== a2 && (r2.setAttribute(g2, a2), this[g2] = a2);
          },
          dashstyleSetter: function(a2) {
            var r2, z = this["stroke-width"];
            "inherit" === z && (z = 1);
            if (a2 = a2 && a2.toLowerCase()) {
              a2 = a2.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(
                /,$/,
                ""
              ).split(",");
              for (r2 = a2.length; r2--; )
                a2[r2] = g(a2[r2]) * z;
              a2 = a2.join(",").replace(/NaN/g, "none");
              this.element.setAttribute("stroke-dasharray", a2);
            }
          },
          alignSetter: function(a2) {
            this.alignValue = a2;
            this.element.setAttribute("text-anchor", { left: "start", center: "middle", right: "end" }[a2]);
          },
          opacitySetter: function(a2, g2, r2) {
            this[g2] = a2;
            r2.setAttribute(g2, a2);
          },
          titleSetter: function(a2) {
            var g2 = this.element.getElementsByTagName("title")[0];
            g2 || (g2 = h.createElementNS(this.SVG_NS, "title"), this.element.appendChild(g2));
            g2.firstChild && g2.removeChild(g2.firstChild);
            g2.appendChild(h.createTextNode(String(E(a2), "").replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")));
          },
          textSetter: function(a2) {
            a2 !== this.textStr && (delete this.bBox, this.textStr = a2, this.added && this.renderer.buildText(this));
          },
          fillSetter: function(a2, g2, r2) {
            "string" === typeof a2 ? r2.setAttribute(g2, a2) : a2 && this.complexColor(a2, g2, r2);
          },
          visibilitySetter: function(a2, g2, r2) {
            "inherit" === a2 ? r2.removeAttribute(g2) : this[g2] !== a2 && r2.setAttribute(g2, a2);
            this[g2] = a2;
          },
          zIndexSetter: function(a2, r2) {
            var z = this.renderer, d2 = this.parentGroup, b2 = (d2 || z).element || z.box, m2, k2 = this.element, c2, H2, z = b2 === z.box;
            m2 = this.added;
            var h2;
            w(a2) ? (k2.setAttribute("data-z-index", a2), a2 = +a2, this[r2] === a2 && (m2 = false)) : w(this[r2]) && k2.removeAttribute("data-z-index");
            this[r2] = a2;
            if (m2) {
              (a2 = this.zIndex) && d2 && (d2.handleZ = true);
              r2 = b2.childNodes;
              for (h2 = r2.length - 1; 0 <= h2 && !c2; h2--)
                if (d2 = r2[h2], m2 = d2.getAttribute("data-z-index"), H2 = !w(m2), d2 !== k2) {
                  if (0 > a2 && H2 && !z && !h2)
                    b2.insertBefore(k2, r2[h2]), c2 = true;
                  else if (g(m2) <= a2 || H2 && (!w(a2) || 0 <= a2))
                    b2.insertBefore(k2, r2[h2 + 1] || null), c2 = true;
                }
              c2 || (b2.insertBefore(k2, r2[z ? 3 : 0] || null), c2 = true);
            }
            return c2;
          },
          _defaultSetter: function(a2, g2, r2) {
            r2.setAttribute(g2, a2);
          }
        });
        C.prototype.yGetter = C.prototype.xGetter;
        C.prototype.translateXSetter = C.prototype.translateYSetter = C.prototype.rotationSetter = C.prototype.verticalAlignSetter = C.prototype.rotationOriginXSetter = C.prototype.rotationOriginYSetter = C.prototype.scaleXSetter = C.prototype.scaleYSetter = C.prototype.matrixSetter = function(a2, g2) {
          this[g2] = a2;
          this.doTransform = true;
        };
        C.prototype["stroke-widthSetter"] = C.prototype.strokeSetter = function(a2, g2, r2) {
          this[g2] = a2;
          this.stroke && this["stroke-width"] ? (C.prototype.fillSetter.call(this, this.stroke, "stroke", r2), r2.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = true) : "stroke-width" === g2 && 0 === a2 && this.hasStroke && (r2.removeAttribute("stroke"), this.hasStroke = false);
        };
        F = a.SVGRenderer = function() {
          this.init.apply(this, arguments);
        };
        k(F.prototype, { Element: C, SVG_NS: H, init: function(a2, g2, r2, d2, b2, k2) {
          var z;
          d2 = this.createElement("svg").attr({ version: "1.1", "class": "highcharts-root" }).css(this.getStyle(d2));
          z = d2.element;
          a2.appendChild(z);
          f(a2, "dir", "ltr");
          -1 === a2.innerHTML.indexOf("xmlns") && f(z, "xmlns", this.SVG_NS);
          this.isSVG = true;
          this.box = z;
          this.boxWrapper = d2;
          this.alignedObjects = [];
          this.url = (l || m) && h.getElementsByTagName("base").length ? Q.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
          this.createElement("desc").add().element.appendChild(h.createTextNode("Created with Highcharts 6.2.0"));
          this.defs = this.createElement("defs").add();
          this.allowHTML = k2;
          this.forExport = b2;
          this.gradients = {};
          this.cache = {};
          this.cacheKeys = [];
          this.imgCount = 0;
          this.setSize(
            g2,
            r2,
            false
          );
          var c2;
          l && a2.getBoundingClientRect && (g2 = function() {
            x(a2, { left: 0, top: 0 });
            c2 = a2.getBoundingClientRect();
            x(a2, { left: Math.ceil(c2.left) - c2.left + "px", top: Math.ceil(c2.top) - c2.top + "px" });
          }, g2(), this.unSubPixelFix = I(Q, "resize", g2));
        }, getStyle: function(a2) {
          return this.style = k({ fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px" }, a2);
        }, setStyle: function(a2) {
          this.boxWrapper.css(this.getStyle(a2));
        }, isHidden: function() {
          return !this.boxWrapper.getBBox().width;
        }, destroy: function() {
          var a2 = this.defs;
          this.box = null;
          this.boxWrapper = this.boxWrapper.destroy();
          c(this.gradients || {});
          this.gradients = null;
          a2 && (this.defs = a2.destroy());
          this.unSubPixelFix && this.unSubPixelFix();
          return this.alignedObjects = null;
        }, createElement: function(a2) {
          var g2 = new this.Element();
          g2.init(this, a2);
          return g2;
        }, draw: A, getRadialAttr: function(a2, g2) {
          return { cx: a2[0] - a2[2] / 2 + g2.cx * a2[2], cy: a2[1] - a2[2] / 2 + g2.cy * a2[2], r: g2.r * a2[2] };
        }, truncate: function(a2, g2, r2, d2, b2, m2, k2) {
          var z = this, c2 = a2.rotation, H2, q2 = d2 ? 1 : 0, A2 = (r2 || d2).length, v2 = A2, p2 = [], l2 = function(a3) {
            g2.firstChild && g2.removeChild(g2.firstChild);
            a3 && g2.appendChild(h.createTextNode(a3));
          }, O2 = function(m3, c3) {
            c3 = c3 || m3;
            if (void 0 === p2[c3])
              if (g2.getSubStringLength)
                try {
                  p2[c3] = b2 + g2.getSubStringLength(0, d2 ? c3 + 1 : c3);
                } catch (Y) {
                }
              else
                z.getSpanWidth && (l2(k2(r2 || d2, m3)), p2[c3] = b2 + z.getSpanWidth(a2, g2));
            return p2[c3];
          }, G2, M2;
          a2.rotation = 0;
          G2 = O2(g2.textContent.length);
          if (M2 = b2 + G2 > m2) {
            for (; q2 <= A2; )
              v2 = Math.ceil((q2 + A2) / 2), d2 && (H2 = k2(d2, v2)), G2 = O2(v2, H2 && H2.length - 1), q2 === A2 ? q2 = A2 + 1 : G2 > m2 ? A2 = v2 - 1 : q2 = v2;
            0 === A2 ? l2("") : r2 && A2 === r2.length - 1 || l2(H2 || k2(r2 || d2, v2));
          }
          d2 && d2.splice(0, v2);
          a2.actualWidth = G2;
          a2.rotation = c2;
          return M2;
        }, escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, buildText: function(a2) {
          var r2 = a2.element, b2 = this, m2 = b2.forExport, c2 = E(a2.textStr, "").toString(), z = -1 !== c2.indexOf("<"), k2 = r2.childNodes, q2, A2 = f(r2, "x"), l2 = a2.styles, G2 = a2.textWidth, M2 = l2 && l2.lineHeight, e2 = l2 && l2.textOutline, B2 = l2 && "ellipsis" === l2.textOverflow, R2 = l2 && "nowrap" === l2.whiteSpace, y2 = l2 && l2.fontSize, t2, D2, J2 = k2.length, l2 = G2 && !a2.added && this.box, w2 = function(a3) {
            var d2;
            d2 = /(px|em)$/.test(a3 && a3.style.fontSize) ? a3.style.fontSize : y2 || b2.style.fontSize || 12;
            return M2 ? g(M2) : b2.fontMetrics(d2, a3.getAttribute("style") ? a3 : r2).h;
          }, Q2 = function(a3, g2) {
            N(b2.escapes, function(r3, d2) {
              g2 && -1 !== v(r3, g2) || (a3 = a3.toString().replace(new RegExp(r3, "g"), d2));
            });
            return a3;
          }, u2 = function(a3, g2) {
            var r3;
            r3 = a3.indexOf("<");
            a3 = a3.substring(r3, a3.indexOf(">") - r3);
            r3 = a3.indexOf(g2 + "=");
            if (-1 !== r3 && (r3 = r3 + g2.length + 1, g2 = a3.charAt(r3), '"' === g2 || "'" === g2))
              return a3 = a3.substring(r3 + 1), a3.substring(0, a3.indexOf(g2));
          };
          t2 = [c2, B2, R2, M2, e2, y2, G2].join();
          if (t2 !== a2.textCache) {
            for (a2.textCache = t2; J2--; )
              r2.removeChild(k2[J2]);
            z || e2 || B2 || G2 || -1 !== c2.indexOf(" ") ? (l2 && l2.appendChild(r2), c2 = z ? c2.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [c2], c2 = d(c2, function(a3) {
              return "" !== a3;
            }), p(c2, function(g2, d2) {
              var c3, z2 = 0, k3 = 0;
              g2 = g2.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
              c3 = g2.split("|||");
              p(c3, function(g3) {
                if ("" !== g3 || 1 === c3.length) {
                  var v2 = {}, l3 = h.createElementNS(b2.SVG_NS, "tspan"), p2, M3;
                  (p2 = u2(g3, "class")) && f(l3, "class", p2);
                  if (p2 = u2(g3, "style"))
                    p2 = p2.replace(/(;| |^)color([ :])/, "$1fill$2"), f(l3, "style", p2);
                  (M3 = u2(g3, "href")) && !m2 && (f(l3, "onclick", 'location.href="' + M3 + '"'), f(l3, "class", "highcharts-anchor"), x(l3, { cursor: "pointer" }));
                  g3 = Q2(g3.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");
                  if (" " !== g3) {
                    l3.appendChild(h.createTextNode(g3));
                    z2 ? v2.dx = 0 : d2 && null !== A2 && (v2.x = A2);
                    f(l3, v2);
                    r2.appendChild(l3);
                    !z2 && D2 && (!O && m2 && x(l3, { display: "block" }), f(l3, "dy", w2(l3)));
                    if (G2) {
                      var e3 = g3.replace(/([^\^])-/g, "$1- ").split(" "), v2 = !R2 && (1 < c3.length || d2 || 1 < e3.length);
                      M3 = 0;
                      var t3 = w2(l3);
                      if (B2)
                        q2 = b2.truncate(a2, l3, g3, void 0, 0, Math.max(0, G2 - parseInt(y2 || 12, 10)), function(a3, g4) {
                          return a3.substring(0, g4) + "…";
                        });
                      else if (v2)
                        for (; e3.length; )
                          e3.length && !R2 && 0 < M3 && (l3 = h.createElementNS(H, "tspan"), f(l3, { dy: t3, x: A2 }), p2 && f(l3, "style", p2), l3.appendChild(h.createTextNode(e3.join(" ").replace(/- /g, "-"))), r2.appendChild(l3)), b2.truncate(a2, l3, null, e3, 0 === M3 ? k3 : 0, G2, function(a3, g4) {
                            return e3.slice(0, g4).join(" ").replace(/- /g, "-");
                          }), k3 = a2.actualWidth, M3++;
                    }
                    z2++;
                  }
                }
              });
              D2 = D2 || r2.childNodes.length;
            }), B2 && q2 && a2.attr("title", Q2(a2.textStr, ["&lt;", "&gt;"])), l2 && l2.removeChild(r2), e2 && a2.applyTextOutline && a2.applyTextOutline(e2)) : r2.appendChild(h.createTextNode(Q2(c2)));
          }
        }, getContrast: function(a2) {
          a2 = u(a2).rgba;
          a2[0] *= 1;
          a2[1] *= 1.2;
          a2[2] *= 0.5;
          return 459 < a2[0] + a2[1] + a2[2] ? "#000000" : "#FFFFFF";
        }, button: function(a2, g2, r2, d2, b2, c2, m2, H2, h2) {
          var z = this.label(a2, g2, r2, h2, null, null, null, null, "button"), q2 = 0;
          z.attr(G({ padding: 8, r: 2 }, b2));
          var A2, v2, l2, p2;
          b2 = G({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1,
            style: { color: "#333333", cursor: "pointer", fontWeight: "normal" }
          }, b2);
          A2 = b2.style;
          delete b2.style;
          c2 = G(b2, { fill: "#e6e6e6" }, c2);
          v2 = c2.style;
          delete c2.style;
          m2 = G(b2, { fill: "#e6ebf5", style: { color: "#000000", fontWeight: "bold" } }, m2);
          l2 = m2.style;
          delete m2.style;
          H2 = G(b2, { style: { color: "#cccccc" } }, H2);
          p2 = H2.style;
          delete H2.style;
          I(z.element, L ? "mouseover" : "mouseenter", function() {
            3 !== q2 && z.setState(1);
          });
          I(z.element, L ? "mouseout" : "mouseleave", function() {
            3 !== q2 && z.setState(q2);
          });
          z.setState = function(a3) {
            1 !== a3 && (z.state = q2 = a3);
            z.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a3 || 0]);
            z.attr([b2, c2, m2, H2][a3 || 0]).css([A2, v2, l2, p2][a3 || 0]);
          };
          z.attr(b2).css(k({ cursor: "default" }, A2));
          return z.on("click", function(a3) {
            3 !== q2 && d2.call(z, a3);
          });
        }, crispLine: function(a2, g2) {
          a2[1] === a2[4] && (a2[1] = a2[4] = Math.round(a2[1]) - g2 % 2 / 2);
          a2[2] === a2[5] && (a2[2] = a2[5] = Math.round(a2[2]) + g2 % 2 / 2);
          return a2;
        }, path: function(a2) {
          var g2 = { fill: "none" };
          J(a2) ? g2.d = a2 : B(a2) && k(g2, a2);
          return this.createElement("path").attr(g2);
        }, circle: function(a2, g2, r2) {
          a2 = B(a2) ? a2 : { x: a2, y: g2, r: r2 };
          g2 = this.createElement("circle");
          g2.xSetter = g2.ySetter = function(a3, g3, r3) {
            r3.setAttribute("c" + g3, a3);
          };
          return g2.attr(a2);
        }, arc: function(a2, g2, r2, d2, b2, c2) {
          B(a2) ? (d2 = a2, g2 = d2.y, r2 = d2.r, a2 = d2.x) : d2 = { innerR: d2, start: b2, end: c2 };
          a2 = this.symbol("arc", a2, g2, r2, r2, d2);
          a2.r = r2;
          return a2;
        }, rect: function(a2, g2, r2, d2, b2, c2) {
          b2 = B(a2) ? a2.r : b2;
          var m2 = this.createElement("rect");
          a2 = B(a2) ? a2 : void 0 === a2 ? {} : { x: a2, y: g2, width: Math.max(r2, 0), height: Math.max(d2, 0) };
          void 0 !== c2 && (a2.strokeWidth = c2, a2 = m2.crisp(a2));
          a2.fill = "none";
          b2 && (a2.r = b2);
          m2.rSetter = function(a3, g3, r3) {
            f(r3, { rx: a3, ry: a3 });
          };
          return m2.attr(a2);
        }, setSize: function(a2, g2, r2) {
          var d2 = this.alignedObjects, b2 = d2.length;
          this.width = a2;
          this.height = g2;
          for (this.boxWrapper.animate({ width: a2, height: g2 }, { step: function() {
            this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
          }, duration: E(r2, true) ? void 0 : 0 }); b2--; )
            d2[b2].align();
        }, g: function(a2) {
          var g2 = this.createElement("g");
          return a2 ? g2.attr({ "class": "highcharts-" + a2 }) : g2;
        }, image: function(a2, g2, r2, d2, b2, c2) {
          var m2 = { preserveAspectRatio: "none" }, H2, h2 = function(a3, g3) {
            a3.setAttributeNS ? a3.setAttributeNS("http://www.w3.org/1999/xlink", "href", g3) : a3.setAttribute(
              "hc-svg-href",
              g3
            );
          }, q2 = function(g3) {
            h2(H2.element, a2);
            c2.call(H2, g3);
          };
          1 < arguments.length && k(m2, { x: g2, y: r2, width: d2, height: b2 });
          H2 = this.createElement("image").attr(m2);
          c2 ? (h2(H2.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), m2 = new Q.Image(), I(m2, "load", q2), m2.src = a2, m2.complete && q2({})) : h2(H2.element, a2);
          return H2;
        }, symbol: function(a2, g2, r2, d2, b2, c2) {
          var m2 = this, H2, q2 = /^url\((.*?)\)$/, A2 = q2.test(a2), v2 = !A2 && (this.symbols[a2] ? a2 : "circle"), z = v2 && this.symbols[v2], l2 = w(g2) && z && z.call(
            this.symbols,
            Math.round(g2),
            Math.round(r2),
            d2,
            b2,
            c2
          ), G2, M2;
          z ? (H2 = this.path(l2), H2.attr("fill", "none"), k(H2, { symbolName: v2, x: g2, y: r2, width: d2, height: b2 }), c2 && k(H2, c2)) : A2 && (G2 = a2.match(q2)[1], H2 = this.image(G2), H2.imgwidth = E(R[G2] && R[G2].width, c2 && c2.width), H2.imgheight = E(R[G2] && R[G2].height, c2 && c2.height), M2 = function() {
            H2.attr({ width: H2.width, height: H2.height });
          }, p(["width", "height"], function(a3) {
            H2[a3 + "Setter"] = function(a4, g3) {
              var r3 = {}, d3 = this["img" + g3], b3 = "width" === g3 ? "translateX" : "translateY";
              this[g3] = a4;
              w(d3) && (this.element && this.element.setAttribute(g3, d3), this.alignByTranslate || (r3[b3] = ((this[g3] || 0) - d3) / 2, this.attr(r3)));
            };
          }), w(g2) && H2.attr({ x: g2, y: r2 }), H2.isImg = true, w(H2.imgwidth) && w(H2.imgheight) ? M2() : (H2.attr({ width: 0, height: 0 }), t("img", { onload: function() {
            var a3 = e[m2.chartIndex];
            0 === this.width && (x(this, { position: "absolute", top: "-999em" }), h.body.appendChild(this));
            R[G2] = { width: this.width, height: this.height };
            H2.imgwidth = this.width;
            H2.imgheight = this.height;
            H2.element && M2();
            this.parentNode && this.parentNode.removeChild(this);
            m2.imgCount--;
            if (!m2.imgCount && a3 && a3.onload)
              a3.onload();
          }, src: G2 }), this.imgCount++));
          return H2;
        }, symbols: { circle: function(a2, g2, r2, d2) {
          return this.arc(a2 + r2 / 2, g2 + d2 / 2, r2 / 2, d2 / 2, { start: 0, end: 2 * Math.PI, open: false });
        }, square: function(a2, g2, r2, d2) {
          return ["M", a2, g2, "L", a2 + r2, g2, a2 + r2, g2 + d2, a2, g2 + d2, "Z"];
        }, triangle: function(a2, g2, r2, d2) {
          return ["M", a2 + r2 / 2, g2, "L", a2 + r2, g2 + d2, a2, g2 + d2, "Z"];
        }, "triangle-down": function(a2, g2, r2, d2) {
          return ["M", a2, g2, "L", a2 + r2, g2, a2 + r2 / 2, g2 + d2, "Z"];
        }, diamond: function(a2, g2, r2, d2) {
          return ["M", a2 + r2 / 2, g2, "L", a2 + r2, g2 + d2 / 2, a2 + r2 / 2, g2 + d2, a2, g2 + d2 / 2, "Z"];
        }, arc: function(a2, g2, r2, d2, b2) {
          var c2 = b2.start, m2 = b2.r || r2, H2 = b2.r || d2 || r2, k2 = b2.end - 1e-3;
          r2 = b2.innerR;
          d2 = E(
            b2.open,
            1e-3 > Math.abs(b2.end - b2.start - 2 * Math.PI)
          );
          var h2 = Math.cos(c2), q2 = Math.sin(c2), A2 = Math.cos(k2), k2 = Math.sin(k2);
          b2 = 1e-3 > b2.end - c2 - Math.PI ? 0 : 1;
          m2 = ["M", a2 + m2 * h2, g2 + H2 * q2, "A", m2, H2, 0, b2, 1, a2 + m2 * A2, g2 + H2 * k2];
          w(r2) && m2.push(d2 ? "M" : "L", a2 + r2 * A2, g2 + r2 * k2, "A", r2, r2, 0, b2, 0, a2 + r2 * h2, g2 + r2 * q2);
          m2.push(d2 ? "" : "Z");
          return m2;
        }, callout: function(a2, g2, r2, d2, b2) {
          var c2 = Math.min(b2 && b2.r || 0, r2, d2), m2 = c2 + 6, H2 = b2 && b2.anchorX;
          b2 = b2 && b2.anchorY;
          var k2;
          k2 = [
            "M",
            a2 + c2,
            g2,
            "L",
            a2 + r2 - c2,
            g2,
            "C",
            a2 + r2,
            g2,
            a2 + r2,
            g2,
            a2 + r2,
            g2 + c2,
            "L",
            a2 + r2,
            g2 + d2 - c2,
            "C",
            a2 + r2,
            g2 + d2,
            a2 + r2,
            g2 + d2,
            a2 + r2 - c2,
            g2 + d2,
            "L",
            a2 + c2,
            g2 + d2,
            "C",
            a2,
            g2 + d2,
            a2,
            g2 + d2,
            a2,
            g2 + d2 - c2,
            "L",
            a2,
            g2 + c2,
            "C",
            a2,
            g2,
            a2,
            g2,
            a2 + c2,
            g2
          ];
          H2 && H2 > r2 ? b2 > g2 + m2 && b2 < g2 + d2 - m2 ? k2.splice(13, 3, "L", a2 + r2, b2 - 6, a2 + r2 + 6, b2, a2 + r2, b2 + 6, a2 + r2, g2 + d2 - c2) : k2.splice(13, 3, "L", a2 + r2, d2 / 2, H2, b2, a2 + r2, d2 / 2, a2 + r2, g2 + d2 - c2) : H2 && 0 > H2 ? b2 > g2 + m2 && b2 < g2 + d2 - m2 ? k2.splice(33, 3, "L", a2, b2 + 6, a2 - 6, b2, a2, b2 - 6, a2, g2 + c2) : k2.splice(33, 3, "L", a2, d2 / 2, H2, b2, a2, d2 / 2, a2, g2 + c2) : b2 && b2 > d2 && H2 > a2 + m2 && H2 < a2 + r2 - m2 ? k2.splice(23, 3, "L", H2 + 6, g2 + d2, H2, g2 + d2 + 6, H2 - 6, g2 + d2, a2 + c2, g2 + d2) : b2 && 0 > b2 && H2 > a2 + m2 && H2 < a2 + r2 - m2 && k2.splice(3, 3, "L", H2 - 6, g2, H2, g2 - 6, H2 + 6, g2, r2 - c2, g2);
          return k2;
        } }, clipRect: function(g2, r2, d2, b2) {
          var c2 = a.uniqueKey(), m2 = this.createElement("clipPath").attr({ id: c2 }).add(this.defs);
          g2 = this.rect(g2, r2, d2, b2, 0).add(m2);
          g2.id = c2;
          g2.clipPath = m2;
          g2.count = 0;
          return g2;
        }, text: function(a2, g2, r2, d2) {
          var b2 = {};
          if (d2 && (this.allowHTML || !this.forExport))
            return this.html(a2, g2, r2);
          b2.x = Math.round(g2 || 0);
          r2 && (b2.y = Math.round(r2));
          w(a2) && (b2.text = a2);
          a2 = this.createElement("text").attr(b2);
          d2 || (a2.xSetter = function(a3, g3, r3) {
            var d3 = r3.getElementsByTagName("tspan"), b3, c2 = r3.getAttribute(g3), m2;
            for (m2 = 0; m2 < d3.length; m2++)
              b3 = d3[m2], b3.getAttribute(g3) === c2 && b3.setAttribute(g3, a3);
            r3.setAttribute(g3, a3);
          });
          return a2;
        }, fontMetrics: function(a2, r2) {
          a2 = a2 || r2 && r2.style && r2.style.fontSize || this.style && this.style.fontSize;
          a2 = /px/.test(a2) ? g(a2) : /em/.test(a2) ? parseFloat(a2) * (r2 ? this.fontMetrics(null, r2.parentNode).f : 16) : 12;
          r2 = 24 > a2 ? a2 + 3 : Math.round(1.2 * a2);
          return { h: r2, b: Math.round(0.8 * r2), f: a2 };
        }, rotCorr: function(a2, g2, r2) {
          var d2 = a2;
          g2 && r2 && (d2 = Math.max(d2 * Math.cos(g2 * y), 4));
          return { x: -a2 / 3 * Math.sin(g2 * y), y: d2 };
        }, label: function(g2, d2, b2, c2, m2, H2, h2, q2, A2) {
          var v2 = this, l2 = v2.g("button" !== A2 && "label"), M2 = l2.text = v2.text("", 0, 0, h2).attr({ zIndex: 1 }), O2, z, e2 = 0, B2 = 3, R2 = 0, f2, y2, t2, D2, J2, E2 = {}, N2, x2, Q2 = /^url\((.*?)\)$/.test(c2), u2 = Q2, L2, n2, P, T;
          A2 && l2.addClass("highcharts-" + A2);
          u2 = Q2;
          L2 = function() {
            return (N2 || 0) % 2 / 2;
          };
          n2 = function() {
            var a2 = M2.element.style, g3 = {};
            z = (void 0 === f2 || void 0 === y2 || J2) && w(M2.textStr) && M2.getBBox();
            l2.width = (f2 || z.width || 0) + 2 * B2 + R2;
            l2.height = (y2 || z.height || 0) + 2 * B2;
            x2 = B2 + v2.fontMetrics(a2 && a2.fontSize, M2).b;
            u2 && (O2 || (l2.box = O2 = v2.symbols[c2] || Q2 ? v2.symbol(c2) : v2.rect(), O2.addClass(("button" === A2 ? "" : "highcharts-label-box") + (A2 ? " highcharts-" + A2 + "-box" : "")), O2.add(l2), a2 = L2(), g3.x = a2, g3.y = (q2 ? -x2 : 0) + a2), g3.width = Math.round(l2.width), g3.height = Math.round(l2.height), O2.attr(k(
              g3,
              E2
            )), E2 = {});
          };
          P = function() {
            var a2 = R2 + B2, g3;
            g3 = q2 ? 0 : x2;
            w(f2) && z && ("center" === J2 || "right" === J2) && (a2 += { center: 0.5, right: 1 }[J2] * (f2 - z.width));
            if (a2 !== M2.x || g3 !== M2.y)
              M2.attr("x", a2), M2.hasBoxWidthChanged && (z = M2.getBBox(true), n2()), void 0 !== g3 && M2.attr("y", g3);
            M2.x = a2;
            M2.y = g3;
          };
          T = function(a2, g3) {
            O2 ? O2.attr(a2, g3) : E2[a2] = g3;
          };
          l2.onAdd = function() {
            M2.add(l2);
            l2.attr({ text: g2 || 0 === g2 ? g2 : "", x: d2, y: b2 });
            O2 && w(m2) && l2.attr({ anchorX: m2, anchorY: H2 });
          };
          l2.widthSetter = function(g3) {
            f2 = a.isNumber(g3) ? g3 : null;
          };
          l2.heightSetter = function(a2) {
            y2 = a2;
          };
          l2["text-alignSetter"] = function(a2) {
            J2 = a2;
          };
          l2.paddingSetter = function(a2) {
            w(a2) && a2 !== B2 && (B2 = l2.padding = a2, P());
          };
          l2.paddingLeftSetter = function(a2) {
            w(a2) && a2 !== R2 && (R2 = a2, P());
          };
          l2.alignSetter = function(a2) {
            a2 = { left: 0, center: 0.5, right: 1 }[a2];
            a2 !== e2 && (e2 = a2, z && l2.attr({ x: t2 }));
          };
          l2.textSetter = function(a2) {
            void 0 !== a2 && M2.textSetter(a2);
            n2();
            P();
          };
          l2["stroke-widthSetter"] = function(a2, g3) {
            a2 && (u2 = true);
            N2 = this["stroke-width"] = a2;
            T(g3, a2);
          };
          l2.strokeSetter = l2.fillSetter = l2.rSetter = function(a2, g3) {
            "r" !== g3 && ("fill" === g3 && a2 && (u2 = true), l2[g3] = a2);
            T(g3, a2);
          };
          l2.anchorXSetter = function(a2, g3) {
            m2 = l2.anchorX = a2;
            T(g3, Math.round(a2) - L2() - t2);
          };
          l2.anchorYSetter = function(a2, g3) {
            H2 = l2.anchorY = a2;
            T(g3, a2 - D2);
          };
          l2.xSetter = function(a2) {
            l2.x = a2;
            e2 && (a2 -= e2 * ((f2 || z.width) + 2 * B2), l2["forceAnimate:x"] = true);
            t2 = Math.round(a2);
            l2.attr("translateX", t2);
          };
          l2.ySetter = function(a2) {
            D2 = l2.y = Math.round(a2);
            l2.attr("translateY", D2);
          };
          var V = l2.css;
          return k(l2, { css: function(a2) {
            if (a2) {
              var g3 = {};
              a2 = G(a2);
              p(l2.textProps, function(r2) {
                void 0 !== a2[r2] && (g3[r2] = a2[r2], delete a2[r2]);
              });
              M2.css(g3);
              "width" in g3 && n2();
            }
            return V.call(l2, a2);
          }, getBBox: function() {
            return { width: z.width + 2 * B2, height: z.height + 2 * B2, x: z.x - B2, y: z.y - B2 };
          }, shadow: function(a2) {
            a2 && (n2(), O2 && O2.shadow(a2));
            return l2;
          }, destroy: function() {
            r(l2.element, "mouseenter");
            r(l2.element, "mouseleave");
            M2 && (M2 = M2.destroy());
            O2 && (O2 = O2.destroy());
            C.prototype.destroy.call(l2);
            l2 = v2 = n2 = P = T = null;
          } });
        } });
        a.Renderer = F;
      })(K);
      (function(a) {
        var C = a.attr, F = a.createElement, I = a.css, n = a.defined, f = a.each, e = a.extend, u = a.isFirefox, x = a.isMS, t = a.isWebKit, w = a.pick, y = a.pInt, c = a.SVGRenderer, h = a.win, p = a.wrap;
        e(a.SVGElement.prototype, { htmlCss: function(a2) {
          var c2 = "SPAN" === this.element.tagName && a2 && "width" in a2, d = w(c2 && a2.width, void 0);
          c2 && (delete a2.width, this.textWidth = d, this.htmlUpdateTransform());
          a2 && "ellipsis" === a2.textOverflow && (a2.whiteSpace = "nowrap", a2.overflow = "hidden");
          this.styles = e(this.styles, a2);
          I(this.element, a2);
          return this;
        }, htmlGetBBox: function() {
          var a2 = this.element;
          return { x: a2.offsetLeft, y: a2.offsetTop, width: a2.offsetWidth, height: a2.offsetHeight };
        }, htmlUpdateTransform: function() {
          if (this.added) {
            var a2 = this.renderer, c2 = this.element, d = this.translateX || 0, b = this.translateY || 0, h2 = this.x || 0, p2 = this.y || 0, l = this.textAlign || "left", e2 = { left: 0, center: 0.5, right: 1 }[l], B = this.styles, t2 = B && B.whiteSpace;
            I(c2, { marginLeft: d, marginTop: b });
            this.shadows && f(this.shadows, function(a3) {
              I(a3, { marginLeft: d + 1, marginTop: b + 1 });
            });
            this.inverted && f(c2.childNodes, function(d2) {
              a2.invertChild(d2, c2);
            });
            if ("SPAN" === c2.tagName) {
              var B = this.rotation, m = this.textWidth && y(this.textWidth), G = [B, l, c2.innerHTML, this.textWidth, this.textAlign].join(), A;
              (A = m !== this.oldTextWidth) && !(A = m > this.oldTextWidth) && ((A = this.textPxLength) || (I(c2, { width: "", whiteSpace: t2 || "nowrap" }), A = c2.offsetWidth), A = A > m);
              A && /[ \-]/.test(c2.textContent || c2.innerText) ? (I(c2, { width: m + "px", display: "block", whiteSpace: t2 || "normal" }), this.oldTextWidth = m, this.hasBoxWidthChanged = true) : this.hasBoxWidthChanged = false;
              G !== this.cTT && (t2 = a2.fontMetrics(c2.style.fontSize).b, !n(B) || B === (this.oldRotation || 0) && l === this.oldAlign || this.setSpanRotation(B, e2, t2), this.getSpanCorrection(!n(B) && this.textPxLength || c2.offsetWidth, t2, e2, B, l));
              I(c2, { left: h2 + (this.xCorr || 0) + "px", top: p2 + (this.yCorr || 0) + "px" });
              this.cTT = G;
              this.oldRotation = B;
              this.oldAlign = l;
            }
          } else
            this.alignOnAdd = true;
        }, setSpanRotation: function(a2, c2, d) {
          var b = {}, k = this.renderer.getTransformKey();
          b[k] = b.transform = "rotate(" + a2 + "deg)";
          b[k + (u ? "Origin" : "-origin")] = b.transformOrigin = 100 * c2 + "% " + d + "px";
          I(this.element, b);
        }, getSpanCorrection: function(a2, c2, d) {
          this.xCorr = -a2 * d;
          this.yCorr = -c2;
        } });
        e(c.prototype, { getTransformKey: function() {
          return x && !/Edge/.test(h.navigator.userAgent) ? "-ms-transform" : t ? "-webkit-transform" : u ? "MozTransform" : h.opera ? "-o-transform" : "";
        }, html: function(a2, c2, d) {
          var b = this.createElement("span"), k = b.element, h2 = b.renderer, l = h2.isSVG, q = function(a3, d2) {
            f(["opacity", "visibility"], function(b2) {
              p(a3, b2 + "Setter", function(a4, b3, c3, m) {
                a4.call(this, b3, c3, m);
                d2[c3] = b3;
              });
            });
            a3.addedSetters = true;
          };
          b.textSetter = function(a3) {
            a3 !== k.innerHTML && delete this.bBox;
            this.textStr = a3;
            k.innerHTML = w(a3, "");
            b.doTransform = true;
          };
          l && q(b, b.element.style);
          b.xSetter = b.ySetter = b.alignSetter = b.rotationSetter = function(a3, d2) {
            "align" === d2 && (d2 = "textAlign");
            b[d2] = a3;
            b.doTransform = true;
          };
          b.afterSetters = function() {
            this.doTransform && (this.htmlUpdateTransform(), this.doTransform = false);
          };
          b.attr({ text: a2, x: Math.round(c2), y: Math.round(d) }).css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize, position: "absolute" });
          k.style.whiteSpace = "nowrap";
          b.css = b.htmlCss;
          l && (b.add = function(a3) {
            var d2, c3 = h2.box.parentNode, l2 = [];
            if (this.parentGroup = a3) {
              if (d2 = a3.div, !d2) {
                for (; a3; )
                  l2.push(a3), a3 = a3.parentGroup;
                f(l2.reverse(), function(a4) {
                  function m(g2, d3) {
                    a4[d3] = g2;
                    "translateX" === d3 ? k2.left = g2 + "px" : k2.top = g2 + "px";
                    a4.doTransform = true;
                  }
                  var k2, g = C(a4.element, "class");
                  g && (g = { className: g });
                  d2 = a4.div = a4.div || F("div", g, {
                    position: "absolute",
                    left: (a4.translateX || 0) + "px",
                    top: (a4.translateY || 0) + "px",
                    display: a4.display,
                    opacity: a4.opacity,
                    pointerEvents: a4.styles && a4.styles.pointerEvents
                  }, d2 || c3);
                  k2 = d2.style;
                  e(a4, { classSetter: function(a5) {
                    return function(g2) {
                      this.element.setAttribute("class", g2);
                      a5.className = g2;
                    };
                  }(d2), on: function() {
                    l2[0].div && b.on.apply({ element: l2[0].div }, arguments);
                    return a4;
                  }, translateXSetter: m, translateYSetter: m });
                  a4.addedSetters || q(a4, k2);
                });
              }
            } else
              d2 = c3;
            d2.appendChild(k);
            b.added = true;
            b.alignOnAdd && b.htmlUpdateTransform();
            return b;
          });
          return b;
        } });
      })(K);
      (function(a) {
        var C = a.defined, F = a.each, I = a.extend, n = a.merge, f = a.pick, e = a.timeUnits, u = a.win;
        a.Time = function(a2) {
          this.update(a2, false);
        };
        a.Time.prototype = { defaultOptions: {}, update: function(a2) {
          var e2 = f(a2 && a2.useUTC, true), w = this;
          this.options = a2 = n(true, this.options || {}, a2);
          this.Date = a2.Date || u.Date;
          this.timezoneOffset = (this.useUTC = e2) && a2.timezoneOffset;
          this.getTimezoneOffset = this.timezoneOffsetFunction();
          (this.variableTimezone = !(e2 && !a2.getTimezoneOffset && !a2.timezone)) || this.timezoneOffset ? (this.get = function(a3, c) {
            var h = c.getTime(), p = h - w.getTimezoneOffset(c);
            c.setTime(p);
            a3 = c["getUTC" + a3]();
            c.setTime(h);
            return a3;
          }, this.set = function(a3, c, h) {
            var p;
            if ("Milliseconds" === a3 || "Seconds" === a3 || "Minutes" === a3 && 0 === c.getTimezoneOffset() % 60)
              c["set" + a3](h);
            else
              p = w.getTimezoneOffset(c), p = c.getTime() - p, c.setTime(p), c["setUTC" + a3](h), a3 = w.getTimezoneOffset(c), p = c.getTime() + a3, c.setTime(p);
          }) : e2 ? (this.get = function(a3, c) {
            return c["getUTC" + a3]();
          }, this.set = function(a3, c, h) {
            return c["setUTC" + a3](h);
          }) : (this.get = function(a3, c) {
            return c["get" + a3]();
          }, this.set = function(a3, c, h) {
            return c["set" + a3](h);
          });
        }, makeTime: function(e2, t, w, y, c, h) {
          var p, k, q;
          this.useUTC ? (p = this.Date.UTC.apply(0, arguments), k = this.getTimezoneOffset(p), p += k, q = this.getTimezoneOffset(p), k !== q ? p += q - k : k - 36e5 !== this.getTimezoneOffset(p - 36e5) || a.isSafari || (p -= 36e5)) : p = new this.Date(e2, t, f(w, 1), f(y, 0), f(c, 0), f(h, 0)).getTime();
          return p;
        }, timezoneOffsetFunction: function() {
          var e2 = this, f2 = this.options, w = u.moment;
          if (!this.useUTC)
            return function(a2) {
              return 6e4 * new Date(a2).getTimezoneOffset();
            };
          if (f2.timezone) {
            if (w)
              return function(a2) {
                return 6e4 * -w.tz(a2, f2.timezone).utcOffset();
              };
            a.error(25);
          }
          return this.useUTC && f2.getTimezoneOffset ? function(a2) {
            return 6e4 * f2.getTimezoneOffset(a2);
          } : function() {
            return 6e4 * (e2.timezoneOffset || 0);
          };
        }, dateFormat: function(e2, f2, w) {
          if (!a.defined(f2) || isNaN(f2))
            return a.defaultOptions.lang.invalidDate || "";
          e2 = a.pick(e2, "%Y-%m-%d %H:%M:%S");
          var t = this, c = new this.Date(f2), h = this.get("Hours", c), p = this.get("Day", c), k = this.get("Date", c), q = this.get("Month", c), d = this.get("FullYear", c), b = a.defaultOptions.lang, v = b.weekdays, J = b.shortWeekdays, l = a.pad, c = a.extend({ a: J ? J[p] : v[p].substr(0, 3), A: v[p], d: l(k), e: l(k, 2, " "), w: p, b: b.shortMonths[q], B: b.months[q], m: l(q + 1), o: q + 1, y: d.toString().substr(2, 2), Y: d, H: l(h), k: h, I: l(h % 12 || 12), l: h % 12 || 12, M: l(t.get("Minutes", c)), p: 12 > h ? "AM" : "PM", P: 12 > h ? "am" : "pm", S: l(c.getSeconds()), L: l(Math.floor(f2 % 1e3), 3) }, a.dateFormats);
          a.objectEach(c, function(a2, d2) {
            for (; -1 !== e2.indexOf("%" + d2); )
              e2 = e2.replace("%" + d2, "function" === typeof a2 ? a2.call(t, f2) : a2);
          });
          return w ? e2.substr(0, 1).toUpperCase() + e2.substr(1) : e2;
        }, resolveDTLFormat: function(e2) {
          return a.isObject(
            e2,
            true
          ) ? e2 : (e2 = a.splat(e2), { main: e2[0], from: e2[1], to: e2[2] });
        }, getTimeTicks: function(a2, t, w, y) {
          var c = this, h = [], p, k = {}, q;
          p = new c.Date(t);
          var d = a2.unitRange, b = a2.count || 1, v;
          y = f(y, 1);
          if (C(t)) {
            c.set("Milliseconds", p, d >= e.second ? 0 : b * Math.floor(c.get("Milliseconds", p) / b));
            d >= e.second && c.set("Seconds", p, d >= e.minute ? 0 : b * Math.floor(c.get("Seconds", p) / b));
            d >= e.minute && c.set("Minutes", p, d >= e.hour ? 0 : b * Math.floor(c.get("Minutes", p) / b));
            d >= e.hour && c.set("Hours", p, d >= e.day ? 0 : b * Math.floor(c.get("Hours", p) / b));
            d >= e.day && c.set(
              "Date",
              p,
              d >= e.month ? 1 : b * Math.floor(c.get("Date", p) / b)
            );
            d >= e.month && (c.set("Month", p, d >= e.year ? 0 : b * Math.floor(c.get("Month", p) / b)), q = c.get("FullYear", p));
            d >= e.year && c.set("FullYear", p, q - q % b);
            d === e.week && (q = c.get("Day", p), c.set("Date", p, c.get("Date", p) - q + y + (q < y ? -7 : 0)));
            q = c.get("FullYear", p);
            y = c.get("Month", p);
            var J = c.get("Date", p), l = c.get("Hours", p);
            t = p.getTime();
            c.variableTimezone && (v = w - t > 4 * e.month || c.getTimezoneOffset(t) !== c.getTimezoneOffset(w));
            t = p.getTime();
            for (p = 1; t < w; )
              h.push(t), t = d === e.year ? c.makeTime(q + p * b, 0) : d === e.month ? c.makeTime(q, y + p * b) : !v || d !== e.day && d !== e.week ? v && d === e.hour && 1 < b ? c.makeTime(q, y, J, l + p * b) : t + d * b : c.makeTime(q, y, J + p * b * (d === e.day ? 1 : 7)), p++;
            h.push(t);
            d <= e.hour && 1e4 > h.length && F(h, function(a3) {
              0 === a3 % 18e5 && "000000000" === c.dateFormat("%H%M%S%L", a3) && (k[a3] = "day");
            });
          }
          h.info = I(a2, { higherRanks: k, totalRange: d * b });
          return h;
        } };
      })(K);
      (function(a) {
        var C = a.color, F = a.merge;
        a.defaultOptions = {
          colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
          symbols: [
            "circle",
            "diamond",
            "square",
            "triangle",
            "triangle-down"
          ],
          lang: { loading: "Loading...", months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint: ".", numericSymbols: "kMGTPE".split(""), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " },
          global: {},
          time: a.Time.prototype.defaultOptions,
          chart: { borderRadius: 0, defaultSeriesType: "line", ignoreHiddenSeries: true, spacing: [10, 10, 15, 10], resetZoomButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } }, width: null, height: null, borderColor: "#335cad", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" },
          title: { text: "Chart title", align: "center", margin: 15, widthAdjust: -44 },
          subtitle: { text: "", align: "center", widthAdjust: -44 },
          plotOptions: {},
          labels: { style: { position: "absolute", color: "#333333" } },
          legend: {
            enabled: true,
            align: "center",
            alignColumns: true,
            layout: "horizontal",
            labelFormatter: function() {
              return this.name;
            },
            borderColor: "#999999",
            borderRadius: 0,
            navigation: { activeColor: "#003399", inactiveColor: "#cccccc" },
            itemStyle: { color: "#333333", fontSize: "12px", fontWeight: "bold", textOverflow: "ellipsis" },
            itemHoverStyle: { color: "#000000" },
            itemHiddenStyle: { color: "#cccccc" },
            shadow: false,
            itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" },
            squareSymbol: true,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: { style: { fontWeight: "bold" } }
          },
          loading: { labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } },
          tooltip: {
            enabled: true,
            animation: a.svg,
            borderRadius: 3,
            dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" },
            footerFormat: "",
            padding: 8,
            snap: a.isTouchDevice ? 25 : 10,
            backgroundColor: C("#f7f7f7").setOpacity(0.85).get(),
            borderWidth: 1,
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
            shadow: true,
            style: { color: "#333333", cursor: "default", fontSize: "12px", pointerEvents: "none", whiteSpace: "nowrap" }
          },
          credits: { enabled: true, href: "https://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "9px" }, text: "Highcharts.com" }
        };
        a.setOptions = function(C2) {
          a.defaultOptions = F(true, a.defaultOptions, C2);
          a.time.update(F(a.defaultOptions.global, a.defaultOptions.time), false);
          return a.defaultOptions;
        };
        a.getOptions = function() {
          return a.defaultOptions;
        };
        a.defaultPlotOptions = a.defaultOptions.plotOptions;
        a.time = new a.Time(F(a.defaultOptions.global, a.defaultOptions.time));
        a.dateFormat = function(C2, n, f) {
          return a.time.dateFormat(C2, n, f);
        };
      })(K);
      (function(a) {
        var C = a.correctFloat, F = a.defined, I = a.destroyObjectProperties, n = a.fireEvent, f = a.isNumber, e = a.merge, u = a.pick, x = a.deg2rad;
        a.Tick = function(a2, e2, f2, c, h) {
          this.axis = a2;
          this.pos = e2;
          this.type = f2 || "";
          this.isNewLabel = this.isNew = true;
          this.parameters = h || {};
          this.tickmarkOffset = this.parameters.tickmarkOffset;
          this.options = this.parameters.options;
          f2 || c || this.addLabel();
        };
        a.Tick.prototype = { addLabel: function() {
          var f2 = this, w = f2.axis, y = w.options, c = w.chart, h = w.categories, p = w.names, k = f2.pos, q = u(f2.options && f2.options.labels, y.labels), d = w.tickPositions, b = k === d[0], v = k === d[d.length - 1], h = this.parameters.category || (h ? u(h[k], p[k], k) : k), J = f2.label, d = d.info, l, n2, B, D;
          w.isDatetimeAxis && d && (n2 = c.time.resolveDTLFormat(y.dateTimeLabelFormats[!y.grid && d.higherRanks[k] || d.unitName]), l = n2.main);
          f2.isFirst = b;
          f2.isLast = v;
          f2.formatCtx = { axis: w, chart: c, isFirst: b, isLast: v, dateTimeLabelFormat: l, tickPositionInfo: d, value: w.isLog ? C(w.lin2log(h)) : h, pos: k };
          y = w.labelFormatter.call(f2.formatCtx, this.formatCtx);
          if (D = n2 && n2.list)
            f2.shortenLabel = function() {
              for (B = 0; B < D.length; B++)
                if (J.attr({ text: w.labelFormatter.call(a.extend(f2.formatCtx, { dateTimeLabelFormat: D[B] })) }), J.getBBox().width < w.getSlotWidth(f2) - 2 * u(q.padding, 5))
                  return;
              J.attr({ text: "" });
            };
          if (F(J))
            J && J.textStr !== y && (!J.textWidth || q.style && q.style.width || J.styles.width || J.css({ width: null }), J.attr({ text: y }));
          else {
            if (f2.label = J = F(y) && q.enabled ? c.renderer.text(y, 0, 0, q.useHTML).css(e(q.style)).add(w.labelGroup) : null)
              J.textPxLength = J.getBBox().width;
            f2.rotation = 0;
          }
        }, getLabelSize: function() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        }, handleOverflow: function(a2) {
          var e2 = this.axis, f2 = e2.options.labels, c = a2.x, h = e2.chart.chartWidth, p = e2.chart.spacing, k = u(e2.labelLeft, Math.min(e2.pos, p[3])), p = u(
            e2.labelRight,
            Math.max(e2.isRadial ? 0 : e2.pos + e2.len, h - p[1])
          ), q = this.label, d = this.rotation, b = { left: 0, center: 0.5, right: 1 }[e2.labelAlign || q.attr("align")], v = q.getBBox().width, J = e2.getSlotWidth(this), l = J, t = 1, B, D = {};
          if (d || "justify" !== u(f2.overflow, "justify"))
            0 > d && c - b * v < k ? B = Math.round(c / Math.cos(d * x) - k) : 0 < d && c + b * v > p && (B = Math.round((h - c) / Math.cos(d * x)));
          else if (h = c + (1 - b) * v, c - b * v < k ? l = a2.x + l * (1 - b) - k : h > p && (l = p - a2.x + l * b, t = -1), l = Math.min(J, l), l < J && "center" === e2.labelAlign && (a2.x += t * (J - l - b * (J - Math.min(v, l)))), v > l || e2.autoRotation && (q.styles || {}).width)
            B = l;
          B && (this.shortenLabel ? this.shortenLabel() : (D.width = B, (f2.style || {}).textOverflow || (D.textOverflow = "ellipsis"), q.css(D)));
        }, getPosition: function(e2, f2, y, c) {
          var h = this.axis, p = h.chart, k = c && p.oldChartHeight || p.chartHeight;
          e2 = { x: e2 ? a.correctFloat(h.translate(f2 + y, null, null, c) + h.transB) : h.left + h.offset + (h.opposite ? (c && p.oldChartWidth || p.chartWidth) - h.right - h.left : 0), y: e2 ? k - h.bottom + h.offset - (h.opposite ? h.height : 0) : a.correctFloat(k - h.translate(f2 + y, null, null, c) - h.transB) };
          n(
            this,
            "afterGetPosition",
            { pos: e2 }
          );
          return e2;
        }, getLabelPosition: function(a2, e2, f2, c, h, p, k, q) {
          var d = this.axis, b = d.transA, v = d.reversed, J = d.staggerLines, l = d.tickRotCorr || { x: 0, y: 0 }, t = h.y, B = c || d.reserveSpaceDefault ? 0 : -d.labelOffset * ("center" === d.labelAlign ? 0.5 : 1), D = {};
          F(t) || (t = 0 === d.side ? f2.rotation ? -8 : -f2.getBBox().height : 2 === d.side ? l.y + 8 : Math.cos(f2.rotation * x) * (l.y - f2.getBBox(false, 0).height / 2));
          a2 = a2 + h.x + B + l.x - (p && c ? p * b * (v ? -1 : 1) : 0);
          e2 = e2 + t - (p && !c ? p * b * (v ? 1 : -1) : 0);
          J && (f2 = k / (q || 1) % J, d.opposite && (f2 = J - f2 - 1), e2 += d.labelOffset / J * f2);
          D.x = a2;
          D.y = Math.round(e2);
          n(this, "afterGetLabelPosition", { pos: D });
          return D;
        }, getMarkPath: function(a2, e2, f2, c, h, p) {
          return p.crispLine(["M", a2, e2, "L", a2 + (h ? 0 : -f2), e2 + (h ? f2 : 0)], c);
        }, renderGridLine: function(a2, e2, f2) {
          var c = this.axis, h = c.options, p = this.gridLine, k = {}, q = this.pos, d = this.type, b = u(this.tickmarkOffset, c.tickmarkOffset), v = c.chart.renderer, J = d ? d + "Grid" : "grid", l = h[J + "LineWidth"], t = h[J + "LineColor"], h = h[J + "LineDashStyle"];
          p || (k.stroke = t, k["stroke-width"] = l, h && (k.dashstyle = h), d || (k.zIndex = 1), a2 && (e2 = 0), this.gridLine = p = v.path().attr(k).addClass("highcharts-" + (d ? d + "-" : "") + "grid-line").add(c.gridGroup));
          if (p && (f2 = c.getPlotLinePath(q + b, p.strokeWidth() * f2, a2, "pass")))
            p[a2 || this.isNew ? "attr" : "animate"]({ d: f2, opacity: e2 });
        }, renderMark: function(a2, e2, f2) {
          var c = this.axis, h = c.options, p = c.chart.renderer, k = this.type, q = k ? k + "Tick" : "tick", d = c.tickSize(q), b = this.mark, v = !b, J = a2.x;
          a2 = a2.y;
          var l = u(h[q + "Width"], !k && c.isXAxis ? 1 : 0), h = h[q + "Color"];
          d && (c.opposite && (d[0] = -d[0]), v && (this.mark = b = p.path().addClass("highcharts-" + (k ? k + "-" : "") + "tick").add(c.axisGroup), b.attr({ stroke: h, "stroke-width": l })), b[v ? "attr" : "animate"]({ d: this.getMarkPath(J, a2, d[0], b.strokeWidth() * f2, c.horiz, p), opacity: e2 }));
        }, renderLabel: function(a2, e2, y, c) {
          var h = this.axis, p = h.horiz, k = h.options, q = this.label, d = k.labels, b = d.step, h = u(this.tickmarkOffset, h.tickmarkOffset), v = true, J = a2.x;
          a2 = a2.y;
          q && f(J) && (q.xy = a2 = this.getLabelPosition(J, a2, q, p, d, h, c, b), this.isFirst && !this.isLast && !u(k.showFirstLabel, 1) || this.isLast && !this.isFirst && !u(k.showLastLabel, 1) ? v = false : !p || d.step || d.rotation || e2 || 0 === y || this.handleOverflow(a2), b && c % b && (v = false), v && f(a2.y) ? (a2.opacity = y, q[this.isNewLabel ? "attr" : "animate"](a2), this.isNewLabel = false) : (q.attr("y", -9999), this.isNewLabel = true));
        }, render: function(e2, f2, y) {
          var c = this.axis, h = c.horiz, p = this.pos, k = u(this.tickmarkOffset, c.tickmarkOffset), p = this.getPosition(h, p, k, f2), k = p.x, q = p.y, c = h && k === c.pos + c.len || !h && q === c.pos ? -1 : 1;
          y = u(y, 1);
          this.isActive = true;
          this.renderGridLine(f2, y, c);
          this.renderMark(p, y, c);
          this.renderLabel(p, f2, y, e2);
          this.isNew = false;
          a.fireEvent(this, "afterRender");
        }, destroy: function() {
          I(this, this.axis);
        } };
      })(K);
      var W = function(a) {
        var C = a.addEvent, F = a.animObject, I = a.arrayMax, n = a.arrayMin, f = a.color, e = a.correctFloat, u = a.defaultOptions, x = a.defined, t = a.deg2rad, w = a.destroyObjectProperties, y = a.each, c = a.extend, h = a.fireEvent, p = a.format, k = a.getMagnitude, q = a.grep, d = a.inArray, b = a.isArray, v = a.isNumber, J = a.isString, l = a.merge, L = a.normalizeTickInterval, B = a.objectEach, D = a.pick, m = a.removeEvent, G = a.splat, A = a.syncTimeout, N = a.Tick, E = function() {
          this.init.apply(this, arguments);
        };
        a.extend(E.prototype, {
          defaultOptions: { dateTimeLabelFormats: { millisecond: {
            main: "%H:%M:%S.%L",
            range: false
          }, second: { main: "%H:%M:%S", range: false }, minute: { main: "%H:%M", range: false }, hour: { main: "%H:%M", range: false }, day: { main: "%e. %b" }, week: { main: "%e. %b" }, month: { main: "%b '%y" }, year: { main: "%Y" } }, endOnTick: false, labels: { enabled: true, indentation: 10, x: 0, style: { color: "#666666", cursor: "default", fontSize: "11px" } }, maxPadding: 0.01, minorTickLength: 2, minorTickPosition: "outside", minPadding: 0.01, startOfWeek: 1, startOnTick: false, tickLength: 10, tickPixelInterval: 100, tickmarkPlacement: "between", tickPosition: "outside", title: {
            align: "middle",
            style: { color: "#666666" }
          }, type: "linear", minorGridLineColor: "#f2f2f2", minorGridLineWidth: 1, minorTickColor: "#999999", lineColor: "#ccd6eb", lineWidth: 1, gridLineColor: "#e6e6e6", tickColor: "#ccd6eb" },
          defaultYAxisOptions: { endOnTick: true, maxPadding: 0.05, minPadding: 0.05, tickPixelInterval: 72, showLastLabel: true, labels: { x: -8 }, startOnTick: true, title: { rotation: 270, text: "Values" }, stackLabels: { allowOverlap: false, enabled: false, formatter: function() {
            return a.numberFormat(this.total, -1);
          }, style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          } }, gridLineWidth: 1, lineWidth: 0 },
          defaultLeftAxisOptions: { labels: { x: -15 }, title: { rotation: 270 } },
          defaultRightAxisOptions: { labels: { x: 15 }, title: { rotation: 90 } },
          defaultBottomAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } },
          defaultTopAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } },
          init: function(a2, r) {
            var g = r.isX, b2 = this;
            b2.chart = a2;
            b2.horiz = a2.inverted && !b2.isZAxis ? !g : g;
            b2.isXAxis = g;
            b2.coll = b2.coll || (g ? "xAxis" : "yAxis");
            h(this, "init", { userOptions: r });
            b2.opposite = r.opposite;
            b2.side = r.side || (b2.horiz ? b2.opposite ? 0 : 2 : b2.opposite ? 1 : 3);
            b2.setOptions(r);
            var c2 = this.options, m2 = c2.type;
            b2.labelFormatter = c2.labels.formatter || b2.defaultLabelFormatter;
            b2.userOptions = r;
            b2.minPixelPadding = 0;
            b2.reversed = c2.reversed;
            b2.visible = false !== c2.visible;
            b2.zoomEnabled = false !== c2.zoomEnabled;
            b2.hasNames = "category" === m2 || true === c2.categories;
            b2.categories = c2.categories || b2.hasNames;
            b2.names || (b2.names = [], b2.names.keys = {});
            b2.plotLinesAndBandsGroups = {};
            b2.isLog = "logarithmic" === m2;
            b2.isDatetimeAxis = "datetime" === m2;
            b2.positiveValuesOnly = b2.isLog && !b2.allowNegativeLog;
            b2.isLinked = x(c2.linkedTo);
            b2.ticks = {};
            b2.labelEdge = [];
            b2.minorTicks = {};
            b2.plotLinesAndBands = [];
            b2.alternateBands = {};
            b2.len = 0;
            b2.minRange = b2.userMinRange = c2.minRange || c2.maxZoom;
            b2.range = c2.range;
            b2.offset = c2.offset || 0;
            b2.stacks = {};
            b2.oldStacks = {};
            b2.stacksTouched = 0;
            b2.max = null;
            b2.min = null;
            b2.crosshair = D(c2.crosshair, G(a2.options.tooltip.crosshairs)[g ? 0 : 1], false);
            r = b2.options.events;
            -1 === d(b2, a2.axes) && (g ? a2.axes.splice(a2.xAxis.length, 0, b2) : a2.axes.push(b2), a2[b2.coll].push(b2));
            b2.series = b2.series || [];
            a2.inverted && !b2.isZAxis && g && void 0 === b2.reversed && (b2.reversed = true);
            B(r, function(a3, g2) {
              C(b2, g2, a3);
            });
            b2.lin2log = c2.linearToLogConverter || b2.lin2log;
            b2.isLog && (b2.val2lin = b2.log2lin, b2.lin2val = b2.lin2log);
            h(this, "afterInit");
          },
          setOptions: function(a2) {
            this.options = l(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], l(u[this.coll], a2));
            h(this, "afterSetOptions", { userOptions: a2 });
          },
          defaultLabelFormatter: function() {
            var g = this.axis, r = this.value, b2 = g.chart.time, d2 = g.categories, c2 = this.dateTimeLabelFormat, m2 = u.lang, k2 = m2.numericSymbols, m2 = m2.numericSymbolMagnitude || 1e3, h2 = k2 && k2.length, l2, q2 = g.options.labels.format, g = g.isLog ? Math.abs(r) : g.tickInterval;
            if (q2)
              l2 = p(q2, this, b2);
            else if (d2)
              l2 = r;
            else if (c2)
              l2 = b2.dateFormat(c2, r);
            else if (h2 && 1e3 <= g)
              for (; h2-- && void 0 === l2; )
                b2 = Math.pow(m2, h2 + 1), g >= b2 && 0 === 10 * r % b2 && null !== k2[h2] && 0 !== r && (l2 = a.numberFormat(r / b2, -1) + k2[h2]);
            void 0 === l2 && (l2 = 1e4 <= Math.abs(r) ? a.numberFormat(r, -1) : a.numberFormat(r, -1, void 0, ""));
            return l2;
          },
          getSeriesExtremes: function() {
            var a2 = this, r = a2.chart;
            h(this, "getSeriesExtremes", null, function() {
              a2.hasVisibleSeries = false;
              a2.dataMin = a2.dataMax = a2.threshold = null;
              a2.softThreshold = !a2.isXAxis;
              a2.buildStacks && a2.buildStacks();
              y(a2.series, function(g) {
                if (g.visible || !r.options.chart.ignoreHiddenSeries) {
                  var b2 = g.options, d2 = b2.threshold, c2;
                  a2.hasVisibleSeries = true;
                  a2.positiveValuesOnly && 0 >= d2 && (d2 = null);
                  if (a2.isXAxis)
                    b2 = g.xData, b2.length && (g = n(b2), c2 = I(b2), v(g) || g instanceof Date || (b2 = q(b2, v), g = n(b2), c2 = I(b2)), b2.length && (a2.dataMin = Math.min(D(
                      a2.dataMin,
                      b2[0],
                      g
                    ), g), a2.dataMax = Math.max(D(a2.dataMax, b2[0], c2), c2)));
                  else if (g.getExtremes(), c2 = g.dataMax, g = g.dataMin, x(g) && x(c2) && (a2.dataMin = Math.min(D(a2.dataMin, g), g), a2.dataMax = Math.max(D(a2.dataMax, c2), c2)), x(d2) && (a2.threshold = d2), !b2.softThreshold || a2.positiveValuesOnly)
                    a2.softThreshold = false;
                }
              });
            });
            h(this, "afterGetSeriesExtremes");
          },
          translate: function(a2, r, b2, d2, c2, m2) {
            var g = this.linkedParent || this, k2 = 1, H = 0, l2 = d2 ? g.oldTransA : g.transA;
            d2 = d2 ? g.oldMin : g.min;
            var h2 = g.minPixelPadding;
            c2 = (g.isOrdinal || g.isBroken || g.isLog && c2) && g.lin2val;
            l2 || (l2 = g.transA);
            b2 && (k2 *= -1, H = g.len);
            g.reversed && (k2 *= -1, H -= k2 * (g.sector || g.len));
            r ? (a2 = (a2 * k2 + H - h2) / l2 + d2, c2 && (a2 = g.lin2val(a2))) : (c2 && (a2 = g.val2lin(a2)), a2 = v(d2) ? k2 * (a2 - d2) * l2 + H + k2 * h2 + (v(m2) ? l2 * m2 : 0) : void 0);
            return a2;
          },
          toPixels: function(a2, r) {
            return this.translate(a2, false, !this.horiz, null, true) + (r ? 0 : this.pos);
          },
          toValue: function(a2, r) {
            return this.translate(a2 - (r ? 0 : this.pos), true, !this.horiz, null, true);
          },
          getPlotLinePath: function(a2, r, b2, d2, c2) {
            var g = this.chart, m2 = this.left, k2 = this.top, H, l2, h2 = b2 && g.oldChartHeight || g.chartHeight, q2 = b2 && g.oldChartWidth || g.chartWidth, A2;
            H = this.transB;
            var e2 = function(a3, g2, r2) {
              if ("pass" !== d2 && a3 < g2 || a3 > r2)
                d2 ? a3 = Math.min(Math.max(g2, a3), r2) : A2 = true;
              return a3;
            };
            c2 = D(c2, this.translate(a2, null, null, b2));
            c2 = Math.min(Math.max(-1e5, c2), 1e5);
            a2 = b2 = Math.round(c2 + H);
            H = l2 = Math.round(h2 - c2 - H);
            v(c2) ? this.horiz ? (H = k2, l2 = h2 - this.bottom, a2 = b2 = e2(a2, m2, m2 + this.width)) : (a2 = m2, b2 = q2 - this.right, H = l2 = e2(H, k2, k2 + this.height)) : (A2 = true, d2 = false);
            return A2 && !d2 ? null : g.renderer.crispLine(["M", a2, H, "L", b2, l2], r || 1);
          },
          getLinearTickPositions: function(a2, r, b2) {
            var g, d2 = e(Math.floor(r / a2) * a2);
            b2 = e(Math.ceil(b2 / a2) * a2);
            var c2 = [], m2;
            e(d2 + a2) === d2 && (m2 = 20);
            if (this.single)
              return [r];
            for (r = d2; r <= b2; ) {
              c2.push(r);
              r = e(r + a2, m2);
              if (r === g)
                break;
              g = r;
            }
            return c2;
          },
          getMinorTickInterval: function() {
            var a2 = this.options;
            return true === a2.minorTicks ? D(a2.minorTickInterval, "auto") : false === a2.minorTicks ? null : a2.minorTickInterval;
          },
          getMinorTickPositions: function() {
            var a2 = this, r = a2.options, b2 = a2.tickPositions, d2 = a2.minorTickInterval, c2 = [], m2 = a2.pointRangePadding || 0, k2 = a2.min - m2, m2 = a2.max + m2, l2 = m2 - k2;
            if (l2 && l2 / d2 < a2.len / 3)
              if (a2.isLog)
                y(this.paddedTicks, function(g, r2, b3) {
                  r2 && c2.push.apply(
                    c2,
                    a2.getLogTickPositions(d2, b3[r2 - 1], b3[r2], true)
                  );
                });
              else if (a2.isDatetimeAxis && "auto" === this.getMinorTickInterval())
                c2 = c2.concat(a2.getTimeTicks(a2.normalizeTimeTickInterval(d2), k2, m2, r.startOfWeek));
              else
                for (r = k2 + (b2[0] - k2) % d2; r <= m2 && r !== c2[0]; r += d2)
                  c2.push(r);
            0 !== c2.length && a2.trimTicks(c2);
            return c2;
          },
          adjustForMinRange: function() {
            var a2 = this.options, r = this.min, b2 = this.max, d2, c2, m2, k2, l2, h2, q2, v2;
            this.isXAxis && void 0 === this.minRange && !this.isLog && (x(a2.min) || x(a2.max) ? this.minRange = null : (y(this.series, function(a3) {
              h2 = a3.xData;
              for (k2 = q2 = a3.xIncrement ? 1 : h2.length - 1; 0 < k2; k2--)
                if (l2 = h2[k2] - h2[k2 - 1], void 0 === m2 || l2 < m2)
                  m2 = l2;
            }), this.minRange = Math.min(5 * m2, this.dataMax - this.dataMin)));
            b2 - r < this.minRange && (c2 = this.dataMax - this.dataMin >= this.minRange, v2 = this.minRange, d2 = (v2 - b2 + r) / 2, d2 = [r - d2, D(a2.min, r - d2)], c2 && (d2[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), r = I(d2), b2 = [r + v2, D(a2.max, r + v2)], c2 && (b2[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), b2 = n(b2), b2 - r < v2 && (d2[0] = b2 - v2, d2[1] = D(a2.min, b2 - v2), r = I(d2)));
            this.min = r;
            this.max = b2;
          },
          getClosest: function() {
            var a2;
            this.categories ? a2 = 1 : y(
              this.series,
              function(g) {
                var r = g.closestPointRange, b2 = g.visible || !g.chart.options.chart.ignoreHiddenSeries;
                !g.noSharedTooltip && x(r) && b2 && (a2 = x(a2) ? Math.min(a2, r) : r);
              }
            );
            return a2;
          },
          nameToX: function(a2) {
            var g = b(this.categories), c2 = g ? this.categories : this.names, m2 = a2.options.x, k2;
            a2.series.requireSorting = false;
            x(m2) || (m2 = false === this.options.uniqueNames ? a2.series.autoIncrement() : g ? d(a2.name, c2) : D(c2.keys[a2.name], -1));
            -1 === m2 ? g || (k2 = c2.length) : k2 = m2;
            void 0 !== k2 && (this.names[k2] = a2.name, this.names.keys[a2.name] = k2);
            return k2;
          },
          updateNames: function() {
            var g = this, r = this.names;
            0 < r.length && (y(a.keys(r.keys), function(a2) {
              delete r.keys[a2];
            }), r.length = 0, this.minRange = this.userMinRange, y(this.series || [], function(a2) {
              a2.xIncrement = null;
              if (!a2.points || a2.isDirtyData)
                a2.processData(), a2.generatePoints();
              y(a2.points, function(r2, b2) {
                var d2;
                r2.options && (d2 = g.nameToX(r2), void 0 !== d2 && d2 !== r2.x && (r2.x = d2, a2.xData[b2] = d2));
              });
            }));
          },
          setAxisTranslation: function(a2) {
            var g = this, b2 = g.max - g.min, d2 = g.axisPointRange || 0, c2, m2 = 0, k2 = 0, l2 = g.linkedParent, q2 = !!g.categories, v2 = g.transA, A2 = g.isXAxis;
            if (A2 || q2 || d2)
              c2 = g.getClosest(), l2 ? (m2 = l2.minPointOffset, k2 = l2.pointRangePadding) : y(g.series, function(a3) {
                var b3 = q2 ? 1 : A2 ? D(a3.options.pointRange, c2, 0) : g.axisPointRange || 0;
                a3 = a3.options.pointPlacement;
                d2 = Math.max(d2, b3);
                g.single || (m2 = Math.max(m2, J(a3) ? 0 : b3 / 2), k2 = Math.max(k2, "on" === a3 ? 0 : b3));
              }), l2 = g.ordinalSlope && c2 ? g.ordinalSlope / c2 : 1, g.minPointOffset = m2 *= l2, g.pointRangePadding = k2 *= l2, g.pointRange = Math.min(d2, b2), A2 && (g.closestPointRange = c2);
            a2 && (g.oldTransA = v2);
            g.translationSlope = g.transA = v2 = g.staticScale || g.len / (b2 + k2 || 1);
            g.transB = g.horiz ? g.left : g.bottom;
            g.minPixelPadding = v2 * m2;
            h(this, "afterSetAxisTranslation");
          },
          minFromRange: function() {
            return this.max - this.range;
          },
          setTickInterval: function(g) {
            var b2 = this, d2 = b2.chart, c2 = b2.options, m2 = b2.isLog, l2 = b2.isDatetimeAxis, q2 = b2.isXAxis, A2 = b2.isLinked, p2 = c2.maxPadding, f2 = c2.minPadding, G2 = c2.tickInterval, B2 = c2.tickPixelInterval, J2 = b2.categories, E2 = v(b2.threshold) ? b2.threshold : null, N2 = b2.softThreshold, w2, t2, u2, n2;
            l2 || J2 || A2 || this.getTickAmount();
            u2 = D(b2.userMin, c2.min);
            n2 = D(b2.userMax, c2.max);
            A2 ? (b2.linkedParent = d2[b2.coll][c2.linkedTo], d2 = b2.linkedParent.getExtremes(), b2.min = D(
              d2.min,
              d2.dataMin
            ), b2.max = D(d2.max, d2.dataMax), c2.type !== b2.linkedParent.options.type && a.error(11, 1)) : (!N2 && x(E2) && (b2.dataMin >= E2 ? (w2 = E2, f2 = 0) : b2.dataMax <= E2 && (t2 = E2, p2 = 0)), b2.min = D(u2, w2, b2.dataMin), b2.max = D(n2, t2, b2.dataMax));
            m2 && (b2.positiveValuesOnly && !g && 0 >= Math.min(b2.min, D(b2.dataMin, b2.min)) && a.error(10, 1), b2.min = e(b2.log2lin(b2.min), 15), b2.max = e(b2.log2lin(b2.max), 15));
            b2.range && x(b2.max) && (b2.userMin = b2.min = u2 = Math.max(b2.dataMin, b2.minFromRange()), b2.userMax = n2 = b2.max, b2.range = null);
            h(b2, "foundExtremes");
            b2.beforePadding && b2.beforePadding();
            b2.adjustForMinRange();
            !(J2 || b2.axisPointRange || b2.usePercentage || A2) && x(b2.min) && x(b2.max) && (d2 = b2.max - b2.min) && (!x(u2) && f2 && (b2.min -= d2 * f2), !x(n2) && p2 && (b2.max += d2 * p2));
            v(c2.softMin) && !v(b2.userMin) && (b2.min = Math.min(b2.min, c2.softMin));
            v(c2.softMax) && !v(b2.userMax) && (b2.max = Math.max(b2.max, c2.softMax));
            v(c2.floor) && (b2.min = Math.max(b2.min, c2.floor));
            v(c2.ceiling) && (b2.max = Math.min(b2.max, c2.ceiling));
            N2 && x(b2.dataMin) && (E2 = E2 || 0, !x(u2) && b2.min < E2 && b2.dataMin >= E2 ? b2.min = E2 : !x(n2) && b2.max > E2 && b2.dataMax <= E2 && (b2.max = E2));
            b2.tickInterval = b2.min === b2.max || void 0 === b2.min || void 0 === b2.max ? 1 : A2 && !G2 && B2 === b2.linkedParent.options.tickPixelInterval ? G2 = b2.linkedParent.tickInterval : D(G2, this.tickAmount ? (b2.max - b2.min) / Math.max(this.tickAmount - 1, 1) : void 0, J2 ? 1 : (b2.max - b2.min) * B2 / Math.max(b2.len, B2));
            q2 && !g && y(b2.series, function(a2) {
              a2.processData(b2.min !== b2.oldMin || b2.max !== b2.oldMax);
            });
            b2.setAxisTranslation(true);
            b2.beforeSetTickPositions && b2.beforeSetTickPositions();
            b2.postProcessTickInterval && (b2.tickInterval = b2.postProcessTickInterval(b2.tickInterval));
            b2.pointRange && !G2 && (b2.tickInterval = Math.max(b2.pointRange, b2.tickInterval));
            g = D(c2.minTickInterval, b2.isDatetimeAxis && b2.closestPointRange);
            !G2 && b2.tickInterval < g && (b2.tickInterval = g);
            l2 || m2 || G2 || (b2.tickInterval = L(b2.tickInterval, null, k(b2.tickInterval), D(c2.allowDecimals, !(0.5 < b2.tickInterval && 5 > b2.tickInterval && 1e3 < b2.max && 9999 > b2.max)), !!this.tickAmount));
            this.tickAmount || (b2.tickInterval = b2.unsquish());
            this.setTickPositions();
          },
          setTickPositions: function() {
            var g = this.options, b2, d2 = g.tickPositions;
            b2 = this.getMinorTickInterval();
            var c2 = g.tickPositioner, m2 = g.startOnTick, k2 = g.endOnTick;
            this.tickmarkOffset = this.categories && "between" === g.tickmarkPlacement && 1 === this.tickInterval ? 0.5 : 0;
            this.minorTickInterval = "auto" === b2 && this.tickInterval ? this.tickInterval / 5 : b2;
            this.single = this.min === this.max && x(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || false !== g.allowDecimals);
            this.tickPositions = b2 = d2 && d2.slice();
            !b2 && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (b2 = [this.min, this.max], a.error(19)) : b2 = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, g.units), this.min, this.max, g.startOfWeek, this.ordinalPositions, this.closestPointRange, true) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b2.length > this.len && (b2 = [b2[0], b2.pop()], b2[0] === b2[1] && (b2.length = 1)), this.tickPositions = b2, c2 && (c2 = c2.apply(this, [this.min, this.max]))) && (this.tickPositions = b2 = c2);
            this.paddedTicks = b2.slice(0);
            this.trimTicks(b2, m2, k2);
            this.isLinked || (this.single && 2 > b2.length && (this.min -= 0.5, this.max += 0.5), d2 || c2 || this.adjustTickAmount());
            h(this, "afterSetTickPositions");
          },
          trimTicks: function(a2, b2, d2) {
            var g = a2[0], c2 = a2[a2.length - 1], m2 = this.minPointOffset || 0;
            if (!this.isLinked) {
              if (b2 && -Infinity !== g)
                this.min = g;
              else
                for (; this.min - m2 > a2[0]; )
                  a2.shift();
              if (d2)
                this.max = c2;
              else
                for (; this.max + m2 < a2[a2.length - 1]; )
                  a2.pop();
              0 === a2.length && x(g) && !this.options.tickPositions && a2.push((c2 + g) / 2);
            }
          },
          alignToOthers: function() {
            var a2 = {}, b2, d2 = this.options;
            false === this.chart.options.chart.alignTicks || false === d2.alignTicks || false === d2.startOnTick || false === d2.endOnTick || this.isLog || y(this.chart[this.coll], function(g) {
              var d3 = g.options, d3 = [g.horiz ? d3.left : d3.top, d3.width, d3.height, d3.pane].join();
              g.series.length && (a2[d3] ? b2 = true : a2[d3] = 1);
            });
            return b2;
          },
          getTickAmount: function() {
            var a2 = this.options, b2 = a2.tickAmount, d2 = a2.tickPixelInterval;
            !x(a2.tickInterval) && this.len < d2 && !this.isRadial && !this.isLog && a2.startOnTick && a2.endOnTick && (b2 = 2);
            !b2 && this.alignToOthers() && (b2 = Math.ceil(this.len / d2) + 1);
            4 > b2 && (this.finalTickAmt = b2, b2 = 5);
            this.tickAmount = b2;
          },
          adjustTickAmount: function() {
            var a2 = this.tickInterval, b2 = this.tickPositions, d2 = this.tickAmount, c2 = this.finalTickAmt, m2 = b2 && b2.length, k2 = D(this.threshold, this.softThreshold ? 0 : null);
            if (this.hasData()) {
              if (m2 < d2) {
                for (; b2.length < d2; )
                  b2.length % 2 || this.min === k2 ? b2.push(e(b2[b2.length - 1] + a2)) : b2.unshift(e(b2[0] - a2));
                this.transA *= (m2 - 1) / (d2 - 1);
                this.min = b2[0];
                this.max = b2[b2.length - 1];
              } else
                m2 > d2 && (this.tickInterval *= 2, this.setTickPositions());
              if (x(c2)) {
                for (a2 = d2 = b2.length; a2--; )
                  (3 === c2 && 1 === a2 % 2 || 2 >= c2 && 0 < a2 && a2 < d2 - 1) && b2.splice(a2, 1);
                this.finalTickAmt = void 0;
              }
            }
          },
          setScale: function() {
            var a2, b2;
            this.oldMin = this.min;
            this.oldMax = this.max;
            this.oldAxisLength = this.len;
            this.setAxisSize();
            b2 = this.len !== this.oldAxisLength;
            y(this.series, function(b3) {
              if (b3.isDirtyData || b3.isDirty || b3.xAxis.isDirty)
                a2 = true;
            });
            b2 || a2 || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = false, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b2 || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
            h(this, "afterSetScale");
          },
          setExtremes: function(a2, b2, d2, m2, k2) {
            var g = this, r = g.chart;
            d2 = D(d2, true);
            y(g.series, function(a3) {
              delete a3.kdTree;
            });
            k2 = c(k2, { min: a2, max: b2 });
            h(g, "setExtremes", k2, function() {
              g.userMin = a2;
              g.userMax = b2;
              g.eventArgs = k2;
              d2 && r.redraw(m2);
            });
          },
          zoom: function(a2, b2) {
            var g = this.dataMin, d2 = this.dataMax, c2 = this.options, m2 = Math.min(g, D(c2.min, g)), c2 = Math.max(d2, D(c2.max, d2));
            if (a2 !== this.min || b2 !== this.max)
              this.allowZoomOutside || (x(g) && (a2 < m2 && (a2 = m2), a2 > c2 && (a2 = c2)), x(d2) && (b2 < m2 && (b2 = m2), b2 > c2 && (b2 = c2))), this.displayBtn = void 0 !== a2 || void 0 !== b2, this.setExtremes(a2, b2, false, void 0, { trigger: "zoom" });
            return true;
          },
          setAxisSize: function() {
            var b2 = this.chart, d2 = this.options, c2 = d2.offsets || [0, 0, 0, 0], m2 = this.horiz, k2 = this.width = Math.round(a.relativeLength(D(d2.width, b2.plotWidth - c2[3] + c2[1]), b2.plotWidth)), l2 = this.height = Math.round(a.relativeLength(D(d2.height, b2.plotHeight - c2[0] + c2[2]), b2.plotHeight)), h2 = this.top = Math.round(a.relativeLength(D(
              d2.top,
              b2.plotTop + c2[0]
            ), b2.plotHeight, b2.plotTop)), d2 = this.left = Math.round(a.relativeLength(D(d2.left, b2.plotLeft + c2[3]), b2.plotWidth, b2.plotLeft));
            this.bottom = b2.chartHeight - l2 - h2;
            this.right = b2.chartWidth - k2 - d2;
            this.len = Math.max(m2 ? k2 : l2, 0);
            this.pos = m2 ? d2 : h2;
          },
          getExtremes: function() {
            var a2 = this.isLog;
            return { min: a2 ? e(this.lin2log(this.min)) : this.min, max: a2 ? e(this.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
          },
          getThreshold: function(a2) {
            var b2 = this.isLog, g = b2 ? this.lin2log(this.min) : this.min, b2 = b2 ? this.lin2log(this.max) : this.max;
            null === a2 || -Infinity === a2 ? a2 = g : Infinity === a2 ? a2 = b2 : g > a2 ? a2 = g : b2 < a2 && (a2 = b2);
            return this.translate(a2, 0, 1, 0, 1);
          },
          autoLabelAlign: function(a2) {
            a2 = (D(a2, 0) - 90 * this.side + 720) % 360;
            return 15 < a2 && 165 > a2 ? "right" : 195 < a2 && 345 > a2 ? "left" : "center";
          },
          tickSize: function(a2) {
            var b2 = this.options, g = b2[a2 + "Length"], d2 = D(b2[a2 + "Width"], "tick" === a2 && this.isXAxis ? 1 : 0);
            if (d2 && g)
              return "inside" === b2[a2 + "Position"] && (g = -g), [g, d2];
          },
          labelMetrics: function() {
            var a2 = this.tickPositions && this.tickPositions[0] || 0;
            return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a2] && this.ticks[a2].label);
          },
          unsquish: function() {
            var a2 = this.options.labels, b2 = this.horiz, d2 = this.tickInterval, c2 = d2, m2 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / d2), k2, l2 = a2.rotation, h2 = this.labelMetrics(), q2, v2 = Number.MAX_VALUE, A2, p2 = function(a3) {
              a3 /= m2 || 1;
              a3 = 1 < a3 ? Math.ceil(a3) : 1;
              return e(a3 * d2);
            };
            b2 ? (A2 = !a2.staggerLines && !a2.step && (x(l2) ? [l2] : m2 < D(a2.autoRotationLimit, 80) && a2.autoRotation)) && y(A2, function(a3) {
              var b3;
              if (a3 === l2 || a3 && -90 <= a3 && 90 >= a3)
                q2 = p2(Math.abs(h2.h / Math.sin(t * a3))), b3 = q2 + Math.abs(a3 / 360), b3 < v2 && (v2 = b3, k2 = a3, c2 = q2);
            }) : a2.step || (c2 = p2(h2.h));
            this.autoRotation = A2;
            this.labelRotation = D(k2, l2);
            return c2;
          },
          getSlotWidth: function(a2) {
            var b2 = this.chart, g = this.horiz, d2 = this.options.labels, c2 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), m2 = b2.margin[3];
            return a2 && a2.slotWidth || g && 2 > (d2.step || 0) && !d2.rotation && (this.staggerLines || 1) * this.len / c2 || !g && (d2.style && parseInt(d2.style.width, 10) || m2 && m2 - b2.spacing[3] || 0.33 * b2.chartWidth);
          },
          renderUnsquish: function() {
            var a2 = this.chart, b2 = a2.renderer, d2 = this.tickPositions, c2 = this.ticks, m2 = this.options.labels, k2 = m2 && m2.style || {}, l2 = this.horiz, h2 = this.getSlotWidth(), q2 = Math.max(1, Math.round(h2 - 2 * (m2.padding || 5))), v2 = {}, A2 = this.labelMetrics(), e2 = m2.style && m2.style.textOverflow, p2, f2, G2 = 0, B2;
            J(m2.rotation) || (v2.rotation = m2.rotation || 0);
            y(d2, function(a3) {
              (a3 = c2[a3]) && a3.label && a3.label.textPxLength > G2 && (G2 = a3.label.textPxLength);
            });
            this.maxLabelLength = G2;
            if (this.autoRotation)
              G2 > q2 && G2 > A2.h ? v2.rotation = this.labelRotation : this.labelRotation = 0;
            else if (h2 && (p2 = q2, !e2)) {
              for (f2 = "clip", q2 = d2.length; !l2 && q2--; )
                if (B2 = d2[q2], B2 = c2[B2].label)
                  B2.styles && "ellipsis" === B2.styles.textOverflow ? B2.css({ textOverflow: "clip" }) : B2.textPxLength > h2 && B2.css({ width: h2 + "px" }), B2.getBBox().height > this.len / d2.length - (A2.h - A2.f) && (B2.specificTextOverflow = "ellipsis");
            }
            v2.rotation && (p2 = G2 > 0.5 * a2.chartHeight ? 0.33 * a2.chartHeight : G2, e2 || (f2 = "ellipsis"));
            if (this.labelAlign = m2.align || this.autoLabelAlign(this.labelRotation))
              v2.align = this.labelAlign;
            y(d2, function(a3) {
              var b3 = (a3 = c2[a3]) && a3.label, g = k2.width, d3 = {};
              b3 && (b3.attr(v2), a3.shortenLabel ? a3.shortenLabel() : p2 && !g && "nowrap" !== k2.whiteSpace && (p2 < b3.textPxLength || "SPAN" === b3.element.tagName) ? (d3.width = p2, e2 || (d3.textOverflow = b3.specificTextOverflow || f2), b3.css(d3)) : b3.styles && b3.styles.width && !d3.width && !g && b3.css({ width: null }), delete b3.specificTextOverflow, a3.rotation = v2.rotation);
            }, this);
            this.tickRotCorr = b2.rotCorr(A2.b, this.labelRotation || 0, 0 !== this.side);
          },
          hasData: function() {
            return this.hasVisibleSeries || x(this.min) && x(this.max) && this.tickPositions && 0 < this.tickPositions.length;
          },
          addTitle: function(a2) {
            var b2 = this.chart.renderer, g = this.horiz, d2 = this.opposite, c2 = this.options.title, m2;
            this.axisTitle || ((m2 = c2.textAlign) || (m2 = (g ? { low: "left", middle: "center", high: "right" } : { low: d2 ? "right" : "left", middle: "center", high: d2 ? "left" : "right" })[c2.align]), this.axisTitle = b2.text(c2.text, 0, 0, c2.useHTML).attr({ zIndex: 7, rotation: c2.rotation || 0, align: m2 }).addClass("highcharts-axis-title").css(l(c2.style)).add(this.axisGroup), this.axisTitle.isNew = true);
            c2.style.width || this.isRadial || this.axisTitle.css({ width: this.len });
            this.axisTitle[a2 ? "show" : "hide"](true);
          },
          generateTick: function(a2) {
            var b2 = this.ticks;
            b2[a2] ? b2[a2].addLabel() : b2[a2] = new N(this, a2);
          },
          getOffset: function() {
            var a2 = this, b2 = a2.chart, d2 = b2.renderer, c2 = a2.options, m2 = a2.tickPositions, k2 = a2.ticks, l2 = a2.horiz, q2 = a2.side, v2 = b2.inverted && !a2.isZAxis ? [1, 0, 3, 2][q2] : q2, A2, e2, p2 = 0, G2, f2 = 0, J2 = c2.title, E2 = c2.labels, N2 = 0, w2 = b2.axisOffset, b2 = b2.clipOffset, t2 = [-1, 1, 1, -1][q2], u2 = c2.className, n2 = a2.axisParent;
            A2 = a2.hasData();
            a2.showAxis = e2 = A2 || D(c2.showEmpty, true);
            a2.staggerLines = a2.horiz && E2.staggerLines;
            a2.axisGroup || (a2.gridGroup = d2.g("grid").attr({ zIndex: c2.gridZIndex || 1 }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (u2 || "")).add(n2), a2.axisGroup = d2.g("axis").attr({ zIndex: c2.zIndex || 2 }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (u2 || "")).add(n2), a2.labelGroup = d2.g("axis-labels").attr({ zIndex: E2.zIndex || 7 }).addClass("highcharts-" + a2.coll.toLowerCase() + "-labels " + (u2 || "")).add(n2));
            A2 || a2.isLinked ? (y(m2, function(b3, g) {
              a2.generateTick(b3, g);
            }), a2.renderUnsquish(), a2.reserveSpaceDefault = 0 === q2 || 2 === q2 || { 1: "left", 3: "right" }[q2] === a2.labelAlign, D(E2.reserveSpace, "center" === a2.labelAlign ? true : null, a2.reserveSpaceDefault) && y(m2, function(a3) {
              N2 = Math.max(k2[a3].getLabelSize(), N2);
            }), a2.staggerLines && (N2 *= a2.staggerLines), a2.labelOffset = N2 * (a2.opposite ? -1 : 1)) : B(k2, function(a3, b3) {
              a3.destroy();
              delete k2[b3];
            });
            J2 && J2.text && false !== J2.enabled && (a2.addTitle(e2), e2 && false !== J2.reserveSpace && (a2.titleOffset = p2 = a2.axisTitle.getBBox()[l2 ? "height" : "width"], G2 = J2.offset, f2 = x(G2) ? 0 : D(J2.margin, l2 ? 5 : 10)));
            a2.renderLine();
            a2.offset = t2 * D(c2.offset, w2[q2]);
            a2.tickRotCorr = a2.tickRotCorr || { x: 0, y: 0 };
            d2 = 0 === q2 ? -a2.labelMetrics().h : 2 === q2 ? a2.tickRotCorr.y : 0;
            f2 = Math.abs(N2) + f2;
            N2 && (f2 = f2 - d2 + t2 * (l2 ? D(E2.y, a2.tickRotCorr.y + 8 * t2) : E2.x));
            a2.axisTitleMargin = D(G2, f2);
            a2.getMaxLabelDimensions && (a2.maxLabelDimensions = a2.getMaxLabelDimensions(k2, m2));
            l2 = this.tickSize("tick");
            w2[q2] = Math.max(w2[q2], a2.axisTitleMargin + p2 + t2 * a2.offset, f2, A2 && m2.length && l2 ? l2[0] + t2 * a2.offset : 0);
            c2 = c2.offset ? 0 : 2 * Math.floor(a2.axisLine.strokeWidth() / 2);
            b2[v2] = Math.max(b2[v2], c2);
            h(this, "afterGetOffset");
          },
          getLinePath: function(a2) {
            var b2 = this.chart, g = this.opposite, d2 = this.offset, c2 = this.horiz, m2 = this.left + (g ? this.width : 0) + d2, d2 = b2.chartHeight - this.bottom - (g ? this.height : 0) + d2;
            g && (a2 *= -1);
            return b2.renderer.crispLine([
              "M",
              c2 ? this.left : m2,
              c2 ? d2 : this.top,
              "L",
              c2 ? b2.chartWidth - this.right : m2,
              c2 ? d2 : b2.chartHeight - this.bottom
            ], a2);
          },
          renderLine: function() {
            this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
          },
          getTitlePosition: function() {
            var a2 = this.horiz, b2 = this.left, d2 = this.top, c2 = this.len, m2 = this.options.title, k2 = a2 ? b2 : d2, l2 = this.opposite, h2 = this.offset, q2 = m2.x || 0, v2 = m2.y || 0, A2 = this.axisTitle, e2 = this.chart.renderer.fontMetrics(m2.style && m2.style.fontSize, A2), A2 = Math.max(A2.getBBox(null, 0).height - e2.h - 1, 0), c2 = { low: k2 + (a2 ? 0 : c2), middle: k2 + c2 / 2, high: k2 + (a2 ? c2 : 0) }[m2.align], b2 = (a2 ? d2 + this.height : b2) + (a2 ? 1 : -1) * (l2 ? -1 : 1) * this.axisTitleMargin + [-A2, A2, e2.f, -A2][this.side];
            return { x: a2 ? c2 + q2 : b2 + (l2 ? this.width : 0) + h2 + q2, y: a2 ? b2 + v2 - (l2 ? this.height : 0) + h2 : c2 + v2 };
          },
          renderMinorTick: function(a2) {
            var b2 = this.chart.hasRendered && v(this.oldMin), d2 = this.minorTicks;
            d2[a2] || (d2[a2] = new N(this, a2, "minor"));
            b2 && d2[a2].isNew && d2[a2].render(null, true);
            d2[a2].render(
              null,
              false,
              1
            );
          },
          renderTick: function(a2, b2) {
            var d2 = this.isLinked, g = this.ticks, c2 = this.chart.hasRendered && v(this.oldMin);
            if (!d2 || a2 >= this.min && a2 <= this.max)
              g[a2] || (g[a2] = new N(this, a2)), c2 && g[a2].isNew && g[a2].render(b2, true, -1), g[a2].render(b2);
          },
          render: function() {
            var b2 = this, d2 = b2.chart, c2 = b2.options, m2 = b2.isLog, k2 = b2.isLinked, l2 = b2.tickPositions, q2 = b2.axisTitle, e2 = b2.ticks, p2 = b2.minorTicks, f2 = b2.alternateBands, G2 = c2.stackLabels, J2 = c2.alternateGridColor, E2 = b2.tickmarkOffset, D2 = b2.axisLine, t2 = b2.showAxis, w2 = F(d2.renderer.globalAnimation), u2, n2;
            b2.labelEdge.length = 0;
            b2.overlap = false;
            y([e2, p2, f2], function(a2) {
              B(a2, function(a3) {
                a3.isActive = false;
              });
            });
            if (b2.hasData() || k2)
              b2.minorTickInterval && !b2.categories && y(b2.getMinorTickPositions(), function(a2) {
                b2.renderMinorTick(a2);
              }), l2.length && (y(l2, function(a2, d3) {
                b2.renderTick(a2, d3);
              }), E2 && (0 === b2.min || b2.single) && (e2[-1] || (e2[-1] = new N(b2, -1, null, true)), e2[-1].render(-1))), J2 && y(l2, function(c3, g) {
                n2 = void 0 !== l2[g + 1] ? l2[g + 1] + E2 : b2.max - E2;
                0 === g % 2 && c3 < b2.max && n2 <= b2.max + (d2.polar ? -E2 : E2) && (f2[c3] || (f2[c3] = new a.PlotLineOrBand(b2)), u2 = c3 + E2, f2[c3].options = { from: m2 ? b2.lin2log(u2) : u2, to: m2 ? b2.lin2log(n2) : n2, color: J2 }, f2[c3].render(), f2[c3].isActive = true);
              }), b2._addedPlotLB || (y((c2.plotLines || []).concat(c2.plotBands || []), function(a2) {
                b2.addPlotBandOrLine(a2);
              }), b2._addedPlotLB = true);
            y([e2, p2, f2], function(a2) {
              var b3, c3 = [], g = w2.duration;
              B(a2, function(a3, b4) {
                a3.isActive || (a3.render(b4, false, 0), a3.isActive = false, c3.push(b4));
              });
              A(function() {
                for (b3 = c3.length; b3--; )
                  a2[c3[b3]] && !a2[c3[b3]].isActive && (a2[c3[b3]].destroy(), delete a2[c3[b3]]);
              }, a2 !== f2 && d2.hasRendered && g ? g : 0);
            });
            D2 && (D2[D2.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(D2.strokeWidth()) }), D2.isPlaced = true, D2[t2 ? "show" : "hide"](true));
            q2 && t2 && (c2 = b2.getTitlePosition(), v(c2.y) ? (q2[q2.isNew ? "attr" : "animate"](c2), q2.isNew = false) : (q2.attr("y", -9999), q2.isNew = true));
            G2 && G2.enabled && b2.renderStackTotals();
            b2.isDirty = false;
            h(this, "afterRender");
          },
          redraw: function() {
            this.visible && (this.render(), y(this.plotLinesAndBands, function(a2) {
              a2.render();
            }));
            y(this.series, function(a2) {
              a2.isDirty = true;
            });
          },
          keepProps: "extKey hcEvents names series userMax userMin".split(" "),
          destroy: function(a2) {
            var b2 = this, c2 = b2.stacks, g = b2.plotLinesAndBands, k2;
            h(
              this,
              "destroy",
              { keepEvents: a2 }
            );
            a2 || m(b2);
            B(c2, function(a3, b3) {
              w(a3);
              c2[b3] = null;
            });
            y([b2.ticks, b2.minorTicks, b2.alternateBands], function(a3) {
              w(a3);
            });
            if (g)
              for (a2 = g.length; a2--; )
                g[a2].destroy();
            y("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" "), function(a3) {
              b2[a3] && (b2[a3] = b2[a3].destroy());
            });
            for (k2 in b2.plotLinesAndBandsGroups)
              b2.plotLinesAndBandsGroups[k2] = b2.plotLinesAndBandsGroups[k2].destroy();
            B(b2, function(a3, c3) {
              -1 === d(c3, b2.keepProps) && delete b2[c3];
            });
          },
          drawCrosshair: function(a2, b2) {
            var d2, c2 = this.crosshair, g = D(c2.snap, true), m2, k2 = this.cross;
            h(this, "drawCrosshair", { e: a2, point: b2 });
            a2 || (a2 = this.cross && this.cross.e);
            if (this.crosshair && false !== (x(b2) || !g)) {
              g ? x(b2) && (m2 = D(b2.crosshairPos, this.isXAxis ? b2.plotX : this.len - b2.plotY)) : m2 = a2 && (this.horiz ? a2.chartX - this.pos : this.len - a2.chartY + this.pos);
              x(m2) && (d2 = this.getPlotLinePath(b2 && (this.isXAxis ? b2.x : D(b2.stackY, b2.y)), null, null, null, m2) || null);
              if (!x(d2)) {
                this.hideCrosshair();
                return;
              }
              g = this.categories && !this.isRadial;
              k2 || (this.cross = k2 = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (g ? "category " : "thin ") + c2.className).attr({ zIndex: D(c2.zIndex, 2) }).add(), k2.attr({ stroke: c2.color || (g ? f("#ccd6eb").setOpacity(0.25).get() : "#cccccc"), "stroke-width": D(c2.width, 1) }).css({ "pointer-events": "none" }), c2.dashStyle && k2.attr({ dashstyle: c2.dashStyle }));
              k2.show().attr({ d: d2 });
              g && !c2.width && k2.attr({ "stroke-width": this.transA });
              this.cross.e = a2;
            } else
              this.hideCrosshair();
            h(this, "afterDrawCrosshair", { e: a2, point: b2 });
          },
          hideCrosshair: function() {
            this.cross && this.cross.hide();
          }
        });
        return a.Axis = E;
      }(K);
      (function(a) {
        var C = a.Axis, F = a.getMagnitude, I = a.normalizeTickInterval, n = a.timeUnits;
        C.prototype.getTimeTicks = function() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        };
        C.prototype.normalizeTimeTickInterval = function(a2, e) {
          var f = e || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
          e = f[f.length - 1];
          var x = n[e[0]], t = e[1], w;
          for (w = 0; w < f.length && !(e = f[w], x = n[e[0]], t = e[1], f[w + 1] && a2 <= (x * t[t.length - 1] + n[f[w + 1][0]]) / 2); w++)
            ;
          x === n.year && a2 < 5 * x && (t = [1, 2, 5]);
          a2 = I(a2 / x, t, "year" === e[0] ? Math.max(F(a2 / x), 1) : 1);
          return { unitRange: x, count: a2, unitName: e[0] };
        };
      })(K);
      (function(a) {
        var C = a.Axis, F = a.getMagnitude, I = a.map, n = a.normalizeTickInterval, f = a.pick;
        C.prototype.getLogTickPositions = function(a2, u, x, t) {
          var e = this.options, y = this.len, c = [];
          t || (this._minorAutoInterval = null);
          if (0.5 <= a2)
            a2 = Math.round(a2), c = this.getLinearTickPositions(a2, u, x);
          else if (0.08 <= a2)
            for (var y = Math.floor(u), h, p, k, q, d, e = 0.3 < a2 ? [1, 2, 4] : 0.15 < a2 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; y < x + 1 && !d; y++)
              for (p = e.length, h = 0; h < p && !d; h++)
                k = this.log2lin(this.lin2log(y) * e[h]), k > u && (!t || q <= x) && void 0 !== q && c.push(q), q > x && (d = true), q = k;
          else
            u = this.lin2log(u), x = this.lin2log(x), a2 = t ? this.getMinorTickInterval() : e.tickInterval, a2 = f("auto" === a2 ? null : a2, this._minorAutoInterval, e.tickPixelInterval / (t ? 5 : 1) * (x - u) / ((t ? y / this.tickPositions.length : y) || 1)), a2 = n(a2, null, F(a2)), c = I(this.getLinearTickPositions(a2, u, x), this.log2lin), t || (this._minorAutoInterval = a2 / 5);
          t || (this.tickInterval = a2);
          return c;
        };
        C.prototype.log2lin = function(a2) {
          return Math.log(a2) / Math.LN10;
        };
        C.prototype.lin2log = function(a2) {
          return Math.pow(10, a2);
        };
      })(K);
      (function(a, C) {
        var F = a.arrayMax, I = a.arrayMin, n = a.defined, f = a.destroyObjectProperties, e = a.each, u = a.erase, x = a.merge, t = a.pick;
        a.PlotLineOrBand = function(a2, e2) {
          this.axis = a2;
          e2 && (this.options = e2, this.id = e2.id);
        };
        a.PlotLineOrBand.prototype = { render: function() {
          a.fireEvent(this, "render");
          var e2 = this, f2 = e2.axis, c = f2.horiz, h = e2.options, p = h.label, k = e2.label, q = h.to, d = h.from, b = h.value, v = n(d) && n(q), J = n(b), l = e2.svgElem, u2 = !l, B = [], D = h.color, m = t(h.zIndex, 0), G = h.events, B = { "class": "highcharts-plot-" + (v ? "band " : "line ") + (h.className || "") }, A = {}, N = f2.chart.renderer, E = v ? "bands" : "lines";
          f2.isLog && (d = f2.log2lin(d), q = f2.log2lin(q), b = f2.log2lin(b));
          J ? (B.stroke = D, B["stroke-width"] = h.width, h.dashStyle && (B.dashstyle = h.dashStyle)) : v && (D && (B.fill = D), h.borderWidth && (B.stroke = h.borderColor, B["stroke-width"] = h.borderWidth));
          A.zIndex = m;
          E += "-" + m;
          (D = f2.plotLinesAndBandsGroups[E]) || (f2.plotLinesAndBandsGroups[E] = D = N.g("plot-" + E).attr(A).add());
          u2 && (e2.svgElem = l = N.path().attr(B).add(D));
          if (J)
            B = f2.getPlotLinePath(b, l.strokeWidth());
          else if (v)
            B = f2.getPlotBandPath(d, q, h);
          else
            return;
          u2 && B && B.length ? (l.attr({ d: B }), G && a.objectEach(G, function(a2, b2) {
            l.on(b2, function(a3) {
              G[b2].apply(e2, [a3]);
            });
          })) : l && (B ? (l.show(), l.animate({ d: B })) : (l.hide(), k && (e2.label = k = k.destroy())));
          p && n(p.text) && B && B.length && 0 < f2.width && 0 < f2.height && !B.isFlat ? (p = x({ align: c && v && "center", x: c ? !v && 4 : 10, verticalAlign: !c && v && "middle", y: c ? v ? 16 : 10 : v ? 6 : -4, rotation: c && !v && 90 }, p), this.renderLabel(p, B, v, m)) : k && k.hide();
          return e2;
        }, renderLabel: function(a2, e2, c, h) {
          var p = this.label, k = this.axis.chart.renderer;
          p || (p = { align: a2.textAlign || a2.align, rotation: a2.rotation, "class": "highcharts-plot-" + (c ? "band" : "line") + "-label " + (a2.className || "") }, p.zIndex = h, this.label = p = k.text(a2.text, 0, 0, a2.useHTML).attr(p).add(), p.css(a2.style));
          h = e2.xBounds || [e2[1], e2[4], c ? e2[6] : e2[1]];
          e2 = e2.yBounds || [e2[2], e2[5], c ? e2[7] : e2[2]];
          c = I(h);
          k = I(e2);
          p.align(a2, false, { x: c, y: k, width: F(h) - c, height: F(e2) - k });
          p.show();
        }, destroy: function() {
          u(
            this.axis.plotLinesAndBands,
            this
          );
          delete this.axis;
          f(this);
        } };
        a.extend(C.prototype, { getPlotBandPath: function(a2, e2) {
          var c = this.getPlotLinePath(e2, null, null, true), h = this.getPlotLinePath(a2, null, null, true), p = [], k = this.horiz, q = 1, d;
          a2 = a2 < this.min && e2 < this.min || a2 > this.max && e2 > this.max;
          if (h && c)
            for (a2 && (d = h.toString() === c.toString(), q = 0), a2 = 0; a2 < h.length; a2 += 6)
              k && c[a2 + 1] === h[a2 + 1] ? (c[a2 + 1] += q, c[a2 + 4] += q) : k || c[a2 + 2] !== h[a2 + 2] || (c[a2 + 2] += q, c[a2 + 5] += q), p.push("M", h[a2 + 1], h[a2 + 2], "L", h[a2 + 4], h[a2 + 5], c[a2 + 4], c[a2 + 5], c[a2 + 1], c[a2 + 2], "z"), p.isFlat = d;
          return p;
        }, addPlotBand: function(a2) {
          return this.addPlotBandOrLine(
            a2,
            "plotBands"
          );
        }, addPlotLine: function(a2) {
          return this.addPlotBandOrLine(a2, "plotLines");
        }, addPlotBandOrLine: function(e2, f2) {
          var c = new a.PlotLineOrBand(this, e2).render(), h = this.userOptions;
          c && (f2 && (h[f2] = h[f2] || [], h[f2].push(e2)), this.plotLinesAndBands.push(c));
          return c;
        }, removePlotBandOrLine: function(a2) {
          for (var f2 = this.plotLinesAndBands, c = this.options, h = this.userOptions, p = f2.length; p--; )
            f2[p].id === a2 && f2[p].destroy();
          e([c.plotLines || [], h.plotLines || [], c.plotBands || [], h.plotBands || []], function(c2) {
            for (p = c2.length; p--; )
              c2[p].id === a2 && u(c2, c2[p]);
          });
        }, removePlotBand: function(a2) {
          this.removePlotBandOrLine(a2);
        }, removePlotLine: function(a2) {
          this.removePlotBandOrLine(a2);
        } });
      })(K, W);
      (function(a) {
        var C = a.doc, F = a.each, I = a.extend, n = a.format, f = a.isNumber, e = a.map, u = a.merge, x = a.pick, t = a.splat, w = a.syncTimeout, y = a.timeUnits;
        a.Tooltip = function() {
          this.init.apply(this, arguments);
        };
        a.Tooltip.prototype = { init: function(a2, h) {
          this.chart = a2;
          this.options = h;
          this.crosshairs = [];
          this.now = { x: 0, y: 0 };
          this.isHidden = true;
          this.split = h.split && !a2.inverted;
          this.shared = h.shared || this.split;
          this.outside = h.outside && !this.split;
        }, cleanSplit: function(a2) {
          F(this.chart.series, function(c) {
            var h = c && c.tt;
            h && (!h.isActive || a2 ? c.tt = h.destroy() : h.isActive = false);
          });
        }, getLabel: function() {
          var c = this.chart.renderer, h = this.options, e2;
          this.label || (this.outside && (this.container = e2 = a.doc.createElement("div"), e2.className = "highcharts-tooltip-container", a.css(e2, { position: "absolute", top: "1px", pointerEvents: h.style && h.style.pointerEvents }), a.doc.body.appendChild(e2), this.renderer = c = new a.Renderer(e2, 0, 0)), this.split ? this.label = c.g("tooltip") : (this.label = c.label("", 0, 0, h.shape || "callout", null, null, h.useHTML, null, "tooltip").attr({ padding: h.padding, r: h.borderRadius }), this.label.attr({ fill: h.backgroundColor, "stroke-width": h.borderWidth }).css(h.style).shadow(h.shadow)), this.outside && (this.label.attr({ x: this.distance, y: this.distance }), this.label.xSetter = function(a2) {
            e2.style.left = a2 + "px";
          }, this.label.ySetter = function(a2) {
            e2.style.top = a2 + "px";
          }), this.label.attr({ zIndex: 8 }).add());
          return this.label;
        }, update: function(a2) {
          this.destroy();
          u(true, this.chart.options.tooltip.userOptions, a2);
          this.init(this.chart, u(true, this.options, a2));
        }, destroy: function() {
          this.label && (this.label = this.label.destroy());
          this.split && this.tt && (this.cleanSplit(this.chart, true), this.tt = this.tt.destroy());
          this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));
          a.clearTimeout(this.hideTimer);
          a.clearTimeout(this.tooltipTimeout);
        }, move: function(c, h, e2, k) {
          var q = this, d = q.now, b = false !== q.options.animation && !q.isHidden && (1 < Math.abs(c - d.x) || 1 < Math.abs(h - d.y)), v = q.followPointer || 1 < q.len;
          I(d, { x: b ? (2 * d.x + c) / 3 : c, y: b ? (d.y + h) / 2 : h, anchorX: v ? void 0 : b ? (2 * d.anchorX + e2) / 3 : e2, anchorY: v ? void 0 : b ? (d.anchorY + k) / 2 : k });
          q.getLabel().attr(d);
          b && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
            q && q.move(c, h, e2, k);
          }, 32));
        }, hide: function(c) {
          var h = this;
          a.clearTimeout(this.hideTimer);
          c = x(c, this.options.hideDelay, 500);
          this.isHidden || (this.hideTimer = w(function() {
            h.getLabel()[c ? "fadeOut" : "hide"]();
            h.isHidden = true;
          }, c));
        }, getAnchor: function(a2, h) {
          var c = this.chart, k = c.pointer, q = c.inverted, d = c.plotTop, b = c.plotLeft, v = 0, f2 = 0, l, n2;
          a2 = t(a2);
          this.followPointer && h ? (void 0 === h.chartX && (h = k.normalize(h)), a2 = [h.chartX - c.plotLeft, h.chartY - d]) : a2[0].tooltipPos ? a2 = a2[0].tooltipPos : (F(a2, function(a3) {
            l = a3.series.yAxis;
            n2 = a3.series.xAxis;
            v += a3.plotX + (!q && n2 ? n2.left - b : 0);
            f2 += (a3.plotLow ? (a3.plotLow + a3.plotHigh) / 2 : a3.plotY) + (!q && l ? l.top - d : 0);
          }), v /= a2.length, f2 /= a2.length, a2 = [q ? c.plotWidth - f2 : v, this.shared && !q && 1 < a2.length && h ? h.chartY - d : q ? c.plotHeight - v : f2]);
          return e(a2, Math.round);
        }, getPosition: function(a2, h, e2) {
          var c = this.chart, q = this.distance, d = {}, b = c.inverted && e2.h || 0, v, f2 = this.outside, l = f2 ? C.documentElement.clientWidth - 2 * q : c.chartWidth, p = f2 ? Math.max(C.body.scrollHeight, C.documentElement.scrollHeight, C.body.offsetHeight, C.documentElement.offsetHeight, C.documentElement.clientHeight) : c.chartHeight, B = c.pointer.chartPosition, D = ["y", p, h, (f2 ? B.top - q : 0) + e2.plotY + c.plotTop, f2 ? 0 : c.plotTop, f2 ? p : c.plotTop + c.plotHeight], m = ["x", l, a2, (f2 ? B.left - q : 0) + e2.plotX + c.plotLeft, f2 ? 0 : c.plotLeft, f2 ? l : c.plotLeft + c.plotWidth], G = !this.followPointer && x(e2.ttBelow, !c.inverted === !!e2.negative), A = function(a3, c2, g2, m2, k, l2) {
            var h2 = g2 < m2 - q, v2 = m2 + q + g2 < c2, A2 = m2 - q - g2;
            m2 += q;
            if (G && v2)
              d[a3] = m2;
            else if (!G && h2)
              d[a3] = A2;
            else if (h2)
              d[a3] = Math.min(l2 - g2, 0 > A2 - b ? A2 : A2 - b);
            else if (v2)
              d[a3] = Math.max(k, m2 + b + g2 > c2 ? m2 : m2 + b);
            else
              return false;
          }, N = function(a3, b2, c2, g2) {
            var m2;
            g2 < q || g2 > b2 - q ? m2 = false : d[a3] = g2 < c2 / 2 ? 1 : g2 > b2 - c2 / 2 ? b2 - c2 - 2 : g2 - c2 / 2;
            return m2;
          }, E = function(a3) {
            var b2 = D;
            D = m;
            m = b2;
            v = a3;
          }, g = function() {
            false !== A.apply(0, D) ? false !== N.apply(0, m) || v || (E(true), g()) : v ? d.x = d.y = 0 : (E(true), g());
          };
          (c.inverted || 1 < this.len) && E();
          g();
          return d;
        }, defaultFormatter: function(a2) {
          var c = this.points || t(this), e2;
          e2 = [a2.tooltipFooterHeaderFormatter(c[0])];
          e2 = e2.concat(a2.bodyFormatter(c));
          e2.push(a2.tooltipFooterHeaderFormatter(c[0], true));
          return e2;
        }, refresh: function(c, h) {
          var e2, k = this.options, q, d = c, b, v = {}, f2 = [];
          e2 = k.formatter || this.defaultFormatter;
          var v = this.shared, l;
          k.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = t(d)[0].series.tooltipOptions.followPointer, b = this.getAnchor(d, h), h = b[0], q = b[1], !v || d.series && d.series.noSharedTooltip ? v = d.getLabelConfig() : (F(d, function(a2) {
            a2.setState("hover");
            f2.push(a2.getLabelConfig());
          }), v = { x: d[0].category, y: d[0].y }, v.points = f2, d = d[0]), this.len = f2.length, v = e2.call(v, this), l = d.series, this.distance = x(l.tooltipOptions.distance, 16), false === v ? this.hide() : (e2 = this.getLabel(), this.isHidden && e2.attr({ opacity: 1 }).show(), this.split ? this.renderSplit(v, t(c)) : (k.style.width || e2.css({ width: this.chart.spacingBox.width }), e2.attr({ text: v && v.join ? v.join("") : v }), e2.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + x(d.colorIndex, l.colorIndex)), e2.attr({ stroke: k.borderColor || d.color || l.color || "#666666" }), this.updatePosition({ plotX: h, plotY: q, negative: d.negative, ttBelow: d.ttBelow, h: b[2] || 0 })), this.isHidden = false));
        }, renderSplit: function(c, h) {
          var e2 = this, k = [], q = this.chart, d = q.renderer, b = true, v = this.options, f2 = 0, l, t2 = this.getLabel(), B = q.plotTop;
          a.isString(c) && (c = [false, c]);
          F(c.slice(0, h.length + 1), function(a2, c2) {
            if (false !== a2) {
              c2 = h[c2 - 1] || { isHeader: true, plotX: h[0].plotX };
              var m = c2.series || e2, A = m.tt, p = c2.series || {}, E = "highcharts-color-" + x(c2.colorIndex, p.colorIndex, "none");
              A || (m.tt = A = d.label(
                null,
                null,
                null,
                "callout",
                null,
                null,
                v.useHTML
              ).addClass("highcharts-tooltip-box " + E + (c2.isHeader ? " highcharts-tooltip-header" : "")).attr({ padding: v.padding, r: v.borderRadius, fill: v.backgroundColor, stroke: v.borderColor || c2.color || p.color || "#333333", "stroke-width": v.borderWidth }).add(t2));
              A.isActive = true;
              A.attr({ text: a2 });
              A.css(v.style).shadow(v.shadow);
              a2 = A.getBBox();
              p = a2.width + A.strokeWidth();
              c2.isHeader ? (f2 = a2.height, q.xAxis[0].opposite && (l = true, B -= f2), p = Math.max(0, Math.min(c2.plotX + q.plotLeft - p / 2, q.chartWidth + (q.scrollablePixels ? q.scrollablePixels - q.marginRight : 0) - p))) : p = c2.plotX + q.plotLeft - x(v.distance, 16) - p;
              0 > p && (b = false);
              a2 = (c2.series && c2.series.yAxis && c2.series.yAxis.pos) + (c2.plotY || 0);
              a2 -= B;
              c2.isHeader && (a2 = l ? -f2 : q.plotHeight + f2);
              k.push({ target: a2, rank: c2.isHeader ? 1 : 0, size: m.tt.getBBox().height + 1, point: c2, x: p, tt: A });
            }
          });
          this.cleanSplit();
          a.distribute(k, q.plotHeight + f2);
          F(k, function(a2) {
            var c2 = a2.point, d2 = c2.series;
            a2.tt.attr({ visibility: void 0 === a2.pos ? "hidden" : "inherit", x: b || c2.isHeader ? a2.x : c2.plotX + q.plotLeft + x(v.distance, 16), y: a2.pos + B, anchorX: c2.isHeader ? c2.plotX + q.plotLeft : c2.plotX + d2.xAxis.pos, anchorY: c2.isHeader ? q.plotTop + q.plotHeight / 2 : c2.plotY + d2.yAxis.pos });
          });
        }, updatePosition: function(a2) {
          var c = this.chart, e2 = this.getLabel(), k = (this.options.positioner || this.getPosition).call(this, e2.width, e2.height, a2), q = a2.plotX + c.plotLeft;
          a2 = a2.plotY + c.plotTop;
          var d;
          this.outside && (d = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(e2.width + d, e2.height + d, false), q += c.pointer.chartPosition.left - k.x, a2 += c.pointer.chartPosition.top - k.y);
          this.move(
            Math.round(k.x),
            Math.round(k.y || 0),
            q,
            a2
          );
        }, getDateFormat: function(a2, h, e2, k) {
          var c = this.chart.time, d = c.dateFormat("%m-%d %H:%M:%S.%L", h), b, v, f2 = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 }, l = "millisecond";
          for (v in y) {
            if (a2 === y.week && +c.dateFormat("%w", h) === e2 && "00:00:00.000" === d.substr(6)) {
              v = "week";
              break;
            }
            if (y[v] > a2) {
              v = l;
              break;
            }
            if (f2[v] && d.substr(f2[v]) !== "01-01 00:00:00.000".substr(f2[v]))
              break;
            "week" !== v && (l = v);
          }
          v && (b = c.resolveDTLFormat(k[v]).main);
          return b;
        }, getXDateFormat: function(a2, h, e2) {
          h = h.dateTimeLabelFormats;
          var c = e2 && e2.closestPointRange;
          return (c ? this.getDateFormat(c, a2.x, e2.options.startOfWeek, h) : h.day) || h.year;
        }, tooltipFooterHeaderFormatter: function(a2, h) {
          h = h ? "footer" : "header";
          var c = a2.series, k = c.tooltipOptions, e2 = k.xDateFormat, d = c.xAxis, b = d && "datetime" === d.options.type && f(a2.key), v = k[h + "Format"];
          b && !e2 && (e2 = this.getXDateFormat(a2, k, d));
          b && e2 && F(a2.point && a2.point.tooltipDateKeys || ["key"], function(a3) {
            v = v.replace("{point." + a3 + "}", "{point." + a3 + ":" + e2 + "}");
          });
          return n(v, { point: a2, series: c }, this.chart.time);
        }, bodyFormatter: function(a2) {
          return e(
            a2,
            function(a3) {
              var c = a3.series.tooltipOptions;
              return (c[(a3.point.formatPrefix || "point") + "Formatter"] || a3.point.tooltipFormatter).call(a3.point, c[(a3.point.formatPrefix || "point") + "Format"]);
            }
          );
        } };
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.attr, I = a.charts, n = a.color, f = a.css, e = a.defined, u = a.each, x = a.extend, t = a.find, w = a.fireEvent, y = a.isNumber, c = a.isObject, h = a.offset, p = a.pick, k = a.splat, q = a.Tooltip;
        a.Pointer = function(a2, b) {
          this.init(a2, b);
        };
        a.Pointer.prototype = {
          init: function(a2, b) {
            this.options = b;
            this.chart = a2;
            this.runChartClick = b.chart.events && !!b.chart.events.click;
            this.pinchDown = [];
            this.lastValidTouch = {};
            q && (a2.tooltip = new q(a2, b.tooltip), this.followTouchMove = p(b.tooltip.followTouchMove, true));
            this.setDOMEvents();
          },
          zoomOption: function(a2) {
            var b = this.chart, c2 = b.options.chart, d = c2.zoomType || "", b = b.inverted;
            /touch/.test(a2.type) && (d = p(c2.pinchType, d));
            this.zoomX = a2 = /x/.test(d);
            this.zoomY = d = /y/.test(d);
            this.zoomHor = a2 && !b || d && b;
            this.zoomVert = d && !b || a2 && b;
            this.hasZoom = a2 || d;
          },
          normalize: function(a2, b) {
            var c2;
            c2 = a2.touches ? a2.touches.length ? a2.touches.item(0) : a2.changedTouches[0] : a2;
            b || (this.chartPosition = b = h(this.chart.container));
            return x(a2, { chartX: Math.round(c2.pageX - b.left), chartY: Math.round(c2.pageY - b.top) });
          },
          getCoordinates: function(a2) {
            var b = { xAxis: [], yAxis: [] };
            u(this.chart.axes, function(c2) {
              b[c2.isXAxis ? "xAxis" : "yAxis"].push({ axis: c2, value: c2.toValue(a2[c2.horiz ? "chartX" : "chartY"]) });
            });
            return b;
          },
          findNearestKDPoint: function(a2, b, k2) {
            var d;
            u(a2, function(a3) {
              var l = !(a3.noSharedTooltip && b) && 0 > a3.options.findNearestPointBy.indexOf("y");
              a3 = a3.searchPoint(k2, l);
              if ((l = c(
                a3,
                true
              )) && !(l = !c(d, true)))
                var l = d.distX - a3.distX, e2 = d.dist - a3.dist, h2 = (a3.series.group && a3.series.group.zIndex) - (d.series.group && d.series.group.zIndex), l = 0 < (0 !== l && b ? l : 0 !== e2 ? e2 : 0 !== h2 ? h2 : d.series.index > a3.series.index ? -1 : 1);
              l && (d = a3);
            });
            return d;
          },
          getPointFromEvent: function(a2) {
            a2 = a2.target;
            for (var b; a2 && !b; )
              b = a2.point, a2 = a2.parentNode;
            return b;
          },
          getChartCoordinatesFromPoint: function(a2, b) {
            var c2 = a2.series, d = c2.xAxis, c2 = c2.yAxis, k2 = p(a2.clientX, a2.plotX), e2 = a2.shapeArgs;
            if (d && c2)
              return b ? { chartX: d.len + d.pos - k2, chartY: c2.len + c2.pos - a2.plotY } : { chartX: k2 + d.pos, chartY: a2.plotY + c2.pos };
            if (e2 && e2.x && e2.y)
              return { chartX: e2.x, chartY: e2.y };
          },
          getHoverData: function(d, b, k2, e2, l, h2, q2) {
            var v, m = [], f2 = q2 && q2.isBoosting;
            e2 = !(!e2 || !d);
            q2 = b && !b.stickyTracking ? [b] : a.grep(k2, function(a2) {
              return a2.visible && !(!l && a2.directTouch) && p(a2.options.enableMouseTracking, true) && a2.stickyTracking;
            });
            b = (v = e2 ? d : this.findNearestKDPoint(q2, l, h2)) && v.series;
            v && (l && !b.noSharedTooltip ? (q2 = a.grep(k2, function(a2) {
              return a2.visible && !(!l && a2.directTouch) && p(a2.options.enableMouseTracking, true) && !a2.noSharedTooltip;
            }), u(q2, function(a2) {
              var b2 = t(a2.points, function(a3) {
                return a3.x === v.x && !a3.isNull;
              });
              c(b2) && (f2 && (b2 = a2.getPoint(b2)), m.push(b2));
            })) : m.push(v));
            return { hoverPoint: v, hoverSeries: b, hoverPoints: m };
          },
          runPointActions: function(c2, b) {
            var d = this.chart, k2 = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0, l = k2 ? k2.shared : false, e2 = b || d.hoverPoint, h2 = e2 && e2.series || d.hoverSeries, h2 = this.getHoverData(e2, h2, d.series, "touchmove" !== c2.type && (!!b || h2 && h2.directTouch && this.isDirectTouch), l, c2, { isBoosting: d.isBoosting }), q2, e2 = h2.hoverPoint;
            q2 = h2.hoverPoints;
            b = (h2 = h2.hoverSeries) && h2.tooltipOptions.followPointer;
            l = l && h2 && !h2.noSharedTooltip;
            if (e2 && (e2 !== d.hoverPoint || k2 && k2.isHidden)) {
              u(d.hoverPoints || [], function(b2) {
                -1 === a.inArray(b2, q2) && b2.setState();
              });
              u(q2 || [], function(a2) {
                a2.setState("hover");
              });
              if (d.hoverSeries !== h2)
                h2.onMouseOver();
              d.hoverPoint && d.hoverPoint.firePointEvent("mouseOut");
              if (!e2.series)
                return;
              e2.firePointEvent("mouseOver");
              d.hoverPoints = q2;
              d.hoverPoint = e2;
              k2 && k2.refresh(l ? q2 : e2, c2);
            } else
              b && k2 && !k2.isHidden && (e2 = k2.getAnchor([{}], c2), k2.updatePosition({ plotX: e2[0], plotY: e2[1] }));
            this.unDocMouseMove || (this.unDocMouseMove = C(d.container.ownerDocument, "mousemove", function(b2) {
              var c3 = I[a.hoverChartIndex];
              if (c3)
                c3.pointer.onDocumentMouseMove(b2);
            }));
            u(d.axes, function(b2) {
              var d2 = p(b2.crosshair.snap, true), m = d2 ? a.find(q2, function(a2) {
                return a2.series[b2.coll] === b2;
              }) : void 0;
              m || !d2 ? b2.drawCrosshair(c2, m) : b2.hideCrosshair();
            });
          },
          reset: function(a2, b) {
            var c2 = this.chart, d = c2.hoverSeries, l = c2.hoverPoint, e2 = c2.hoverPoints, h2 = c2.tooltip, q2 = h2 && h2.shared ? e2 : l;
            a2 && q2 && u(k(q2), function(b2) {
              b2.series.isCartesian && void 0 === b2.plotX && (a2 = false);
            });
            if (a2)
              h2 && q2 && (h2.refresh(q2), h2.shared && e2 ? u(e2, function(a3) {
                a3.setState(a3.state, true);
                a3.series.isCartesian && (a3.series.xAxis.crosshair && a3.series.xAxis.drawCrosshair(null, a3), a3.series.yAxis.crosshair && a3.series.yAxis.drawCrosshair(null, a3));
              }) : l && (l.setState(l.state, true), u(c2.axes, function(a3) {
                a3.crosshair && a3.drawCrosshair(null, l);
              })));
            else {
              if (l)
                l.onMouseOut();
              e2 && u(e2, function(a3) {
                a3.setState();
              });
              if (d)
                d.onMouseOut();
              h2 && h2.hide(b);
              this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
              u(c2.axes, function(a3) {
                a3.hideCrosshair();
              });
              this.hoverX = c2.hoverPoints = c2.hoverPoint = null;
            }
          },
          scaleGroups: function(a2, b) {
            var c2 = this.chart, d;
            u(c2.series, function(k2) {
              d = a2 || k2.getPlotBox();
              k2.xAxis && k2.xAxis.zoomEnabled && k2.group && (k2.group.attr(d), k2.markerGroup && (k2.markerGroup.attr(d), k2.markerGroup.clip(b ? c2.clipRect : null)), k2.dataLabelsGroup && k2.dataLabelsGroup.attr(d));
            });
            c2.clipRect.attr(b || c2.clipBox);
          },
          dragStart: function(a2) {
            var b = this.chart;
            b.mouseIsDown = a2.type;
            b.cancelClick = false;
            b.mouseDownX = this.mouseDownX = a2.chartX;
            b.mouseDownY = this.mouseDownY = a2.chartY;
          },
          drag: function(a2) {
            var b = this.chart, c2 = b.options.chart, d = a2.chartX, k2 = a2.chartY, e2 = this.zoomHor, h2 = this.zoomVert, q2 = b.plotLeft, m = b.plotTop, f2 = b.plotWidth, A = b.plotHeight, p2, E = this.selectionMarker, g = this.mouseDownX, r = this.mouseDownY, t2 = c2.panKey && a2[c2.panKey + "Key"];
            E && E.touch || (d < q2 ? d = q2 : d > q2 + f2 && (d = q2 + f2), k2 < m ? k2 = m : k2 > m + A && (k2 = m + A), this.hasDragged = Math.sqrt(Math.pow(g - d, 2) + Math.pow(r - k2, 2)), 10 < this.hasDragged && (p2 = b.isInsidePlot(g - q2, r - m), b.hasCartesianSeries && (this.zoomX || this.zoomY) && p2 && !t2 && !E && (this.selectionMarker = E = b.renderer.rect(
              q2,
              m,
              e2 ? 1 : f2,
              h2 ? 1 : A,
              0
            ).attr({ fill: c2.selectionMarkerFill || n("#335cad").setOpacity(0.25).get(), "class": "highcharts-selection-marker", zIndex: 7 }).add()), E && e2 && (d -= g, E.attr({ width: Math.abs(d), x: (0 < d ? 0 : d) + g })), E && h2 && (d = k2 - r, E.attr({ height: Math.abs(d), y: (0 < d ? 0 : d) + r })), p2 && !E && c2.panning && b.pan(a2, c2.panning)));
          },
          drop: function(a2) {
            var b = this, c2 = this.chart, d = this.hasPinched;
            if (this.selectionMarker) {
              var k2 = { originalEvent: a2, xAxis: [], yAxis: [] }, h2 = this.selectionMarker, q2 = h2.attr ? h2.attr("x") : h2.x, p2 = h2.attr ? h2.attr("y") : h2.y, m = h2.attr ? h2.attr("width") : h2.width, G = h2.attr ? h2.attr("height") : h2.height, A;
              if (this.hasDragged || d)
                u(c2.axes, function(c3) {
                  if (c3.zoomEnabled && e(c3.min) && (d || b[{ xAxis: "zoomX", yAxis: "zoomY" }[c3.coll]])) {
                    var h3 = c3.horiz, g = "touchend" === a2.type ? c3.minPixelPadding : 0, l = c3.toValue((h3 ? q2 : p2) + g), h3 = c3.toValue((h3 ? q2 + m : p2 + G) - g);
                    k2[c3.coll].push({ axis: c3, min: Math.min(l, h3), max: Math.max(l, h3) });
                    A = true;
                  }
                }), A && w(c2, "selection", k2, function(a3) {
                  c2.zoom(x(a3, d ? { animation: false } : null));
                });
              y(c2.index) && (this.selectionMarker = this.selectionMarker.destroy());
              d && this.scaleGroups();
            }
            c2 && y(c2.index) && (f(c2.container, { cursor: c2._cursor }), c2.cancelClick = 10 < this.hasDragged, c2.mouseIsDown = this.hasDragged = this.hasPinched = false, this.pinchDown = []);
          },
          onContainerMouseDown: function(a2) {
            a2 = this.normalize(a2);
            2 !== a2.button && (this.zoomOption(a2), a2.preventDefault && a2.preventDefault(), this.dragStart(a2));
          },
          onDocumentMouseUp: function(c2) {
            I[a.hoverChartIndex] && I[a.hoverChartIndex].pointer.drop(c2);
          },
          onDocumentMouseMove: function(a2) {
            var b = this.chart, c2 = this.chartPosition;
            a2 = this.normalize(a2, c2);
            !c2 || this.inClass(a2.target, "highcharts-tracker") || b.isInsidePlot(a2.chartX - b.plotLeft, a2.chartY - b.plotTop) || this.reset();
          },
          onContainerMouseLeave: function(c2) {
            var b = I[a.hoverChartIndex];
            b && (c2.relatedTarget || c2.toElement) && (b.pointer.reset(), b.pointer.chartPosition = null);
          },
          onContainerMouseMove: function(c2) {
            var b = this.chart;
            e(a.hoverChartIndex) && I[a.hoverChartIndex] && I[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = b.index);
            c2 = this.normalize(c2);
            c2.returnValue = false;
            "mousedown" === b.mouseIsDown && this.drag(c2);
            !this.inClass(c2.target, "highcharts-tracker") && !b.isInsidePlot(c2.chartX - b.plotLeft, c2.chartY - b.plotTop) || b.openMenu || this.runPointActions(c2);
          },
          inClass: function(a2, b) {
            for (var c2; a2; ) {
              if (c2 = F(a2, "class")) {
                if (-1 !== c2.indexOf(b))
                  return true;
                if (-1 !== c2.indexOf("highcharts-container"))
                  return false;
              }
              a2 = a2.parentNode;
            }
          },
          onTrackerMouseOut: function(a2) {
            var b = this.chart.hoverSeries;
            a2 = a2.relatedTarget || a2.toElement;
            this.isDirectTouch = false;
            if (!(!b || !a2 || b.stickyTracking || this.inClass(a2, "highcharts-tooltip") || this.inClass(a2, "highcharts-series-" + b.index) && this.inClass(a2, "highcharts-tracker")))
              b.onMouseOut();
          },
          onContainerClick: function(a2) {
            var b = this.chart, c2 = b.hoverPoint, d = b.plotLeft, k2 = b.plotTop;
            a2 = this.normalize(a2);
            b.cancelClick || (c2 && this.inClass(a2.target, "highcharts-tracker") ? (w(c2.series, "click", x(a2, { point: c2 })), b.hoverPoint && c2.firePointEvent("click", a2)) : (x(a2, this.getCoordinates(a2)), b.isInsidePlot(a2.chartX - d, a2.chartY - k2) && w(b, "click", a2)));
          },
          setDOMEvents: function() {
            var c2 = this, b = c2.chart.container, k2 = b.ownerDocument;
            b.onmousedown = function(a2) {
              c2.onContainerMouseDown(a2);
            };
            b.onmousemove = function(a2) {
              c2.onContainerMouseMove(a2);
            };
            b.onclick = function(a2) {
              c2.onContainerClick(a2);
            };
            this.unbindContainerMouseLeave = C(b, "mouseleave", c2.onContainerMouseLeave);
            a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = C(k2, "mouseup", c2.onDocumentMouseUp));
            a.hasTouch && (b.ontouchstart = function(a2) {
              c2.onContainerTouchStart(a2);
            }, b.ontouchmove = function(a2) {
              c2.onContainerTouchMove(a2);
            }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = C(k2, "touchend", c2.onDocumentTouchEnd)));
          },
          destroy: function() {
            var c2 = this;
            c2.unDocMouseMove && c2.unDocMouseMove();
            this.unbindContainerMouseLeave();
            a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
            clearInterval(c2.tooltipTimeout);
            a.objectEach(c2, function(a2, d) {
              c2[d] = null;
            });
          }
        };
      })(K);
      (function(a) {
        var C = a.charts, F = a.each, I = a.extend, n = a.map, f = a.noop, e = a.pick;
        I(a.Pointer.prototype, { pinchTranslate: function(a2, e2, f2, n2, y, c) {
          this.zoomHor && this.pinchTranslateDirection(true, a2, e2, f2, n2, y, c);
          this.zoomVert && this.pinchTranslateDirection(
            false,
            a2,
            e2,
            f2,
            n2,
            y,
            c
          );
        }, pinchTranslateDirection: function(a2, e2, f2, n2, y, c, h, p) {
          var k = this.chart, q = a2 ? "x" : "y", d = a2 ? "X" : "Y", b = "chart" + d, v = a2 ? "width" : "height", t = k["plot" + (a2 ? "Left" : "Top")], l, u, B = p || 1, D = k.inverted, m = k.bounds[a2 ? "h" : "v"], G = 1 === e2.length, A = e2[0][b], N = f2[0][b], E = !G && e2[1][b], g = !G && f2[1][b], r;
          f2 = function() {
            !G && 20 < Math.abs(A - E) && (B = p || Math.abs(N - g) / Math.abs(A - E));
            u = (t - N) / B + A;
            l = k["plot" + (a2 ? "Width" : "Height")] / B;
          };
          f2();
          e2 = u;
          e2 < m.min ? (e2 = m.min, r = true) : e2 + l > m.max && (e2 = m.max - l, r = true);
          r ? (N -= 0.8 * (N - h[q][0]), G || (g -= 0.8 * (g - h[q][1])), f2()) : h[q] = [N, g];
          D || (c[q] = u - t, c[v] = l);
          c = D ? 1 / B : B;
          y[v] = l;
          y[q] = e2;
          n2[D ? a2 ? "scaleY" : "scaleX" : "scale" + d] = B;
          n2["translate" + d] = c * t + (N - c * A);
        }, pinch: function(a2) {
          var u = this, t = u.chart, w = u.pinchDown, y = a2.touches, c = y.length, h = u.lastValidTouch, p = u.hasZoom, k = u.selectionMarker, q = {}, d = 1 === c && (u.inClass(a2.target, "highcharts-tracker") && t.runTrackerClick || u.runChartClick), b = {};
          1 < c && (u.initiated = true);
          p && u.initiated && !d && a2.preventDefault();
          n(y, function(a3) {
            return u.normalize(a3);
          });
          "touchstart" === a2.type ? (F(y, function(a3, b2) {
            w[b2] = {
              chartX: a3.chartX,
              chartY: a3.chartY
            };
          }), h.x = [w[0].chartX, w[1] && w[1].chartX], h.y = [w[0].chartY, w[1] && w[1].chartY], F(t.axes, function(a3) {
            if (a3.zoomEnabled) {
              var b2 = t.bounds[a3.horiz ? "h" : "v"], c2 = a3.minPixelPadding, d2 = a3.toPixels(e(a3.options.min, a3.dataMin)), k2 = a3.toPixels(e(a3.options.max, a3.dataMax)), h2 = Math.max(d2, k2);
              b2.min = Math.min(a3.pos, Math.min(d2, k2) - c2);
              b2.max = Math.max(a3.pos + a3.len, h2 + c2);
            }
          }), u.res = true) : u.followTouchMove && 1 === c ? this.runPointActions(u.normalize(a2)) : w.length && (k || (u.selectionMarker = k = I({ destroy: f, touch: true }, t.plotBox)), u.pinchTranslate(
            w,
            y,
            q,
            k,
            b,
            h
          ), u.hasPinched = p, u.scaleGroups(q, b), u.res && (u.res = false, this.reset(false, 0)));
        }, touch: function(f2, n2) {
          var t = this.chart, u, y;
          if (t.index !== a.hoverChartIndex)
            this.onContainerMouseLeave({ relatedTarget: true });
          a.hoverChartIndex = t.index;
          1 === f2.touches.length ? (f2 = this.normalize(f2), (y = t.isInsidePlot(f2.chartX - t.plotLeft, f2.chartY - t.plotTop)) && !t.openMenu ? (n2 && this.runPointActions(f2), "touchmove" === f2.type && (n2 = this.pinchDown, u = n2[0] ? 4 <= Math.sqrt(Math.pow(n2[0].chartX - f2.chartX, 2) + Math.pow(n2[0].chartY - f2.chartY, 2)) : false), e(
            u,
            true
          ) && this.pinch(f2)) : n2 && this.reset()) : 2 === f2.touches.length && this.pinch(f2);
        }, onContainerTouchStart: function(a2) {
          this.zoomOption(a2);
          this.touch(a2, true);
        }, onContainerTouchMove: function(a2) {
          this.touch(a2);
        }, onDocumentTouchEnd: function(e2) {
          C[a.hoverChartIndex] && C[a.hoverChartIndex].pointer.drop(e2);
        } });
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.charts, I = a.css, n = a.doc, f = a.extend, e = a.noop, u = a.Pointer, x = a.removeEvent, t = a.win, w = a.wrap;
        if (!a.hasTouch && (t.PointerEvent || t.MSPointerEvent)) {
          var y = {}, c = !!t.PointerEvent, h = function() {
            var c2 = [];
            c2.item = function(a2) {
              return this[a2];
            };
            a.objectEach(y, function(a2) {
              c2.push({ pageX: a2.pageX, pageY: a2.pageY, target: a2.target });
            });
            return c2;
          }, p = function(c2, q, d, b) {
            "touch" !== c2.pointerType && c2.pointerType !== c2.MSPOINTER_TYPE_TOUCH || !F[a.hoverChartIndex] || (b(c2), b = F[a.hoverChartIndex].pointer, b[q]({ type: d, target: c2.currentTarget, preventDefault: e, touches: h() }));
          };
          f(u.prototype, {
            onContainerPointerDown: function(a2) {
              p(a2, "onContainerTouchStart", "touchstart", function(a3) {
                y[a3.pointerId] = { pageX: a3.pageX, pageY: a3.pageY, target: a3.currentTarget };
              });
            },
            onContainerPointerMove: function(a2) {
              p(a2, "onContainerTouchMove", "touchmove", function(a3) {
                y[a3.pointerId] = { pageX: a3.pageX, pageY: a3.pageY };
                y[a3.pointerId].target || (y[a3.pointerId].target = a3.currentTarget);
              });
            },
            onDocumentPointerUp: function(a2) {
              p(a2, "onDocumentTouchEnd", "touchend", function(a3) {
                delete y[a3.pointerId];
              });
            },
            batchMSEvents: function(a2) {
              a2(this.chart.container, c ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
              a2(this.chart.container, c ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
              a2(n, c ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
            }
          });
          w(u.prototype, "init", function(a2, c2, d) {
            a2.call(this, c2, d);
            this.hasZoom && I(c2.container, { "-ms-touch-action": "none", "touch-action": "none" });
          });
          w(u.prototype, "setDOMEvents", function(a2) {
            a2.apply(this);
            (this.hasZoom || this.followTouchMove) && this.batchMSEvents(C);
          });
          w(u.prototype, "destroy", function(a2) {
            this.batchMSEvents(x);
            a2.call(this);
          });
        }
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.css, I = a.discardElement, n = a.defined, f = a.each, e = a.fireEvent, u = a.isFirefox, x = a.marginNames, t = a.merge, w = a.pick, y = a.setAnimation, c = a.stableSort, h = a.win, p = a.wrap;
        a.Legend = function(a2, c2) {
          this.init(a2, c2);
        };
        a.Legend.prototype = { init: function(a2, c2) {
          this.chart = a2;
          this.setOptions(c2);
          c2.enabled && (this.render(), C(this.chart, "endResize", function() {
            this.legend.positionCheckboxes();
          }), this.proximate ? this.unchartrender = C(this.chart, "render", function() {
            this.legend.proximatePositions();
            this.legend.positionItems();
          }) : this.unchartrender && this.unchartrender());
        }, setOptions: function(a2) {
          var c2 = w(a2.padding, 8);
          this.options = a2;
          this.itemStyle = a2.itemStyle;
          this.itemHiddenStyle = t(this.itemStyle, a2.itemHiddenStyle);
          this.itemMarginTop = a2.itemMarginTop || 0;
          this.padding = c2;
          this.initialItemY = c2 - 5;
          this.symbolWidth = w(a2.symbolWidth, 16);
          this.pages = [];
          this.proximate = "proximate" === a2.layout && !this.chart.inverted;
        }, update: function(a2, c2) {
          var d = this.chart;
          this.setOptions(t(true, this.options, a2));
          this.destroy();
          d.isDirtyLegend = d.isDirtyBox = true;
          w(c2, true) && d.redraw();
          e(this, "afterUpdate");
        }, colorizeItem: function(a2, c2) {
          a2.legendGroup[c2 ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
          var d = this.options, b = a2.legendItem, k = a2.legendLine, h2 = a2.legendSymbol, l = this.itemHiddenStyle.color, d = c2 ? d.itemStyle.color : l, q = c2 ? a2.color || l : l, f2 = a2.options && a2.options.marker, p2 = { fill: q };
          b && b.css({ fill: d, color: d });
          k && k.attr({ stroke: q });
          h2 && (f2 && h2.isMarker && (p2 = a2.pointAttribs(), c2 || (p2.stroke = p2.fill = l)), h2.attr(p2));
          e(this, "afterColorizeItem", { item: a2, visible: c2 });
        }, positionItems: function() {
          f(this.allItems, this.positionItem, this);
          this.chart.isResizing || this.positionCheckboxes();
        }, positionItem: function(a2) {
          var c2 = this.options, d = c2.symbolPadding, c2 = !c2.rtl, b = a2._legendItemPos, e2 = b[0], b = b[1], h2 = a2.checkbox;
          if ((a2 = a2.legendGroup) && a2.element)
            a2[n(a2.translateY) ? "animate" : "attr"]({ translateX: c2 ? e2 : this.legendWidth - e2 - 2 * d - 4, translateY: b });
          h2 && (h2.x = e2, h2.y = b);
        }, destroyItem: function(a2) {
          var c2 = a2.checkbox;
          f(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function(c3) {
            a2[c3] && (a2[c3] = a2[c3].destroy());
          });
          c2 && I(a2.checkbox);
        }, destroy: function() {
          function a2(a3) {
            this[a3] && (this[a3] = this[a3].destroy());
          }
          f(this.getAllItems(), function(c2) {
            f(
              ["legendItem", "legendGroup"],
              a2,
              c2
            );
          });
          f("clipRect up down pager nav box title group".split(" "), a2, this);
          this.display = null;
        }, positionCheckboxes: function() {
          var a2 = this.group && this.group.alignAttr, c2, d = this.clipHeight || this.legendHeight, b = this.titleHeight;
          a2 && (c2 = a2.translateY, f(this.allItems, function(e2) {
            var h2 = e2.checkbox, k;
            h2 && (k = c2 + b + h2.y + (this.scrollOffset || 0) + 3, F(h2, { left: a2.translateX + e2.checkboxOffset + h2.x - 20 + "px", top: k + "px", display: this.proximate || k > c2 - 6 && k < c2 + d - 6 ? "" : "none" }));
          }, this));
        }, renderTitle: function() {
          var a2 = this.options, c2 = this.padding, d = a2.title, b = 0;
          d.text && (this.title || (this.title = this.chart.renderer.label(d.text, c2 - 3, c2 - 4, null, null, null, a2.useHTML, null, "legend-title").attr({ zIndex: 1 }).css(d.style).add(this.group)), a2 = this.title.getBBox(), b = a2.height, this.offsetWidth = a2.width, this.contentGroup.attr({ translateY: b }));
          this.titleHeight = b;
        }, setText: function(c2) {
          var h2 = this.options;
          c2.legendItem.attr({ text: h2.labelFormat ? a.format(h2.labelFormat, c2, this.chart.time) : h2.labelFormatter.call(c2) });
        }, renderItem: function(a2) {
          var c2 = this.chart, d = c2.renderer, b = this.options, h2 = this.symbolWidth, e2 = b.symbolPadding, l = this.itemStyle, k = this.itemHiddenStyle, f2 = "horizontal" === b.layout ? w(b.itemDistance, 20) : 0, p2 = !b.rtl, m = a2.legendItem, G = !a2.series, A = !G && a2.series.drawLegendSymbol ? a2.series : a2, n2 = A.options, n2 = this.createCheckboxForItem && n2 && n2.showCheckbox, f2 = h2 + e2 + f2 + (n2 ? 20 : 0), E = b.useHTML, g = a2.options.className;
          m || (a2.legendGroup = d.g("legend-item").addClass("highcharts-" + A.type + "-series highcharts-color-" + a2.colorIndex + (g ? " " + g : "") + (G ? " highcharts-series-" + a2.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), a2.legendItem = m = d.text("", p2 ? h2 + e2 : -e2, this.baseline || 0, E).css(t(a2.visible ? l : k)).attr({ align: p2 ? "left" : "right", zIndex: 2 }).add(a2.legendGroup), this.baseline || (h2 = l.fontSize, this.fontMetrics = d.fontMetrics(h2, m), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, m.attr("y", this.baseline)), this.symbolHeight = b.symbolHeight || this.fontMetrics.f, A.drawLegendSymbol(this, a2), this.setItemEvents && this.setItemEvents(a2, m, E), n2 && this.createCheckboxForItem(a2));
          this.colorizeItem(a2, a2.visible);
          l.width || m.css({ width: (b.itemWidth || b.width || c2.spacingBox.width) - f2 });
          this.setText(a2);
          c2 = m.getBBox();
          a2.itemWidth = a2.checkboxOffset = b.itemWidth || a2.legendItemWidth || c2.width + f2;
          this.maxItemWidth = Math.max(this.maxItemWidth, a2.itemWidth);
          this.totalItemWidth += a2.itemWidth;
          this.itemHeight = a2.itemHeight = Math.round(a2.legendItemHeight || c2.height || this.symbolHeight);
        }, layoutItem: function(a2) {
          var c2 = this.options, d = this.padding, b = "horizontal" === c2.layout, h2 = a2.itemHeight, e2 = c2.itemMarginBottom || 0, l = this.itemMarginTop, k = b ? w(c2.itemDistance, 20) : 0, f2 = c2.width, p2 = f2 || this.chart.spacingBox.width - 2 * d - c2.x, c2 = c2.alignColumns && this.totalItemWidth > p2 ? this.maxItemWidth : a2.itemWidth;
          b && this.itemX - d + c2 > p2 && (this.itemX = d, this.itemY += l + this.lastLineHeight + e2, this.lastLineHeight = 0);
          this.lastItemY = l + this.itemY + e2;
          this.lastLineHeight = Math.max(h2, this.lastLineHeight);
          a2._legendItemPos = [this.itemX, this.itemY];
          b ? this.itemX += c2 : (this.itemY += l + h2 + e2, this.lastLineHeight = h2);
          this.offsetWidth = f2 || Math.max((b ? this.itemX - d - (a2.checkbox ? 0 : k) : c2) + d, this.offsetWidth);
        }, getAllItems: function() {
          var a2 = [];
          f(this.chart.series, function(c2) {
            var d = c2 && c2.options;
            c2 && w(d.showInLegend, n(d.linkedTo) ? false : void 0, true) && (a2 = a2.concat(c2.legendItems || ("point" === d.legendType ? c2.data : c2)));
          });
          e(this, "afterGetAllItems", { allItems: a2 });
          return a2;
        }, getAlignment: function() {
          var a2 = this.options;
          return this.proximate ? a2.align.charAt(0) + "tv" : a2.floating ? "" : a2.align.charAt(0) + a2.verticalAlign.charAt(0) + a2.layout.charAt(0);
        }, adjustMargins: function(a2, c2) {
          var d = this.chart, b = this.options, h2 = this.getAlignment();
          h2 && f([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function(e2, l) {
            e2.test(h2) && !n(a2[l]) && (d[x[l]] = Math.max(d[x[l]], d.legend[(l + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][l] * b[l % 2 ? "x" : "y"] + w(b.margin, 12) + c2[l] + (0 === l && void 0 !== d.options.title.margin ? d.titleOffset + d.options.title.margin : 0)));
          });
        }, proximatePositions: function() {
          var c2 = this.chart, h2 = [], d = "left" === this.options.align;
          f(this.allItems, function(b) {
            var e2, k;
            e2 = d;
            b.xAxis && b.points && (b.xAxis.options.reversed && (e2 = !e2), e2 = a.find(e2 ? b.points : b.points.slice(0).reverse(), function(b2) {
              return a.isNumber(b2.plotY);
            }), k = b.legendGroup.getBBox().height, h2.push({ target: b.visible ? (e2 ? e2.plotY : b.xAxis.height) - 0.3 * k : c2.plotHeight, size: k, item: b }));
          }, this);
          a.distribute(h2, c2.plotHeight);
          f(h2, function(a2) {
            a2.item._legendItemPos[1] = c2.plotTop - c2.spacing[0] + a2.pos;
          });
        }, render: function() {
          var a2 = this.chart, h2 = a2.renderer, d = this.group, b, e2, p2, l = this.box, n2 = this.options, B = this.padding;
          this.itemX = B;
          this.itemY = this.initialItemY;
          this.lastItemY = this.offsetWidth = 0;
          d || (this.group = d = h2.g("legend").attr({ zIndex: 7 }).add(), this.contentGroup = h2.g().attr({ zIndex: 1 }).add(d), this.scrollGroup = h2.g().add(this.contentGroup));
          this.renderTitle();
          b = this.getAllItems();
          c(b, function(a3, b2) {
            return (a3.options && a3.options.legendIndex || 0) - (b2.options && b2.options.legendIndex || 0);
          });
          n2.reversed && b.reverse();
          this.allItems = b;
          this.display = e2 = !!b.length;
          this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
          f(b, this.renderItem, this);
          f(b, this.layoutItem, this);
          b = (n2.width || this.offsetWidth) + B;
          p2 = this.lastItemY + this.lastLineHeight + this.titleHeight;
          p2 = this.handleOverflow(p2);
          p2 += B;
          l || (this.box = l = h2.rect().addClass("highcharts-legend-box").attr({ r: n2.borderRadius }).add(d), l.isNew = true);
          l.attr({ stroke: n2.borderColor, "stroke-width": n2.borderWidth || 0, fill: n2.backgroundColor || "none" }).shadow(n2.shadow);
          0 < b && 0 < p2 && (l[l.isNew ? "attr" : "animate"](l.crisp.call({}, { x: 0, y: 0, width: b, height: p2 }, l.strokeWidth())), l.isNew = false);
          l[e2 ? "show" : "hide"]();
          this.legendWidth = b;
          this.legendHeight = p2;
          e2 && (h2 = a2.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (h2 = t(h2, { y: h2.y + a2.titleOffset + a2.options.title.margin })), d.align(t(n2, { width: b, height: p2, verticalAlign: this.proximate ? "top" : n2.verticalAlign }), true, h2));
          this.proximate || this.positionItems();
        }, handleOverflow: function(a2) {
          var c2 = this, d = this.chart, b = d.renderer, h2 = this.options, e2 = h2.y, l = this.padding, d = d.spacingBox.height + ("top" === h2.verticalAlign ? -e2 : e2) - l, e2 = h2.maxHeight, k, p2 = this.clipRect, n2 = h2.navigation, m = w(n2.animation, true), G = n2.arrowSize || 12, A = this.nav, t2 = this.pages, E, g = this.allItems, r = function(a3) {
            "number" === typeof a3 ? p2.attr({ height: a3 }) : p2 && (c2.clipRect = p2.destroy(), c2.contentGroup.clip());
            c2.contentGroup.div && (c2.contentGroup.div.style.clip = a3 ? "rect(" + l + "px,9999px," + (l + a3) + "px,0)" : "auto");
          };
          "horizontal" !== h2.layout || "middle" === h2.verticalAlign || h2.floating || (d /= 2);
          e2 && (d = Math.min(d, e2));
          t2.length = 0;
          a2 > d && false !== n2.enabled ? (this.clipHeight = k = Math.max(d - 20 - this.titleHeight - l, 0), this.currentPage = w(this.currentPage, 1), this.fullHeight = a2, f(g, function(a3, b2) {
            var c3 = a3._legendItemPos[1], d2 = Math.round(a3.legendItem.getBBox().height), m2 = t2.length;
            if (!m2 || c3 - t2[m2 - 1] > k && (E || c3) !== t2[m2 - 1])
              t2.push(E || c3), m2++;
            a3.pageIx = m2 - 1;
            E && (g[b2 - 1].pageIx = m2 - 1);
            b2 === g.length - 1 && c3 + d2 - t2[m2 - 1] > k && (t2.push(c3), a3.pageIx = m2);
            c3 !== E && (E = c3);
          }), p2 || (p2 = c2.clipRect = b.clipRect(0, l, 9999, 0), c2.contentGroup.clip(p2)), r(k), A || (this.nav = A = b.g().attr({ zIndex: 1 }).add(this.group), this.up = b.symbol("triangle", 0, 0, G, G).on("click", function() {
            c2.scroll(-1, m);
          }).add(A), this.pager = b.text("", 15, 10).addClass("highcharts-legend-navigation").css(n2.style).add(A), this.down = b.symbol("triangle-down", 0, 0, G, G).on("click", function() {
            c2.scroll(1, m);
          }).add(A)), c2.scroll(0), a2 = d) : A && (r(), this.nav = A.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0);
          return a2;
        }, scroll: function(a2, c2) {
          var d = this.pages, b = d.length;
          a2 = this.currentPage + a2;
          var h2 = this.clipHeight, e2 = this.options.navigation, l = this.pager, f2 = this.padding;
          a2 > b && (a2 = b);
          0 < a2 && (void 0 !== c2 && y(c2, this.chart), this.nav.attr({ translateX: f2, translateY: h2 + this.padding + 7 + this.titleHeight, visibility: "visible" }), this.up.attr({ "class": 1 === a2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }), l.attr({ text: a2 + "/" + b }), this.down.attr({ x: 18 + this.pager.getBBox().width, "class": a2 === b ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }), this.up.attr({ fill: 1 === a2 ? e2.inactiveColor : e2.activeColor }).css({ cursor: 1 === a2 ? "default" : "pointer" }), this.down.attr({ fill: a2 === b ? e2.inactiveColor : e2.activeColor }).css({ cursor: a2 === b ? "default" : "pointer" }), this.scrollOffset = -d[a2 - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = a2, this.positionCheckboxes());
        } };
        a.LegendSymbolMixin = { drawRectangle: function(a2, c2) {
          var d = a2.symbolHeight, b = a2.options.squareSymbol;
          c2.legendSymbol = this.chart.renderer.rect(b ? (a2.symbolWidth - d) / 2 : 0, a2.baseline - d + 1, b ? d : a2.symbolWidth, d, w(a2.options.symbolRadius, d / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(c2.legendGroup);
        }, drawLineMarker: function(a2) {
          var c2 = this.options, d = c2.marker, b = a2.symbolWidth, h2 = a2.symbolHeight, e2 = h2 / 2, l = this.chart.renderer, f2 = this.legendGroup;
          a2 = a2.baseline - Math.round(0.3 * a2.fontMetrics.b);
          var k;
          k = { "stroke-width": c2.lineWidth || 0 };
          c2.dashStyle && (k.dashstyle = c2.dashStyle);
          this.legendLine = l.path(["M", 0, a2, "L", b, a2]).addClass("highcharts-graph").attr(k).add(f2);
          d && false !== d.enabled && b && (c2 = Math.min(w(d.radius, e2), e2), 0 === this.symbol.indexOf("url") && (d = t(d, { width: h2, height: h2 }), c2 = 0), this.legendSymbol = d = l.symbol(this.symbol, b / 2 - c2, a2 - c2, 2 * c2, 2 * c2, d).addClass("highcharts-point").add(f2), d.isMarker = true);
        } };
        (/Trident\/7\.0/.test(h.navigator.userAgent) || u) && p(a.Legend.prototype, "positionItem", function(a2, c2) {
          var d = this, b = function() {
            c2._legendItemPos && a2.call(d, c2);
          };
          b();
          setTimeout(b);
        });
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.animate, I = a.animObject, n = a.attr, f = a.doc, e = a.Axis, u = a.createElement, x = a.defaultOptions, t = a.discardElement, w = a.charts, y = a.css, c = a.defined, h = a.each, p = a.extend, k = a.find, q = a.fireEvent, d = a.grep, b = a.isNumber, v = a.isObject, J = a.isString, l = a.Legend, L = a.marginNames, B = a.merge, D = a.objectEach, m = a.Pointer, G = a.pick, A = a.pInt, N = a.removeEvent, E = a.seriesTypes, g = a.splat, r = a.syncTimeout, M = a.win, O = a.Chart = function() {
          this.getArgs.apply(this, arguments);
        };
        a.chart = function(a2, b2, c2) {
          return new O(a2, b2, c2);
        };
        p(O.prototype, {
          callbacks: [],
          getArgs: function() {
            var a2 = [].slice.call(arguments);
            if (J(a2[0]) || a2[0].nodeName)
              this.renderTo = a2.shift();
            this.init(a2[0], a2[1]);
          },
          init: function(b2, c2) {
            var d2, g2, m2 = b2.series, h2 = b2.plotOptions || {};
            q(this, "init", { args: arguments }, function() {
              b2.series = null;
              d2 = B(x, b2);
              for (g2 in d2.plotOptions)
                d2.plotOptions[g2].tooltip = h2[g2] && B(h2[g2].tooltip) || void 0;
              d2.tooltip.userOptions = b2.chart && b2.chart.forExport && b2.tooltip.userOptions || b2.tooltip;
              d2.series = b2.series = m2;
              this.userOptions = b2;
              var e2 = d2.chart, l2 = e2.events;
              this.margin = [];
              this.spacing = [];
              this.bounds = { h: {}, v: {} };
              this.labelCollectors = [];
              this.callback = c2;
              this.isResizing = 0;
              this.options = d2;
              this.axes = [];
              this.series = [];
              this.time = b2.time && a.keys(b2.time).length ? new a.Time(b2.time) : a.time;
              this.hasCartesianSeries = e2.showAxes;
              var f2 = this;
              f2.index = w.length;
              w.push(f2);
              a.chartCount++;
              l2 && D(l2, function(a2, b3) {
                C(f2, b3, a2);
              });
              f2.xAxis = [];
              f2.yAxis = [];
              f2.pointCount = f2.colorCounter = f2.symbolCounter = 0;
              q(f2, "afterInit");
              f2.firstRender();
            });
          },
          initSeries: function(b2) {
            var c2 = this.options.chart;
            (c2 = E[b2.type || c2.type || c2.defaultSeriesType]) || a.error(17, true);
            c2 = new c2();
            c2.init(this, b2);
            return c2;
          },
          orderSeries: function(a2) {
            var b2 = this.series;
            for (a2 = a2 || 0; a2 < b2.length; a2++)
              b2[a2] && (b2[a2].index = a2, b2[a2].name = b2[a2].getName());
          },
          isInsidePlot: function(a2, b2, c2) {
            var d2 = c2 ? b2 : a2;
            a2 = c2 ? a2 : b2;
            return 0 <= d2 && d2 <= this.plotWidth && 0 <= a2 && a2 <= this.plotHeight;
          },
          redraw: function(b2) {
            q(this, "beforeRedraw");
            var c2 = this.axes, d2 = this.series, g2 = this.pointer, m2 = this.legend, e2 = this.userOptions.legend, l2 = this.isDirtyLegend, f2, A2, k2 = this.hasCartesianSeries, r2 = this.isDirtyBox, G2, v2 = this.renderer, H = v2.isHidden(), E2 = [];
            this.setResponsive && this.setResponsive(false);
            a.setAnimation(b2, this);
            H && this.temporaryDisplay();
            this.layOutTitles();
            for (b2 = d2.length; b2--; )
              if (G2 = d2[b2], G2.options.stacking && (f2 = true, G2.isDirty)) {
                A2 = true;
                break;
              }
            if (A2)
              for (b2 = d2.length; b2--; )
                G2 = d2[b2], G2.options.stacking && (G2.isDirty = true);
            h(d2, function(a2) {
              a2.isDirty && ("point" === a2.options.legendType ? (a2.updateTotals && a2.updateTotals(), l2 = true) : e2 && (e2.labelFormatter || e2.labelFormat) && (l2 = true));
              a2.isDirtyData && q(a2, "updatedData");
            });
            l2 && m2 && m2.options.enabled && (m2.render(), this.isDirtyLegend = false);
            f2 && this.getStacks();
            k2 && h(c2, function(a2) {
              a2.updateNames();
              a2.updateYNames && a2.updateYNames();
              a2.setScale();
            });
            this.getMargins();
            k2 && (h(c2, function(a2) {
              a2.isDirty && (r2 = true);
            }), h(c2, function(a2) {
              var b3 = a2.min + "," + a2.max;
              a2.extKey !== b3 && (a2.extKey = b3, E2.push(function() {
                q(a2, "afterSetExtremes", p(a2.eventArgs, a2.getExtremes()));
                delete a2.eventArgs;
              }));
              (r2 || f2) && a2.redraw();
            }));
            r2 && this.drawChartBox();
            q(this, "predraw");
            h(d2, function(a2) {
              (r2 || a2.isDirty) && a2.visible && a2.redraw();
              a2.isDirtyData = false;
            });
            g2 && g2.reset(true);
            v2.draw();
            q(this, "redraw");
            q(this, "render");
            H && this.temporaryDisplay(true);
            h(E2, function(a2) {
              a2.call();
            });
          },
          get: function(a2) {
            function b2(b3) {
              return b3.id === a2 || b3.options && b3.options.id === a2;
            }
            var c2, d2 = this.series, g2;
            c2 = k(this.axes, b2) || k(this.series, b2);
            for (g2 = 0; !c2 && g2 < d2.length; g2++)
              c2 = k(d2[g2].points || [], b2);
            return c2;
          },
          getAxes: function() {
            var a2 = this, b2 = this.options, c2 = b2.xAxis = g(b2.xAxis || {}), b2 = b2.yAxis = g(b2.yAxis || {});
            q(this, "getAxes");
            h(c2, function(a3, b3) {
              a3.index = b3;
              a3.isX = true;
            });
            h(b2, function(a3, b3) {
              a3.index = b3;
            });
            c2 = c2.concat(b2);
            h(c2, function(b3) {
              new e(a2, b3);
            });
            q(this, "afterGetAxes");
          },
          getSelectedPoints: function() {
            var a2 = [];
            h(this.series, function(b2) {
              a2 = a2.concat(d(b2.data || [], function(a3) {
                return a3.selected;
              }));
            });
            return a2;
          },
          getSelectedSeries: function() {
            return d(this.series, function(a2) {
              return a2.selected;
            });
          },
          setTitle: function(a2, b2, c2) {
            var d2 = this, g2 = d2.options, m2;
            m2 = g2.title = B({ style: { color: "#333333", fontSize: g2.isStock ? "16px" : "18px" } }, g2.title, a2);
            g2 = g2.subtitle = B({ style: { color: "#666666" } }, g2.subtitle, b2);
            h([["title", a2, m2], ["subtitle", b2, g2]], function(a3, b3) {
              var c3 = a3[0], g3 = d2[c3], m3 = a3[1];
              a3 = a3[2];
              g3 && m3 && (d2[c3] = g3 = g3.destroy());
              a3 && !g3 && (d2[c3] = d2.renderer.text(a3.text, 0, 0, a3.useHTML).attr({ align: a3.align, "class": "highcharts-" + c3, zIndex: a3.zIndex || 4 }).add(), d2[c3].update = function(a4) {
                d2.setTitle(!b3 && a4, b3 && a4);
              }, d2[c3].css(a3.style));
            });
            d2.layOutTitles(c2);
          },
          layOutTitles: function(a2) {
            var b2 = 0, c2, d2 = this.renderer, g2 = this.spacingBox;
            h(["title", "subtitle"], function(a3) {
              var c3 = this[a3], m2 = this.options[a3];
              a3 = "title" === a3 ? -3 : m2.verticalAlign ? 0 : b2 + 2;
              var h2;
              c3 && (h2 = m2.style.fontSize, h2 = d2.fontMetrics(h2, c3).b, c3.css({ width: (m2.width || g2.width + m2.widthAdjust) + "px" }).align(p({ y: a3 + h2 }, m2), false, "spacingBox"), m2.floating || m2.verticalAlign || (b2 = Math.ceil(b2 + c3.getBBox(m2.useHTML).height)));
            }, this);
            c2 = this.titleOffset !== b2;
            this.titleOffset = b2;
            !this.isDirtyBox && c2 && (this.isDirtyBox = this.isDirtyLegend = c2, this.hasRendered && G(a2, true) && this.isDirtyBox && this.redraw());
          },
          getChartSize: function() {
            var b2 = this.options.chart, d2 = b2.width, b2 = b2.height, g2 = this.renderTo;
            c(d2) || (this.containerWidth = a.getStyle(g2, "width"));
            c(b2) || (this.containerHeight = a.getStyle(g2, "height"));
            this.chartWidth = Math.max(0, d2 || this.containerWidth || 600);
            this.chartHeight = Math.max(0, a.relativeLength(b2, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
          },
          temporaryDisplay: function(b2) {
            var c2 = this.renderTo;
            if (b2)
              for (; c2 && c2.style; )
                c2.hcOrigStyle && (a.css(c2, c2.hcOrigStyle), delete c2.hcOrigStyle), c2.hcOrigDetached && (f.body.removeChild(c2), c2.hcOrigDetached = false), c2 = c2.parentNode;
            else
              for (; c2 && c2.style; ) {
                f.body.contains(c2) || c2.parentNode || (c2.hcOrigDetached = true, f.body.appendChild(c2));
                if ("none" === a.getStyle(c2, "display", false) || c2.hcOricDetached)
                  c2.hcOrigStyle = { display: c2.style.display, height: c2.style.height, overflow: c2.style.overflow }, b2 = { display: "block", overflow: "hidden" }, c2 !== this.renderTo && (b2.height = 0), a.css(c2, b2), c2.offsetWidth || c2.style.setProperty("display", "block", "important");
                c2 = c2.parentNode;
                if (c2 === f.body)
                  break;
              }
          },
          setClassName: function(a2) {
            this.container.className = "highcharts-container " + (a2 || "");
          },
          getContainer: function() {
            var c2, d2 = this.options, g2 = d2.chart, m2, h2;
            c2 = this.renderTo;
            var e2 = a.uniqueKey(), l2;
            c2 || (this.renderTo = c2 = g2.renderTo);
            J(c2) && (this.renderTo = c2 = f.getElementById(c2));
            c2 || a.error(13, true);
            m2 = A(n(c2, "data-highcharts-chart"));
            b(m2) && w[m2] && w[m2].hasRendered && w[m2].destroy();
            n(
              c2,
              "data-highcharts-chart",
              this.index
            );
            c2.innerHTML = "";
            g2.skipClone || c2.offsetWidth || this.temporaryDisplay();
            this.getChartSize();
            m2 = this.chartWidth;
            h2 = this.chartHeight;
            l2 = p({ position: "relative", overflow: "hidden", width: m2 + "px", height: h2 + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }, g2.style);
            this.container = c2 = u("div", { id: e2 }, l2, c2);
            this._cursor = c2.style.cursor;
            this.renderer = new (a[g2.renderer] || a.Renderer)(c2, m2, h2, null, g2.forExport, d2.exporting && d2.exporting.allowHTML);
            this.setClassName(g2.className);
            this.renderer.setStyle(g2.style);
            this.renderer.chartIndex = this.index;
            q(this, "afterGetContainer");
          },
          getMargins: function(a2) {
            var b2 = this.spacing, d2 = this.margin, g2 = this.titleOffset;
            this.resetMargins();
            g2 && !c(d2[0]) && (this.plotTop = Math.max(this.plotTop, g2 + this.options.title.margin + b2[0]));
            this.legend && this.legend.display && this.legend.adjustMargins(d2, b2);
            q(this, "getMargins");
            a2 || this.getAxisMargins();
          },
          getAxisMargins: function() {
            var a2 = this, b2 = a2.axisOffset = [0, 0, 0, 0], d2 = a2.margin;
            a2.hasCartesianSeries && h(a2.axes, function(a3) {
              a3.visible && a3.getOffset();
            });
            h(L, function(g2, m2) {
              c(d2[m2]) || (a2[g2] += b2[m2]);
            });
            a2.setChartSize();
          },
          reflow: function(b2) {
            var d2 = this, g2 = d2.options.chart, m2 = d2.renderTo, h2 = c(g2.width) && c(g2.height), e2 = g2.width || a.getStyle(m2, "width"), g2 = g2.height || a.getStyle(m2, "height"), m2 = b2 ? b2.target : M;
            if (!h2 && !d2.isPrinting && e2 && g2 && (m2 === M || m2 === f)) {
              if (e2 !== d2.containerWidth || g2 !== d2.containerHeight)
                a.clearTimeout(d2.reflowTimeout), d2.reflowTimeout = r(function() {
                  d2.container && d2.setSize(void 0, void 0, false);
                }, b2 ? 100 : 0);
              d2.containerWidth = e2;
              d2.containerHeight = g2;
            }
          },
          setReflow: function(a2) {
            var b2 = this;
            false === a2 || this.unbindReflow ? false === a2 && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = C(M, "resize", function(a3) {
              b2.reflow(a3);
            }), C(this, "destroy", this.unbindReflow));
          },
          setSize: function(b2, c2, d2) {
            var g2 = this, m2 = g2.renderer;
            g2.isResizing += 1;
            a.setAnimation(d2, g2);
            g2.oldChartHeight = g2.chartHeight;
            g2.oldChartWidth = g2.chartWidth;
            void 0 !== b2 && (g2.options.chart.width = b2);
            void 0 !== c2 && (g2.options.chart.height = c2);
            g2.getChartSize();
            b2 = m2.globalAnimation;
            (b2 ? F : y)(g2.container, { width: g2.chartWidth + "px", height: g2.chartHeight + "px" }, b2);
            g2.setChartSize(true);
            m2.setSize(g2.chartWidth, g2.chartHeight, d2);
            h(g2.axes, function(a2) {
              a2.isDirty = true;
              a2.setScale();
            });
            g2.isDirtyLegend = true;
            g2.isDirtyBox = true;
            g2.layOutTitles();
            g2.getMargins();
            g2.redraw(d2);
            g2.oldChartHeight = null;
            q(g2, "resize");
            r(function() {
              g2 && q(g2, "endResize", null, function() {
                --g2.isResizing;
              });
            }, I(b2).duration);
          },
          setChartSize: function(a2) {
            var b2 = this.inverted, c2 = this.renderer, g2 = this.chartWidth, d2 = this.chartHeight, m2 = this.options.chart, e2 = this.spacing, l2 = this.clipOffset, f2, A2, k2, r2;
            this.plotLeft = f2 = Math.round(this.plotLeft);
            this.plotTop = A2 = Math.round(this.plotTop);
            this.plotWidth = k2 = Math.max(0, Math.round(g2 - f2 - this.marginRight));
            this.plotHeight = r2 = Math.max(0, Math.round(d2 - A2 - this.marginBottom));
            this.plotSizeX = b2 ? r2 : k2;
            this.plotSizeY = b2 ? k2 : r2;
            this.plotBorderWidth = m2.plotBorderWidth || 0;
            this.spacingBox = c2.spacingBox = { x: e2[3], y: e2[0], width: g2 - e2[3] - e2[1], height: d2 - e2[0] - e2[2] };
            this.plotBox = c2.plotBox = { x: f2, y: A2, width: k2, height: r2 };
            g2 = 2 * Math.floor(this.plotBorderWidth / 2);
            b2 = Math.ceil(Math.max(g2, l2[3]) / 2);
            c2 = Math.ceil(Math.max(g2, l2[0]) / 2);
            this.clipBox = {
              x: b2,
              y: c2,
              width: Math.floor(this.plotSizeX - Math.max(g2, l2[1]) / 2 - b2),
              height: Math.max(0, Math.floor(this.plotSizeY - Math.max(g2, l2[2]) / 2 - c2))
            };
            a2 || h(this.axes, function(a3) {
              a3.setAxisSize();
              a3.setAxisTranslation();
            });
            q(this, "afterSetChartSize", { skipAxes: a2 });
          },
          resetMargins: function() {
            var a2 = this, b2 = a2.options.chart;
            h(["margin", "spacing"], function(c2) {
              var g2 = b2[c2], d2 = v(g2) ? g2 : [g2, g2, g2, g2];
              h(["Top", "Right", "Bottom", "Left"], function(g3, m2) {
                a2[c2][m2] = G(b2[c2 + g3], d2[m2]);
              });
            });
            h(L, function(b3, c2) {
              a2[b3] = G(a2.margin[c2], a2.spacing[c2]);
            });
            a2.axisOffset = [
              0,
              0,
              0,
              0
            ];
            a2.clipOffset = [0, 0, 0, 0];
          },
          drawChartBox: function() {
            var a2 = this.options.chart, b2 = this.renderer, c2 = this.chartWidth, g2 = this.chartHeight, d2 = this.chartBackground, m2 = this.plotBackground, h2 = this.plotBorder, e2, l2 = this.plotBGImage, f2 = a2.backgroundColor, A2 = a2.plotBackgroundColor, k2 = a2.plotBackgroundImage, r2, p2 = this.plotLeft, G2 = this.plotTop, v2 = this.plotWidth, E2 = this.plotHeight, n2 = this.plotBox, B2 = this.clipRect, t2 = this.clipBox, u2 = "animate";
            d2 || (this.chartBackground = d2 = b2.rect().addClass("highcharts-background").add(), u2 = "attr");
            e2 = a2.borderWidth || 0;
            r2 = e2 + (a2.shadow ? 8 : 0);
            f2 = { fill: f2 || "none" };
            if (e2 || d2["stroke-width"])
              f2.stroke = a2.borderColor, f2["stroke-width"] = e2;
            d2.attr(f2).shadow(a2.shadow);
            d2[u2]({ x: r2 / 2, y: r2 / 2, width: c2 - r2 - e2 % 2, height: g2 - r2 - e2 % 2, r: a2.borderRadius });
            u2 = "animate";
            m2 || (u2 = "attr", this.plotBackground = m2 = b2.rect().addClass("highcharts-plot-background").add());
            m2[u2](n2);
            m2.attr({ fill: A2 || "none" }).shadow(a2.plotShadow);
            k2 && (l2 ? l2.animate(n2) : this.plotBGImage = b2.image(k2, p2, G2, v2, E2).add());
            B2 ? B2.animate({ width: t2.width, height: t2.height }) : this.clipRect = b2.clipRect(t2);
            u2 = "animate";
            h2 || (u2 = "attr", this.plotBorder = h2 = b2.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add());
            h2.attr({ stroke: a2.plotBorderColor, "stroke-width": a2.plotBorderWidth || 0, fill: "none" });
            h2[u2](h2.crisp({ x: p2, y: G2, width: v2, height: E2 }, -h2.strokeWidth()));
            this.isDirtyBox = false;
            q(this, "afterDrawChartBox");
          },
          propFromSeries: function() {
            var a2 = this, b2 = a2.options.chart, c2, g2 = a2.options.series, d2, m2;
            h(["inverted", "angular", "polar"], function(h2) {
              c2 = E[b2.type || b2.defaultSeriesType];
              m2 = b2[h2] || c2 && c2.prototype[h2];
              for (d2 = g2 && g2.length; !m2 && d2--; )
                (c2 = E[g2[d2].type]) && c2.prototype[h2] && (m2 = true);
              a2[h2] = m2;
            });
          },
          linkSeries: function() {
            var a2 = this, b2 = a2.series;
            h(b2, function(a3) {
              a3.linkedSeries.length = 0;
            });
            h(b2, function(b3) {
              var c2 = b3.options.linkedTo;
              J(c2) && (c2 = ":previous" === c2 ? a2.series[b3.index - 1] : a2.get(c2)) && c2.linkedParent !== b3 && (c2.linkedSeries.push(b3), b3.linkedParent = c2, b3.visible = G(b3.options.visible, c2.options.visible, b3.visible));
            });
            q(this, "afterLinkSeries");
          },
          renderSeries: function() {
            h(this.series, function(a2) {
              a2.translate();
              a2.render();
            });
          },
          renderLabels: function() {
            var a2 = this, b2 = a2.options.labels;
            b2.items && h(b2.items, function(c2) {
              var g2 = p(b2.style, c2.style), d2 = A(g2.left) + a2.plotLeft, m2 = A(g2.top) + a2.plotTop + 12;
              delete g2.left;
              delete g2.top;
              a2.renderer.text(c2.html, d2, m2).attr({ zIndex: 2 }).css(g2).add();
            });
          },
          render: function() {
            var a2 = this.axes, b2 = this.renderer, c2 = this.options, g2, d2, m2;
            this.setTitle();
            this.legend = new l(this, c2.legend);
            this.getStacks && this.getStacks();
            this.getMargins(true);
            this.setChartSize();
            c2 = this.plotWidth;
            g2 = this.plotHeight = Math.max(this.plotHeight - 21, 0);
            h(a2, function(a3) {
              a3.setScale();
            });
            this.getAxisMargins();
            d2 = 1.1 < c2 / this.plotWidth;
            m2 = 1.05 < g2 / this.plotHeight;
            if (d2 || m2)
              h(a2, function(a3) {
                (a3.horiz && d2 || !a3.horiz && m2) && a3.setTickInterval(true);
              }), this.getMargins();
            this.drawChartBox();
            this.hasCartesianSeries && h(a2, function(a3) {
              a3.visible && a3.render();
            });
            this.seriesGroup || (this.seriesGroup = b2.g("series-group").attr({ zIndex: 3 }).add());
            this.renderSeries();
            this.renderLabels();
            this.addCredits();
            this.setResponsive && this.setResponsive();
            this.hasRendered = true;
          },
          addCredits: function(a2) {
            var b2 = this;
            a2 = B(true, this.options.credits, a2);
            a2.enabled && !this.credits && (this.credits = this.renderer.text(a2.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
              a2.href && (M.location.href = a2.href);
            }).attr({ align: a2.position.align, zIndex: 8 }).css(a2.style).add().align(a2.position), this.credits.update = function(a3) {
              b2.credits = b2.credits.destroy();
              b2.addCredits(a3);
            });
          },
          destroy: function() {
            var b2 = this, c2 = b2.axes, g2 = b2.series, d2 = b2.container, m2, e2 = d2 && d2.parentNode;
            q(b2, "destroy");
            b2.renderer.forExport ? a.erase(w, b2) : w[b2.index] = void 0;
            a.chartCount--;
            b2.renderTo.removeAttribute("data-highcharts-chart");
            N(b2);
            for (m2 = c2.length; m2--; )
              c2[m2] = c2[m2].destroy();
            this.scroller && this.scroller.destroy && this.scroller.destroy();
            for (m2 = g2.length; m2--; )
              g2[m2] = g2[m2].destroy();
            h("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "), function(a2) {
              var c3 = b2[a2];
              c3 && c3.destroy && (b2[a2] = c3.destroy());
            });
            d2 && (d2.innerHTML = "", N(d2), e2 && t(d2));
            D(b2, function(a2, c3) {
              delete b2[c3];
            });
          },
          firstRender: function() {
            var a2 = this, b2 = a2.options;
            if (!a2.isReadyToRender || a2.isReadyToRender()) {
              a2.getContainer();
              a2.resetMargins();
              a2.setChartSize();
              a2.propFromSeries();
              a2.getAxes();
              h(b2.series || [], function(b3) {
                a2.initSeries(b3);
              });
              a2.linkSeries();
              q(a2, "beforeRender");
              m && (a2.pointer = new m(a2, b2));
              a2.render();
              if (!a2.renderer.imgCount && a2.onload)
                a2.onload();
              a2.temporaryDisplay(true);
            }
          },
          onload: function() {
            h([this.callback].concat(this.callbacks), function(a2) {
              a2 && void 0 !== this.index && a2.apply(this, [this]);
            }, this);
            q(this, "load");
            q(this, "render");
            c(this.index) && this.setReflow(this.options.chart.reflow);
            this.onload = null;
          }
        });
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.Chart, I = a.each;
        C(F, "afterSetChartSize", function(n) {
          var f = this.options.chart.scrollablePlotArea;
          (f = f && f.minWidth) && !this.renderer.forExport && (this.scrollablePixels = f = Math.max(0, f - this.chartWidth)) && (this.plotWidth += f, this.clipBox.width += f, n.skipAxes || I(this.axes, function(e) {
            1 === e.side ? e.getPlotLinePath = function() {
              var f2 = this.right, n2;
              this.right = f2 - e.chart.scrollablePixels;
              n2 = a.Axis.prototype.getPlotLinePath.apply(this, arguments);
              this.right = f2;
              return n2;
            } : (e.setAxisSize(), e.setAxisTranslation());
          }));
        });
        C(F, "render", function() {
          this.scrollablePixels ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
        });
        F.prototype.setUpScrolling = function() {
          this.scrollingContainer = a.createElement("div", { className: "highcharts-scrolling" }, { overflowX: "auto", WebkitOverflowScrolling: "touch" }, this.renderTo);
          this.innerContainer = a.createElement("div", { className: "highcharts-inner-container" }, null, this.scrollingContainer);
          this.innerContainer.appendChild(this.container);
          this.setUpScrolling = null;
        };
        F.prototype.applyFixed = function() {
          var n = this.container, f, e, u = !this.fixedDiv;
          u && (this.fixedDiv = a.createElement("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: 2 }, null, true), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.fixedRenderer = f = new a.Renderer(this.fixedDiv, 0, 0), this.scrollableMask = f.path().attr({ fill: a.color(this.options.chart.backgroundColor || "#fff").setOpacity(0.85).get(), zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), a.each([this.inverted ? ".highcharts-xaxis" : ".highcharts-yaxis", this.inverted ? ".highcharts-xaxis-labels" : ".highcharts-yaxis-labels", ".highcharts-contextbutton", ".highcharts-credits", ".highcharts-legend", ".highcharts-subtitle", ".highcharts-title", ".highcharts-legend-checkbox"], function(e2) {
            a.each(n.querySelectorAll(e2), function(a2) {
              (a2.namespaceURI === f.SVG_NS ? f.box : f.box.parentNode).appendChild(a2);
              a2.style.pointerEvents = "auto";
            });
          }));
          this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
          e = this.chartWidth + this.scrollablePixels;
          a.stop(this.container);
          this.container.style.width = e + "px";
          this.renderer.boxWrapper.attr({ width: e, height: this.chartHeight, viewBox: [0, 0, e, this.chartHeight].join(" ") });
          this.chartBackground.attr({ width: e });
          u && (e = this.options.chart.scrollablePlotArea, e.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixels * e.scrollPositionX));
          u = this.axisOffset;
          e = this.plotTop - u[0] - 1;
          var u = this.plotTop + this.plotHeight + u[2], x = this.plotLeft + this.plotWidth - this.scrollablePixels;
          this.scrollableMask.attr({ d: this.scrollablePixels ? ["M", 0, e, "L", this.plotLeft - 1, e, "L", this.plotLeft - 1, u, "L", 0, u, "Z", "M", x, e, "L", this.chartWidth, e, "L", this.chartWidth, u, "L", x, u, "Z"] : ["M", 0, 0] });
        };
      })(K);
      (function(a) {
        var C, F = a.each, I = a.extend, n = a.erase, f = a.fireEvent, e = a.format, u = a.isArray, x = a.isNumber, t = a.pick, w = a.uniqueKey, y = a.defined, c = a.removeEvent;
        a.Point = C = function() {
        };
        a.Point.prototype = {
          init: function(a2, c2, e2) {
            this.series = a2;
            this.color = a2.color;
            this.applyOptions(c2, e2);
            this.id = y(this.id) ? this.id : w();
            a2.options.colorByPoint ? (c2 = a2.options.colors || a2.chart.options.colors, this.color = this.color || c2[a2.colorCounter], c2 = c2.length, e2 = a2.colorCounter, a2.colorCounter++, a2.colorCounter === c2 && (a2.colorCounter = 0)) : e2 = a2.colorIndex;
            this.colorIndex = t(this.colorIndex, e2);
            a2.chart.pointCount++;
            f(this, "afterInit");
            return this;
          },
          applyOptions: function(a2, c2) {
            var e2 = this.series, h = e2.options.pointValKey || e2.pointValKey;
            a2 = C.prototype.optionsToObject.call(this, a2);
            I(this, a2);
            this.options = this.options ? I(this.options, a2) : a2;
            a2.group && delete this.group;
            a2.dataLabels && delete this.dataLabels;
            h && (this.y = this[h]);
            this.isNull = t(this.isValid && !this.isValid(), null === this.x || !x(this.y, true));
            this.selected && (this.state = "select");
            "name" in this && void 0 === c2 && e2.xAxis && e2.xAxis.hasNames && (this.x = e2.xAxis.nameToX(this));
            void 0 === this.x && e2 && (this.x = void 0 === c2 ? e2.autoIncrement(this) : c2);
            return this;
          },
          setNestedProperty: function(c2, e2, f2) {
            f2 = f2.split(".");
            a.reduce(f2, function(c3, d, b, h) {
              c3[d] = h.length - 1 === b ? e2 : a.isObject(c3[d], true) ? c3[d] : {};
              return c3[d];
            }, c2);
            return c2;
          },
          optionsToObject: function(c2) {
            var e2 = {}, h = this.series, f2 = h.options.keys, d = f2 || h.pointArrayMap || ["y"], b = d.length, v = 0, n2 = 0;
            if (x(c2) || null === c2)
              e2[d[0]] = c2;
            else if (u(c2))
              for (!f2 && c2.length > b && (h = typeof c2[0], "string" === h ? e2.name = c2[0] : "number" === h && (e2.x = c2[0]), v++); n2 < b; )
                f2 && void 0 === c2[v] || (0 < d[n2].indexOf(".") ? a.Point.prototype.setNestedProperty(e2, c2[v], d[n2]) : e2[d[n2]] = c2[v]), v++, n2++;
            else
              "object" === typeof c2 && (e2 = c2, c2.dataLabels && (h._hasPointLabels = true), c2.marker && (h._hasPointMarkers = true));
            return e2;
          },
          getClassName: function() {
            return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
          },
          getZone: function() {
            var a2 = this.series, c2 = a2.zones, a2 = a2.zoneAxis || "y", e2 = 0, f2;
            for (f2 = c2[e2]; this[a2] >= f2.value; )
              f2 = c2[++e2];
            this.nonZonedColor || (this.nonZonedColor = this.color);
            this.color = f2 && f2.color && !this.options.color ? f2.color : this.nonZonedColor;
            return f2;
          },
          destroy: function() {
            var a2 = this.series.chart, e2 = a2.hoverPoints, f2;
            a2.pointCount--;
            e2 && (this.setState(), n(e2, this), e2.length || (a2.hoverPoints = null));
            if (this === a2.hoverPoint)
              this.onMouseOut();
            if (this.graphic || this.dataLabel || this.dataLabels)
              c(this), this.destroyElements();
            this.legendItem && a2.legend.destroyItem(this);
            for (f2 in this)
              this[f2] = null;
          },
          destroyElements: function() {
            for (var a2 = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"], c2, e2 = 6; e2--; )
              c2 = a2[e2], this[c2] && (this[c2] = this[c2].destroy());
            this.dataLabels && (F(this.dataLabels, function(a3) {
              a3.element && a3.destroy();
            }), delete this.dataLabels);
            this.connectors && (F(this.connectors, function(a3) {
              a3.element && a3.destroy();
            }), delete this.connectors);
          },
          getLabelConfig: function() {
            return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };
          },
          tooltipFormatter: function(a2) {
            var c2 = this.series, h = c2.tooltipOptions, f2 = t(h.valueDecimals, ""), d = h.valuePrefix || "", b = h.valueSuffix || "";
            F(c2.pointArrayMap || ["y"], function(c3) {
              c3 = "{point." + c3;
              if (d || b)
                a2 = a2.replace(RegExp(c3 + "}", "g"), d + c3 + "}" + b);
              a2 = a2.replace(RegExp(c3 + "}", "g"), c3 + ":,." + f2 + "f}");
            });
            return e(a2, { point: this, series: this.series }, c2.chart.time);
          },
          firePointEvent: function(a2, c2, e2) {
            var h = this, d = this.series.options;
            (d.point.events[a2] || h.options && h.options.events && h.options.events[a2]) && this.importEvents();
            "click" === a2 && d.allowPointSelect && (e2 = function(a3) {
              h.select && h.select(null, a3.ctrlKey || a3.metaKey || a3.shiftKey);
            });
            f(
              this,
              a2,
              c2,
              e2
            );
          },
          visible: true
        };
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.animObject, I = a.arrayMax, n = a.arrayMin, f = a.correctFloat, e = a.defaultOptions, u = a.defaultPlotOptions, x = a.defined, t = a.each, w = a.erase, y = a.extend, c = a.fireEvent, h = a.grep, p = a.isArray, k = a.isNumber, q = a.isString, d = a.merge, b = a.objectEach, v = a.pick, J = a.removeEvent, l = a.splat, L = a.SVGElement, B = a.syncTimeout, D = a.win;
        a.Series = a.seriesType("line", null, { lineWidth: 2, allowPointSelect: false, showCheckbox: false, animation: { duration: 1e3 }, events: {}, marker: {
          lineWidth: 0,
          lineColor: "#ffffff",
          enabledThreshold: 2,
          radius: 4,
          states: { normal: { animation: true }, hover: { animation: { duration: 50 }, enabled: true, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } }
        }, point: { events: {} }, dataLabels: { align: "center", formatter: function() {
          return null === this.y ? "" : a.numberFormat(this.y, -1);
        }, style: { fontSize: "11px", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0, padding: 5 }, cropThreshold: 300, pointRange: 0, softThreshold: true, states: {
          normal: { animation: true },
          hover: { animation: { duration: 50 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } },
          select: {}
        }, stickyTracking: true, turboThreshold: 1e3, findNearestPointBy: "x" }, {
          isCartesian: true,
          pointClass: a.Point,
          sorted: true,
          requireSorting: true,
          directTouch: false,
          axisTypes: ["xAxis", "yAxis"],
          colorCounter: 0,
          parallelArrays: ["x", "y"],
          coll: "series",
          init: function(a2, d2) {
            var m = this, e2, h2 = a2.series, g;
            m.chart = a2;
            m.options = d2 = m.setOptions(d2);
            m.linkedSeries = [];
            m.bindAxes();
            y(m, { name: d2.name, state: "", visible: false !== d2.visible, selected: true === d2.selected });
            e2 = d2.events;
            b(e2, function(a3, b2) {
              C(m, b2, a3);
            });
            if (e2 && e2.click || d2.point && d2.point.events && d2.point.events.click || d2.allowPointSelect)
              a2.runTrackerClick = true;
            m.getColor();
            m.getSymbol();
            t(m.parallelArrays, function(a3) {
              m[a3 + "Data"] = [];
            });
            m.setData(d2.data, false);
            m.isCartesian && (a2.hasCartesianSeries = true);
            h2.length && (g = h2[h2.length - 1]);
            m._i = v(g && g._i, -1) + 1;
            a2.orderSeries(this.insert(h2));
            c(this, "afterInit");
          },
          insert: function(a2) {
            var b2 = this.options.index, c2;
            if (k(b2)) {
              for (c2 = a2.length; c2--; )
                if (b2 >= v(a2[c2].options.index, a2[c2]._i)) {
                  a2.splice(c2 + 1, 0, this);
                  break;
                }
              -1 === c2 && a2.unshift(this);
              c2 += 1;
            } else
              a2.push(this);
            return v(c2, a2.length - 1);
          },
          bindAxes: function() {
            var b2 = this, c2 = b2.options, d2 = b2.chart, e2;
            t(b2.axisTypes || [], function(m) {
              t(d2[m], function(a2) {
                e2 = a2.options;
                if (c2[m] === e2.index || void 0 !== c2[m] && c2[m] === e2.id || void 0 === c2[m] && 0 === e2.index)
                  b2.insert(a2.series), b2[m] = a2, a2.isDirty = true;
              });
              b2[m] || b2.optionalAxis === m || a.error(18, true);
            });
          },
          updateParallelArrays: function(a2, b2) {
            var c2 = a2.series, d2 = arguments, m = k(b2) ? function(g) {
              var d3 = "y" === g && c2.toYData ? c2.toYData(a2) : a2[g];
              c2[g + "Data"][b2] = d3;
            } : function(a3) {
              Array.prototype[b2].apply(c2[a3 + "Data"], Array.prototype.slice.call(d2, 2));
            };
            t(c2.parallelArrays, m);
          },
          autoIncrement: function() {
            var a2 = this.options, b2 = this.xIncrement, c2, d2 = a2.pointIntervalUnit, e2 = this.chart.time, b2 = v(b2, a2.pointStart, 0);
            this.pointInterval = c2 = v(this.pointInterval, a2.pointInterval, 1);
            d2 && (a2 = new e2.Date(b2), "day" === d2 ? e2.set("Date", a2, e2.get("Date", a2) + c2) : "month" === d2 ? e2.set("Month", a2, e2.get("Month", a2) + c2) : "year" === d2 && e2.set("FullYear", a2, e2.get("FullYear", a2) + c2), c2 = a2.getTime() - b2);
            this.xIncrement = b2 + c2;
            return b2;
          },
          setOptions: function(a2) {
            var b2 = this.chart, m = b2.options, h2 = m.plotOptions, f2 = (b2.userOptions || {}).plotOptions || {}, g = h2[this.type];
            this.userOptions = a2;
            b2 = d(g, h2.series, a2);
            this.tooltipOptions = d(e.tooltip, e.plotOptions.series && e.plotOptions.series.tooltip, e.plotOptions[this.type].tooltip, m.tooltip.userOptions, h2.series && h2.series.tooltip, h2[this.type].tooltip, a2.tooltip);
            this.stickyTracking = v(a2.stickyTracking, f2[this.type] && f2[this.type].stickyTracking, f2.series && f2.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : b2.stickyTracking);
            null === g.marker && delete b2.marker;
            this.zoneAxis = b2.zoneAxis;
            a2 = this.zones = (b2.zones || []).slice();
            !b2.negativeColor && !b2.negativeFillColor || b2.zones || a2.push({ value: b2[this.zoneAxis + "Threshold"] || b2.threshold || 0, className: "highcharts-negative", color: b2.negativeColor, fillColor: b2.negativeFillColor });
            a2.length && x(a2[a2.length - 1].value) && a2.push({ color: this.color, fillColor: this.fillColor });
            c(this, "afterSetOptions", { options: b2 });
            return b2;
          },
          getName: function() {
            return this.name || "Series " + (this.index + 1);
          },
          getCyclic: function(a2, b2, c2) {
            var d2, e2 = this.chart, g = this.userOptions, m = a2 + "Index", h2 = a2 + "Counter", f2 = c2 ? c2.length : v(e2.options.chart[a2 + "Count"], e2[a2 + "Count"]);
            b2 || (d2 = v(g[m], g["_" + m]), x(d2) || (e2.series.length || (e2[h2] = 0), g["_" + m] = d2 = e2[h2] % f2, e2[h2] += 1), c2 && (b2 = c2[d2]));
            void 0 !== d2 && (this[m] = d2);
            this[a2] = b2;
          },
          getColor: function() {
            this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || u[this.type].color, this.chart.options.colors);
          },
          getSymbol: function() {
            this.getCyclic(
              "symbol",
              this.options.marker.symbol,
              this.chart.options.symbols
            );
          },
          drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,
          updateData: function(b2) {
            var c2 = this.options, d2 = this.points, e2 = [], m, g, h2, f2 = this.requireSorting;
            t(b2, function(b3) {
              var g2;
              g2 = a.defined(b3) && this.pointClass.prototype.optionsToObject.call({ series: this }, b3).x;
              k(g2) && (g2 = a.inArray(g2, this.xData, h2), -1 === g2 || d2[g2].touched ? e2.push(b3) : b3 !== c2.data[g2] ? (d2[g2].update(b3, false, null, false), d2[g2].touched = true, f2 && (h2 = g2 + 1)) : d2[g2] && (d2[g2].touched = true), m = true);
            }, this);
            if (m)
              for (b2 = d2.length; b2--; )
                g = d2[b2], g.touched || g.remove(false), g.touched = false;
            else if (b2.length === d2.length)
              t(b2, function(a2, b3) {
                d2[b3].update && a2 !== c2.data[b3] && d2[b3].update(a2, false, null, false);
              });
            else
              return false;
            t(e2, function(a2) {
              this.addPoint(a2, false);
            }, this);
            return true;
          },
          setData: function(b2, c2, d2, e2) {
            var m = this, g = m.points, h2 = g && g.length || 0, f2, l2 = m.options, A = m.chart, G = null, n2 = m.xAxis, B2 = l2.turboThreshold, u2 = this.xData, D2 = this.yData, y2 = (f2 = m.pointArrayMap) && f2.length, N;
            b2 = b2 || [];
            f2 = b2.length;
            c2 = v(c2, true);
            false !== e2 && f2 && h2 && !m.cropped && !m.hasGroupedData && m.visible && !m.isSeriesBoosting && (N = this.updateData(b2));
            if (!N) {
              m.xIncrement = null;
              m.colorCounter = 0;
              t(this.parallelArrays, function(a2) {
                m[a2 + "Data"].length = 0;
              });
              if (B2 && f2 > B2) {
                for (d2 = 0; null === G && d2 < f2; )
                  G = b2[d2], d2++;
                if (k(G))
                  for (d2 = 0; d2 < f2; d2++)
                    u2[d2] = this.autoIncrement(), D2[d2] = b2[d2];
                else if (p(G))
                  if (y2)
                    for (d2 = 0; d2 < f2; d2++)
                      G = b2[d2], u2[d2] = G[0], D2[d2] = G.slice(1, y2 + 1);
                  else
                    for (d2 = 0; d2 < f2; d2++)
                      G = b2[d2], u2[d2] = G[0], D2[d2] = G[1];
                else
                  a.error(12);
              } else
                for (d2 = 0; d2 < f2; d2++)
                  void 0 !== b2[d2] && (G = { series: m }, m.pointClass.prototype.applyOptions.apply(G, [b2[d2]]), m.updateParallelArrays(G, d2));
              D2 && q(D2[0]) && a.error(14, true);
              m.data = [];
              m.options.data = m.userOptions.data = b2;
              for (d2 = h2; d2--; )
                g[d2] && g[d2].destroy && g[d2].destroy();
              n2 && (n2.minRange = n2.userMinRange);
              m.isDirty = A.isDirtyBox = true;
              m.isDirtyData = !!g;
              d2 = false;
            }
            "point" === l2.legendType && (this.processData(), this.generatePoints());
            c2 && A.redraw(d2);
          },
          processData: function(b2) {
            var c2 = this.xData, d2 = this.yData, e2 = c2.length, m;
            m = 0;
            var g, h2, f2 = this.xAxis, l2, k2 = this.options;
            l2 = k2.cropThreshold;
            var p2 = this.getExtremesFromAll || k2.getExtremesFromAll, q2 = this.isCartesian, k2 = f2 && f2.val2lin, v2 = f2 && f2.isLog, n2 = this.requireSorting, B2, t2;
            if (q2 && !this.isDirty && !f2.isDirty && !this.yAxis.isDirty && !b2)
              return false;
            f2 && (b2 = f2.getExtremes(), B2 = b2.min, t2 = b2.max);
            q2 && this.sorted && !p2 && (!l2 || e2 > l2 || this.forceCrop) && (c2[e2 - 1] < B2 || c2[0] > t2 ? (c2 = [], d2 = []) : this.yData && (c2[0] < B2 || c2[e2 - 1] > t2) && (m = this.cropData(this.xData, this.yData, B2, t2), c2 = m.xData, d2 = m.yData, m = m.start, g = true));
            for (l2 = c2.length || 1; --l2; )
              e2 = v2 ? k2(c2[l2]) - k2(c2[l2 - 1]) : c2[l2] - c2[l2 - 1], 0 < e2 && (void 0 === h2 || e2 < h2) ? h2 = e2 : 0 > e2 && n2 && (a.error(15), n2 = false);
            this.cropped = g;
            this.cropStart = m;
            this.processedXData = c2;
            this.processedYData = d2;
            this.closestPointRange = h2;
          },
          cropData: function(a2, b2, c2, d2, e2) {
            var g = a2.length, m = 0, h2 = g, f2;
            e2 = v(e2, this.cropShoulder, 1);
            for (f2 = 0; f2 < g; f2++)
              if (a2[f2] >= c2) {
                m = Math.max(0, f2 - e2);
                break;
              }
            for (c2 = f2; c2 < g; c2++)
              if (a2[c2] > d2) {
                h2 = c2 + e2;
                break;
              }
            return { xData: a2.slice(m, h2), yData: b2.slice(m, h2), start: m, end: h2 };
          },
          generatePoints: function() {
            var a2 = this.options, b2 = a2.data, c2 = this.data, d2, e2 = this.processedXData, g = this.processedYData, h2 = this.pointClass, f2 = e2.length, k2 = this.cropStart || 0, p2, q2 = this.hasGroupedData, a2 = a2.keys, v2, n2 = [], B2;
            c2 || q2 || (c2 = [], c2.length = b2.length, c2 = this.data = c2);
            a2 && q2 && (this.options.keys = false);
            for (B2 = 0; B2 < f2; B2++)
              p2 = k2 + B2, q2 ? (v2 = new h2().init(this, [e2[B2]].concat(l(g[B2]))), v2.dataGroup = this.groupMap[B2], v2.dataGroup.options && (v2.options = v2.dataGroup.options, y(v2, v2.dataGroup.options))) : (v2 = c2[p2]) || void 0 === b2[p2] || (c2[p2] = v2 = new h2().init(this, b2[p2], e2[B2])), v2 && (v2.index = p2, n2[B2] = v2);
            this.options.keys = a2;
            if (c2 && (f2 !== (d2 = c2.length) || q2))
              for (B2 = 0; B2 < d2; B2++)
                B2 !== k2 || q2 || (B2 += f2), c2[B2] && (c2[B2].destroyElements(), c2[B2].plotX = void 0);
            this.data = c2;
            this.points = n2;
          },
          getExtremes: function(a2) {
            var b2 = this.yAxis, c2 = this.processedXData, d2, e2 = [], g = 0;
            d2 = this.xAxis.getExtremes();
            var m = d2.min, h2 = d2.max, f2, l2, q2 = this.requireSorting ? 1 : 0, v2, B2;
            a2 = a2 || this.stackedYData || this.processedYData || [];
            d2 = a2.length;
            for (B2 = 0; B2 < d2; B2++)
              if (l2 = c2[B2], v2 = a2[B2], f2 = (k(v2, true) || p(v2)) && (!b2.positiveValuesOnly || v2.length || 0 < v2), l2 = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c2[B2 + q2] || l2) >= m && (c2[B2 - q2] || l2) <= h2, f2 && l2)
                if (f2 = v2.length)
                  for (; f2--; )
                    "number" === typeof v2[f2] && (e2[g++] = v2[f2]);
                else
                  e2[g++] = v2;
            this.dataMin = n(e2);
            this.dataMax = I(e2);
          },
          translate: function() {
            this.processedXData || this.processData();
            this.generatePoints();
            var a2 = this.options, b2 = a2.stacking, d2 = this.xAxis, e2 = d2.categories, h2 = this.yAxis, g = this.points, l2 = g.length, p2 = !!this.modifyValue, q2 = a2.pointPlacement, B2 = "between" === q2 || k(q2), n2 = a2.threshold, t2 = a2.startFromThreshold ? n2 : 0, u2, D2, y2, w2, J2 = Number.MAX_VALUE;
            "between" === q2 && (q2 = 0.5);
            k(q2) && (q2 *= v(a2.pointRange || d2.pointRange));
            for (a2 = 0; a2 < l2; a2++) {
              var L2 = g[a2], C2 = L2.x, F2 = L2.y;
              D2 = L2.low;
              var I2 = b2 && h2.stacks[(this.negStacks && F2 < (t2 ? 0 : n2) ? "-" : "") + this.stackKey], K2;
              h2.positiveValuesOnly && null !== F2 && 0 >= F2 && (L2.isNull = true);
              L2.plotX = u2 = f(Math.min(Math.max(-1e5, d2.translate(
                C2,
                0,
                0,
                0,
                1,
                q2,
                "flags" === this.type
              )), 1e5));
              b2 && this.visible && !L2.isNull && I2 && I2[C2] && (w2 = this.getStackIndicator(w2, C2, this.index), K2 = I2[C2], F2 = K2.points[w2.key], D2 = F2[0], F2 = F2[1], D2 === t2 && w2.key === I2[C2].base && (D2 = v(k(n2) && n2, h2.min)), h2.positiveValuesOnly && 0 >= D2 && (D2 = null), L2.total = L2.stackTotal = K2.total, L2.percentage = K2.total && L2.y / K2.total * 100, L2.stackY = F2, K2.setOffset(this.pointXOffset || 0, this.barW || 0));
              L2.yBottom = x(D2) ? Math.min(Math.max(-1e5, h2.translate(D2, 0, 1, 0, 1)), 1e5) : null;
              p2 && (F2 = this.modifyValue(F2, L2));
              L2.plotY = D2 = "number" === typeof F2 && Infinity !== F2 ? Math.min(Math.max(-1e5, h2.translate(F2, 0, 1, 0, 1)), 1e5) : void 0;
              L2.isInside = void 0 !== D2 && 0 <= D2 && D2 <= h2.len && 0 <= u2 && u2 <= d2.len;
              L2.clientX = B2 ? f(d2.translate(C2, 0, 0, 0, 1, q2)) : u2;
              L2.negative = L2.y < (n2 || 0);
              L2.category = e2 && void 0 !== e2[L2.x] ? e2[L2.x] : L2.x;
              L2.isNull || (void 0 !== y2 && (J2 = Math.min(J2, Math.abs(u2 - y2))), y2 = u2);
              L2.zone = this.zones.length && L2.getZone();
            }
            this.closestPointRangePx = J2;
            c(this, "afterTranslate");
          },
          getValidPoints: function(a2, b2) {
            var c2 = this.chart;
            return h(a2 || this.points || [], function(a3) {
              return b2 && !c2.isInsidePlot(a3.plotX, a3.plotY, c2.inverted) ? false : !a3.isNull;
            });
          },
          setClip: function(a2) {
            var b2 = this.chart, c2 = this.options, d2 = b2.renderer, e2 = b2.inverted, g = this.clipBox, m = g || b2.clipBox, h2 = this.sharedClipKey || ["_sharedClip", a2 && a2.duration, a2 && a2.easing, m.height, c2.xAxis, c2.yAxis].join(), f2 = b2[h2], l2 = b2[h2 + "m"];
            f2 || (a2 && (m.width = 0, e2 && (m.x = b2.plotSizeX), b2[h2 + "m"] = l2 = d2.clipRect(e2 ? b2.plotSizeX + 99 : -99, e2 ? -b2.plotLeft : -b2.plotTop, 99, e2 ? b2.chartWidth : b2.chartHeight)), b2[h2] = f2 = d2.clipRect(m), f2.count = { length: 0 });
            a2 && !f2.count[this.index] && (f2.count[this.index] = true, f2.count.length += 1);
            false !== c2.clip && (this.group.clip(a2 || g ? f2 : b2.clipRect), this.markerGroup.clip(l2), this.sharedClipKey = h2);
            a2 || (f2.count[this.index] && (delete f2.count[this.index], --f2.count.length), 0 === f2.count.length && h2 && b2[h2] && (g || (b2[h2] = b2[h2].destroy()), b2[h2 + "m"] && (b2[h2 + "m"] = b2[h2 + "m"].destroy())));
          },
          animate: function(a2) {
            var b2 = this.chart, c2 = F(this.options.animation), d2;
            a2 ? this.setClip(c2) : (d2 = this.sharedClipKey, (a2 = b2[d2]) && a2.animate({ width: b2.plotSizeX, x: 0 }, c2), b2[d2 + "m"] && b2[d2 + "m"].animate({ width: b2.plotSizeX + 99, x: 0 }, c2), this.animate = null);
          },
          afterAnimate: function() {
            this.setClip();
            c(this, "afterAnimate");
            this.finishedAnimating = true;
          },
          drawPoints: function() {
            var a2 = this.points, b2 = this.chart, c2, d2, e2, g, h2 = this.options.marker, f2, l2, k2, p2 = this[this.specialGroup] || this.markerGroup, q2, n2 = v(h2.enabled, this.xAxis.isRadial ? true : null, this.closestPointRangePx >= h2.enabledThreshold * h2.radius);
            if (false !== h2.enabled || this._hasPointMarkers)
              for (c2 = 0; c2 < a2.length; c2++)
                d2 = a2[c2], g = d2.graphic, f2 = d2.marker || {}, l2 = !!d2.marker, e2 = n2 && void 0 === f2.enabled || f2.enabled, k2 = d2.isInside, e2 && !d2.isNull ? (e2 = v(f2.symbol, this.symbol), q2 = this.markerAttribs(
                  d2,
                  d2.selected && "select"
                ), g ? g[k2 ? "show" : "hide"](true).animate(q2) : k2 && (0 < q2.width || d2.hasImage) && (d2.graphic = g = b2.renderer.symbol(e2, q2.x, q2.y, q2.width, q2.height, l2 ? f2 : h2).add(p2)), g && g.attr(this.pointAttribs(d2, d2.selected && "select")), g && g.addClass(d2.getClassName(), true)) : g && (d2.graphic = g.destroy());
          },
          markerAttribs: function(a2, b2) {
            var c2 = this.options.marker, d2 = a2.marker || {}, e2 = d2.symbol || c2.symbol, g = v(d2.radius, c2.radius);
            b2 && (c2 = c2.states[b2], b2 = d2.states && d2.states[b2], g = v(b2 && b2.radius, c2 && c2.radius, g + (c2 && c2.radiusPlus || 0)));
            a2.hasImage = e2 && 0 === e2.indexOf("url");
            a2.hasImage && (g = 0);
            a2 = { x: Math.floor(a2.plotX) - g, y: a2.plotY - g };
            g && (a2.width = a2.height = 2 * g);
            return a2;
          },
          pointAttribs: function(a2, b2) {
            var c2 = this.options.marker, d2 = a2 && a2.options, e2 = d2 && d2.marker || {}, g = this.color, h2 = d2 && d2.color, m = a2 && a2.color, d2 = v(e2.lineWidth, c2.lineWidth);
            a2 = a2 && a2.zone && a2.zone.color;
            g = h2 || a2 || m || g;
            a2 = e2.fillColor || c2.fillColor || g;
            g = e2.lineColor || c2.lineColor || g;
            b2 && (c2 = c2.states[b2], b2 = e2.states && e2.states[b2] || {}, d2 = v(b2.lineWidth, c2.lineWidth, d2 + v(b2.lineWidthPlus, c2.lineWidthPlus, 0)), a2 = b2.fillColor || c2.fillColor || a2, g = b2.lineColor || c2.lineColor || g);
            return { stroke: g, "stroke-width": d2, fill: a2 };
          },
          destroy: function() {
            var d2 = this, e2 = d2.chart, h2 = /AppleWebKit\/533/.test(D.navigator.userAgent), f2, l2, g = d2.data || [], k2, p2;
            c(d2, "destroy");
            J(d2);
            t(d2.axisTypes || [], function(a2) {
              (p2 = d2[a2]) && p2.series && (w(p2.series, d2), p2.isDirty = p2.forceRedraw = true);
            });
            d2.legendItem && d2.chart.legend.destroyItem(d2);
            for (l2 = g.length; l2--; )
              (k2 = g[l2]) && k2.destroy && k2.destroy();
            d2.points = null;
            a.clearTimeout(d2.animationTimeout);
            b(d2, function(a2, b2) {
              a2 instanceof L && !a2.survive && (f2 = h2 && "group" === b2 ? "hide" : "destroy", a2[f2]());
            });
            e2.hoverSeries === d2 && (e2.hoverSeries = null);
            w(e2.series, d2);
            e2.orderSeries();
            b(d2, function(a2, b2) {
              delete d2[b2];
            });
          },
          getGraphPath: function(a2, b2, c2) {
            var d2 = this, e2 = d2.options, g = e2.step, h2, m = [], f2 = [], l2;
            a2 = a2 || d2.points;
            (h2 = a2.reversed) && a2.reverse();
            (g = { right: 1, center: 2 }[g] || g && 3) && h2 && (g = 4 - g);
            !e2.connectNulls || b2 || c2 || (a2 = this.getValidPoints(a2));
            t(a2, function(h3, k2) {
              var r = h3.plotX, p2 = h3.plotY, q2 = a2[k2 - 1];
              (h3.leftCliff || q2 && q2.rightCliff) && !c2 && (l2 = true);
              h3.isNull && !x(b2) && 0 < k2 ? l2 = !e2.connectNulls : h3.isNull && !b2 ? l2 = true : (0 === k2 || l2 ? k2 = ["M", h3.plotX, h3.plotY] : d2.getPointSpline ? k2 = d2.getPointSpline(a2, h3, k2) : g ? (k2 = 1 === g ? ["L", q2.plotX, p2] : 2 === g ? ["L", (q2.plotX + r) / 2, q2.plotY, "L", (q2.plotX + r) / 2, p2] : ["L", r, q2.plotY], k2.push("L", r, p2)) : k2 = ["L", r, p2], f2.push(h3.x), g && (f2.push(h3.x), 2 === g && f2.push(h3.x)), m.push.apply(m, k2), l2 = false);
            });
            m.xMap = f2;
            return d2.graphPath = m;
          },
          drawGraph: function() {
            var a2 = this, b2 = this.options, c2 = (this.gappedPath || this.getGraphPath).call(this), d2 = [["graph", "highcharts-graph", b2.lineColor || this.color, b2.dashStyle]], d2 = a2.getZonesGraphs(d2);
            t(d2, function(d3, g) {
              var e2 = d3[0], h2 = a2[e2];
              h2 ? (h2.endX = a2.preventGraphAnimation ? null : c2.xMap, h2.animate({ d: c2 })) : c2.length && (a2[e2] = a2.chart.renderer.path(c2).addClass(d3[1]).attr({ zIndex: 1 }).add(a2.group), h2 = { stroke: d3[2], "stroke-width": b2.lineWidth, fill: a2.fillGraph && a2.color || "none" }, d3[3] ? h2.dashstyle = d3[3] : "square" !== b2.linecap && (h2["stroke-linecap"] = h2["stroke-linejoin"] = "round"), h2 = a2[e2].attr(h2).shadow(2 > g && b2.shadow));
              h2 && (h2.startX = c2.xMap, h2.isArea = c2.isArea);
            });
          },
          getZonesGraphs: function(a2) {
            t(this.zones, function(b2, c2) {
              a2.push([
                "zone-graph-" + c2,
                "highcharts-graph highcharts-zone-graph-" + c2 + " " + (b2.className || ""),
                b2.color || this.color,
                b2.dashStyle || this.options.dashStyle
              ]);
            }, this);
            return a2;
          },
          applyZones: function() {
            var a2 = this, b2 = this.chart, c2 = b2.renderer, d2 = this.zones, e2, g, h2 = this.clips || [], f2, l2 = this.graph, k2 = this.area, p2 = Math.max(b2.chartWidth, b2.chartHeight), q2 = this[(this.zoneAxis || "y") + "Axis"], n2, B2, u2 = b2.inverted, D2, y2, w2, x2, J2 = false;
            d2.length && (l2 || k2) && q2 && void 0 !== q2.min && (B2 = q2.reversed, D2 = q2.horiz, l2 && !this.showLine && l2.hide(), k2 && k2.hide(), n2 = q2.getExtremes(), t(d2, function(d3, m) {
              e2 = B2 ? D2 ? b2.plotWidth : 0 : D2 ? 0 : q2.toPixels(n2.min);
              e2 = Math.min(Math.max(v(g, e2), 0), p2);
              g = Math.min(Math.max(Math.round(q2.toPixels(v(d3.value, n2.max), true)), 0), p2);
              J2 && (e2 = g = q2.toPixels(n2.max));
              y2 = Math.abs(e2 - g);
              w2 = Math.min(e2, g);
              x2 = Math.max(e2, g);
              q2.isXAxis ? (f2 = { x: u2 ? x2 : w2, y: 0, width: y2, height: p2 }, D2 || (f2.x = b2.plotHeight - f2.x)) : (f2 = { x: 0, y: u2 ? x2 : w2, width: p2, height: y2 }, D2 && (f2.y = b2.plotWidth - f2.y));
              u2 && c2.isVML && (f2 = q2.isXAxis ? { x: 0, y: B2 ? w2 : x2, height: f2.width, width: b2.chartWidth } : { x: f2.y - b2.plotLeft - b2.spacingBox.x, y: 0, width: f2.height, height: b2.chartHeight });
              h2[m] ? h2[m].animate(f2) : (h2[m] = c2.clipRect(f2), l2 && a2["zone-graph-" + m].clip(h2[m]), k2 && a2["zone-area-" + m].clip(h2[m]));
              J2 = d3.value > n2.max;
              a2.resetZones && 0 === g && (g = void 0);
            }), this.clips = h2);
          },
          invertGroups: function(a2) {
            function b2() {
              t(["group", "markerGroup"], function(b3) {
                c2[b3] && (d2.renderer.isVML && c2[b3].attr({ width: c2.yAxis.len, height: c2.xAxis.len }), c2[b3].width = c2.yAxis.len, c2[b3].height = c2.xAxis.len, c2[b3].invert(a2));
              });
            }
            var c2 = this, d2 = c2.chart, e2;
            c2.xAxis && (e2 = C(d2, "resize", b2), C(c2, "destroy", e2), b2(a2), c2.invertGroups = b2);
          },
          plotGroup: function(a2, b2, c2, d2, e2) {
            var g = this[a2], h2 = !g;
            h2 && (this[a2] = g = this.chart.renderer.g().attr({ zIndex: d2 || 0.1 }).add(e2));
            g.addClass("highcharts-" + b2 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (x(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (g.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
            g.attr({ visibility: c2 })[h2 ? "attr" : "animate"](this.getPlotBox());
            return g;
          },
          getPlotBox: function() {
            var a2 = this.chart, b2 = this.xAxis, c2 = this.yAxis;
            a2.inverted && (b2 = c2, c2 = this.xAxis);
            return { translateX: b2 ? b2.left : a2.plotLeft, translateY: c2 ? c2.top : a2.plotTop, scaleX: 1, scaleY: 1 };
          },
          render: function() {
            var a2 = this, b2 = a2.chart, d2, e2 = a2.options, h2 = !!a2.animate && b2.renderer.isSVG && F(e2.animation).duration, g = a2.visible ? "inherit" : "hidden", f2 = e2.zIndex, l2 = a2.hasRendered, k2 = b2.seriesGroup, p2 = b2.inverted;
            d2 = a2.plotGroup("group", "series", g, f2, k2);
            a2.markerGroup = a2.plotGroup("markerGroup", "markers", g, f2, k2);
            h2 && a2.animate(true);
            d2.inverted = a2.isCartesian ? p2 : false;
            a2.drawGraph && (a2.drawGraph(), a2.applyZones());
            a2.drawDataLabels && a2.drawDataLabels();
            a2.visible && a2.drawPoints();
            a2.drawTracker && false !== a2.options.enableMouseTracking && a2.drawTracker();
            a2.invertGroups(p2);
            false === e2.clip || a2.sharedClipKey || l2 || d2.clip(b2.clipRect);
            h2 && a2.animate();
            l2 || (a2.animationTimeout = B(function() {
              a2.afterAnimate();
            }, h2));
            a2.isDirty = false;
            a2.hasRendered = true;
            c(a2, "afterRender");
          },
          redraw: function() {
            var a2 = this.chart, b2 = this.isDirty || this.isDirtyData, c2 = this.group, d2 = this.xAxis, e2 = this.yAxis;
            c2 && (a2.inverted && c2.attr({ width: a2.plotWidth, height: a2.plotHeight }), c2.animate({
              translateX: v(d2 && d2.left, a2.plotLeft),
              translateY: v(e2 && e2.top, a2.plotTop)
            }));
            this.translate();
            this.render();
            b2 && delete this.kdTree;
          },
          kdAxisArray: ["clientX", "plotY"],
          searchPoint: function(a2, b2) {
            var c2 = this.xAxis, d2 = this.yAxis, e2 = this.chart.inverted;
            return this.searchKDTree({ clientX: e2 ? c2.len - a2.chartY + c2.pos : a2.chartX - c2.pos, plotY: e2 ? d2.len - a2.chartX + d2.pos : a2.chartY - d2.pos }, b2);
          },
          buildKDTree: function() {
            function a2(c3, d2, g) {
              var e2, h2;
              if (h2 = c3 && c3.length)
                return e2 = b2.kdAxisArray[d2 % g], c3.sort(function(a3, b3) {
                  return a3[e2] - b3[e2];
                }), h2 = Math.floor(h2 / 2), { point: c3[h2], left: a2(c3.slice(
                  0,
                  h2
                ), d2 + 1, g), right: a2(c3.slice(h2 + 1), d2 + 1, g) };
            }
            this.buildingKdTree = true;
            var b2 = this, c2 = -1 < b2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            delete b2.kdTree;
            B(function() {
              b2.kdTree = a2(b2.getValidPoints(null, !b2.directTouch), c2, c2);
              b2.buildingKdTree = false;
            }, b2.options.kdNow ? 0 : 1);
          },
          searchKDTree: function(a2, b2) {
            function c2(a3, b3, f2, l2) {
              var m = b3.point, k2 = d2.kdAxisArray[f2 % l2], p2, q2, r = m;
              q2 = x(a3[e2]) && x(m[e2]) ? Math.pow(a3[e2] - m[e2], 2) : null;
              p2 = x(a3[g]) && x(m[g]) ? Math.pow(a3[g] - m[g], 2) : null;
              p2 = (q2 || 0) + (p2 || 0);
              m.dist = x(p2) ? Math.sqrt(p2) : Number.MAX_VALUE;
              m.distX = x(q2) ? Math.sqrt(q2) : Number.MAX_VALUE;
              k2 = a3[k2] - m[k2];
              p2 = 0 > k2 ? "left" : "right";
              q2 = 0 > k2 ? "right" : "left";
              b3[p2] && (p2 = c2(a3, b3[p2], f2 + 1, l2), r = p2[h2] < r[h2] ? p2 : m);
              b3[q2] && Math.sqrt(k2 * k2) < r[h2] && (a3 = c2(a3, b3[q2], f2 + 1, l2), r = a3[h2] < r[h2] ? a3 : r);
              return r;
            }
            var d2 = this, e2 = this.kdAxisArray[0], g = this.kdAxisArray[1], h2 = b2 ? "distX" : "dist";
            b2 = -1 < d2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            this.kdTree || this.buildingKdTree || this.buildKDTree();
            if (this.kdTree)
              return c2(a2, this.kdTree, b2, b2);
          }
        });
      })(K);
      (function(a) {
        var C = a.Axis, F = a.Chart, I = a.correctFloat, n = a.defined, f = a.destroyObjectProperties, e = a.each, u = a.format, x = a.objectEach, t = a.pick, w = a.Series;
        a.StackItem = function(a2, c, e2, f2, k) {
          var h = a2.chart.inverted;
          this.axis = a2;
          this.isNegative = e2;
          this.options = c;
          this.x = f2;
          this.total = null;
          this.points = {};
          this.stack = k;
          this.rightCliff = this.leftCliff = 0;
          this.alignOptions = { align: c.align || (h ? e2 ? "left" : "right" : "center"), verticalAlign: c.verticalAlign || (h ? "middle" : e2 ? "bottom" : "top"), y: t(c.y, h ? 4 : e2 ? 14 : -6), x: t(c.x, h ? e2 ? -6 : 6 : 0) };
          this.textAlign = c.textAlign || (h ? e2 ? "right" : "left" : "center");
        };
        a.StackItem.prototype = { destroy: function() {
          f(
            this,
            this.axis
          );
        }, render: function(a2) {
          var c = this.axis.chart, e2 = this.options, f2 = e2.format, f2 = f2 ? u(f2, this, c.time) : e2.formatter.call(this);
          this.label ? this.label.attr({ text: f2, visibility: "hidden" }) : this.label = c.renderer.text(f2, null, null, e2.useHTML).css(e2.style).attr({ align: this.textAlign, rotation: e2.rotation, visibility: "hidden" }).add(a2);
          this.label.labelrank = c.plotHeight;
        }, setOffset: function(a2, c) {
          var e2 = this.axis, f2 = e2.chart, k = e2.translate(e2.usePercentage ? 100 : this.total, 0, 0, 0, 1), q = e2.translate(0), q = n(k) && Math.abs(k - q);
          a2 = f2.xAxis[0].translate(this.x) + a2;
          e2 = n(k) && this.getStackBox(f2, this, a2, k, c, q, e2);
          (c = this.label) && e2 && (c.align(this.alignOptions, null, e2), e2 = c.alignAttr, c[false === this.options.crop || f2.isInsidePlot(e2.x, e2.y) ? "show" : "hide"](true));
        }, getStackBox: function(a2, c, e2, f2, k, q, d) {
          var b = c.axis.reversed, h = a2.inverted;
          a2 = d.height + d.pos - (h ? a2.plotLeft : a2.plotTop);
          c = c.isNegative && !b || !c.isNegative && b;
          return { x: h ? c ? f2 : f2 - q : e2, y: h ? a2 - e2 - k : c ? a2 - f2 - q : a2 - f2, width: h ? q : k, height: h ? k : q };
        } };
        F.prototype.getStacks = function() {
          var a2 = this;
          e(a2.yAxis, function(a3) {
            a3.stacks && a3.hasVisibleSeries && (a3.oldStacks = a3.stacks);
          });
          e(a2.series, function(c) {
            !c.options.stacking || true !== c.visible && false !== a2.options.chart.ignoreHiddenSeries || (c.stackKey = c.type + t(c.options.stack, ""));
          });
        };
        C.prototype.buildStacks = function() {
          var a2 = this.series, c = t(this.options.reversedStacks, true), e2 = a2.length, f2;
          if (!this.isXAxis) {
            this.usePercentage = false;
            for (f2 = e2; f2--; )
              a2[c ? f2 : e2 - f2 - 1].setStackedPoints();
            for (f2 = 0; f2 < e2; f2++)
              a2[f2].modifyStacks();
          }
        };
        C.prototype.renderStackTotals = function() {
          var a2 = this.chart, c = a2.renderer, e2 = this.stacks, f2 = this.stackTotalGroup;
          f2 || (this.stackTotalGroup = f2 = c.g("stack-labels").attr({ visibility: "visible", zIndex: 6 }).add());
          f2.translate(a2.plotLeft, a2.plotTop);
          x(e2, function(a3) {
            x(a3, function(a4) {
              a4.render(f2);
            });
          });
        };
        C.prototype.resetStacks = function() {
          var a2 = this, c = a2.stacks;
          a2.isXAxis || x(c, function(c2) {
            x(c2, function(e2, h) {
              e2.touched < a2.stacksTouched ? (e2.destroy(), delete c2[h]) : (e2.total = null, e2.cumulative = null);
            });
          });
        };
        C.prototype.cleanStacks = function() {
          var a2;
          this.isXAxis || (this.oldStacks && (a2 = this.stacks = this.oldStacks), x(a2, function(a3) {
            x(a3, function(a4) {
              a4.cumulative = a4.total;
            });
          }));
        };
        w.prototype.setStackedPoints = function() {
          if (this.options.stacking && (true === this.visible || false === this.chart.options.chart.ignoreHiddenSeries)) {
            var e2 = this.processedXData, c = this.processedYData, h = [], f2 = c.length, k = this.options, q = k.threshold, d = t(k.startFromThreshold && q, 0), b = k.stack, k = k.stacking, v = this.stackKey, u2 = "-" + v, l = this.negStacks, w2 = this.yAxis, B = w2.stacks, D = w2.oldStacks, m, G, A, x2, E, g, r;
            w2.stacksTouched += 1;
            for (E = 0; E < f2; E++)
              g = e2[E], r = c[E], m = this.getStackIndicator(m, g, this.index), x2 = m.key, A = (G = l && r < (d ? 0 : q)) ? u2 : v, B[A] || (B[A] = {}), B[A][g] || (D[A] && D[A][g] ? (B[A][g] = D[A][g], B[A][g].total = null) : B[A][g] = new a.StackItem(w2, w2.options.stackLabels, G, g, b)), A = B[A][g], null !== r ? (A.points[x2] = A.points[this.index] = [t(A.cumulative, d)], n(A.cumulative) || (A.base = x2), A.touched = w2.stacksTouched, 0 < m.index && false === this.singleStacks && (A.points[x2][0] = A.points[this.index + "," + g + ",0"][0])) : A.points[x2] = A.points[this.index] = null, "percent" === k ? (G = G ? v : u2, l && B[G] && B[G][g] ? (G = B[G][g], A.total = G.total = Math.max(G.total, A.total) + Math.abs(r) || 0) : A.total = I(A.total + (Math.abs(r) || 0))) : A.total = I(A.total + (r || 0)), A.cumulative = t(A.cumulative, d) + (r || 0), null !== r && (A.points[x2].push(A.cumulative), h[E] = A.cumulative);
            "percent" === k && (w2.usePercentage = true);
            this.stackedYData = h;
            w2.oldStacks = {};
          }
        };
        w.prototype.modifyStacks = function() {
          var a2 = this, c = a2.stackKey, h = a2.yAxis.stacks, f2 = a2.processedXData, k, q = a2.options.stacking;
          a2[q + "Stacker"] && e([c, "-" + c], function(c2) {
            for (var b = f2.length, d, e2; b--; )
              if (d = f2[b], k = a2.getStackIndicator(k, d, a2.index, c2), e2 = (d = h[c2] && h[c2][d]) && d.points[k.key])
                a2[q + "Stacker"](e2, d, b);
          });
        };
        w.prototype.percentStacker = function(a2, c, e2) {
          c = c.total ? 100 / c.total : 0;
          a2[0] = I(a2[0] * c);
          a2[1] = I(a2[1] * c);
          this.stackedYData[e2] = a2[1];
        };
        w.prototype.getStackIndicator = function(a2, c, e2, f2) {
          !n(a2) || a2.x !== c || f2 && a2.key !== f2 ? a2 = { x: c, index: 0, key: f2 } : a2.index++;
          a2.key = [e2, c, a2.index].join();
          return a2;
        };
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.animate, I = a.Axis, n = a.createElement, f = a.css, e = a.defined, u = a.each, x = a.erase, t = a.extend, w = a.fireEvent, y = a.inArray, c = a.isNumber, h = a.isObject, p = a.isArray, k = a.merge, q = a.objectEach, d = a.pick, b = a.Point, v = a.Series, J = a.seriesTypes, l = a.setAnimation, L = a.splat;
        t(a.Chart.prototype, {
          addSeries: function(a2, b2, c2) {
            var e2, h2 = this;
            a2 && (b2 = d(b2, true), w(h2, "addSeries", { options: a2 }, function() {
              e2 = h2.initSeries(a2);
              h2.isDirtyLegend = true;
              h2.linkSeries();
              w(h2, "afterAddSeries");
              b2 && h2.redraw(c2);
            }));
            return e2;
          },
          addAxis: function(a2, b2, c2, e2) {
            var h2 = b2 ? "xAxis" : "yAxis", f2 = this.options;
            a2 = k(a2, { index: this[h2].length, isX: b2 });
            b2 = new I(this, a2);
            f2[h2] = L(f2[h2] || {});
            f2[h2].push(a2);
            d(c2, true) && this.redraw(e2);
            return b2;
          },
          showLoading: function(a2) {
            var b2 = this, c2 = b2.options, d2 = b2.loadingDiv, e2 = c2.loading, h2 = function() {
              d2 && f(d2, { left: b2.plotLeft + "px", top: b2.plotTop + "px", width: b2.plotWidth + "px", height: b2.plotHeight + "px" });
            };
            d2 || (b2.loadingDiv = d2 = n("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, b2.container), b2.loadingSpan = n("span", { className: "highcharts-loading-inner" }, null, d2), C(b2, "redraw", h2));
            d2.className = "highcharts-loading";
            b2.loadingSpan.innerHTML = a2 || c2.lang.loading;
            f(d2, t(e2.style, { zIndex: 10 }));
            f(b2.loadingSpan, e2.labelStyle);
            b2.loadingShown || (f(d2, {
              opacity: 0,
              display: ""
            }), F(d2, { opacity: e2.style.opacity || 0.5 }, { duration: e2.showDuration || 0 }));
            b2.loadingShown = true;
            h2();
          },
          hideLoading: function() {
            var a2 = this.options, b2 = this.loadingDiv;
            b2 && (b2.className = "highcharts-loading highcharts-loading-hidden", F(b2, { opacity: 0 }, { duration: a2.loading.hideDuration || 100, complete: function() {
              f(b2, { display: "none" });
            } }));
            this.loadingShown = false;
          },
          propsRequireDirtyBox: "backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
          propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
          update: function(a2, b2, h2, f2) {
            var l2 = this, m = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle" }, p2 = a2.chart, g, r, v2 = [];
            w(l2, "update", { options: a2 });
            if (p2) {
              k(true, l2.options.chart, p2);
              "className" in p2 && l2.setClassName(p2.className);
              "reflow" in p2 && l2.setReflow(p2.reflow);
              if ("inverted" in p2 || "polar" in p2 || "type" in p2)
                l2.propFromSeries(), g = true;
              "alignTicks" in p2 && (g = true);
              q(p2, function(a3, b3) {
                -1 !== y("chart." + b3, l2.propsRequireUpdateSeries) && (r = true);
                -1 !== y(b3, l2.propsRequireDirtyBox) && (l2.isDirtyBox = true);
              });
              "style" in p2 && l2.renderer.setStyle(p2.style);
            }
            a2.colors && (this.options.colors = a2.colors);
            a2.plotOptions && k(true, this.options.plotOptions, a2.plotOptions);
            q(a2, function(a3, b3) {
              if (l2[b3] && "function" === typeof l2[b3].update)
                l2[b3].update(a3, false);
              else if ("function" === typeof l2[m[b3]])
                l2[m[b3]](a3);
              "chart" !== b3 && -1 !== y(b3, l2.propsRequireUpdateSeries) && (r = true);
            });
            u("xAxis yAxis zAxis series colorAxis pane".split(" "), function(b3) {
              var c2;
              a2[b3] && ("series" === b3 && (c2 = [], u(l2[b3], function(a3, b4) {
                a3.options.isInternal || c2.push(b4);
              })), u(L(a2[b3]), function(a3, d2) {
                (d2 = e(a3.id) && l2.get(a3.id) || l2[b3][c2 ? c2[d2] : d2]) && d2.coll === b3 && (d2.update(a3, false), h2 && (d2.touched = true));
                if (!d2 && h2) {
                  if ("series" === b3)
                    l2.addSeries(a3, false).touched = true;
                  else if ("xAxis" === b3 || "yAxis" === b3)
                    l2.addAxis(a3, "xAxis" === b3, false).touched = true;
                }
              }), h2 && u(l2[b3], function(a3) {
                a3.touched || a3.options.isInternal ? delete a3.touched : v2.push(a3);
              }));
            });
            u(v2, function(a3) {
              a3.remove && a3.remove(false);
            });
            g && u(l2.axes, function(a3) {
              a3.update({}, false);
            });
            r && u(
              l2.series,
              function(a3) {
                a3.update({}, false);
              }
            );
            a2.loading && k(true, l2.options.loading, a2.loading);
            g = p2 && p2.width;
            p2 = p2 && p2.height;
            c(g) && g !== l2.chartWidth || c(p2) && p2 !== l2.chartHeight ? l2.setSize(g, p2, f2) : d(b2, true) && l2.redraw(f2);
            w(l2, "afterUpdate", { options: a2 });
          },
          setSubtitle: function(a2) {
            this.setTitle(void 0, a2);
          }
        });
        t(b.prototype, { update: function(a2, b2, c2, e2) {
          function f2() {
            l2.applyOptions(a2);
            null === l2.y && g && (l2.graphic = g.destroy());
            h(a2, true) && (g && g.element && a2 && a2.marker && void 0 !== a2.marker.symbol && (l2.graphic = g.destroy()), a2 && a2.dataLabels && l2.dataLabel && (l2.dataLabel = l2.dataLabel.destroy()), l2.connector && (l2.connector = l2.connector.destroy()));
            k2 = l2.index;
            m.updateParallelArrays(l2, k2);
            p2.data[k2] = h(p2.data[k2], true) || h(a2, true) ? l2.options : d(a2, p2.data[k2]);
            m.isDirty = m.isDirtyData = true;
            !m.fixedBox && m.hasCartesianSeries && (q2.isDirtyBox = true);
            "point" === p2.legendType && (q2.isDirtyLegend = true);
            b2 && q2.redraw(c2);
          }
          var l2 = this, m = l2.series, g = l2.graphic, k2, q2 = m.chart, p2 = m.options;
          b2 = d(b2, true);
          false === e2 ? f2() : l2.firePointEvent("update", { options: a2 }, f2);
        }, remove: function(a2, b2) {
          this.series.removePoint(
            y(this, this.series.data),
            a2,
            b2
          );
        } });
        t(v.prototype, { addPoint: function(a2, b2, c2, e2) {
          var h2 = this.options, f2 = this.data, l2 = this.chart, g = this.xAxis, g = g && g.hasNames && g.names, m = h2.data, k2, p2, q2 = this.xData, v2, n2;
          b2 = d(b2, true);
          k2 = { series: this };
          this.pointClass.prototype.applyOptions.apply(k2, [a2]);
          n2 = k2.x;
          v2 = q2.length;
          if (this.requireSorting && n2 < q2[v2 - 1])
            for (p2 = true; v2 && q2[v2 - 1] > n2; )
              v2--;
          this.updateParallelArrays(k2, "splice", v2, 0, 0);
          this.updateParallelArrays(k2, v2);
          g && k2.name && (g[n2] = k2.name);
          m.splice(v2, 0, a2);
          p2 && (this.data.splice(v2, 0, null), this.processData());
          "point" === h2.legendType && this.generatePoints();
          c2 && (f2[0] && f2[0].remove ? f2[0].remove(false) : (f2.shift(), this.updateParallelArrays(k2, "shift"), m.shift()));
          this.isDirtyData = this.isDirty = true;
          b2 && l2.redraw(e2);
        }, removePoint: function(a2, b2, c2) {
          var e2 = this, h2 = e2.data, f2 = h2[a2], m = e2.points, g = e2.chart, k2 = function() {
            m && m.length === h2.length && m.splice(a2, 1);
            h2.splice(a2, 1);
            e2.options.data.splice(a2, 1);
            e2.updateParallelArrays(f2 || { series: e2 }, "splice", a2, 1);
            f2 && f2.destroy();
            e2.isDirty = true;
            e2.isDirtyData = true;
            b2 && g.redraw();
          };
          l(c2, g);
          b2 = d(b2, true);
          f2 ? f2.firePointEvent("remove", null, k2) : k2();
        }, remove: function(a2, b2, c2) {
          function e2() {
            h2.destroy();
            h2.remove = null;
            f2.isDirtyLegend = f2.isDirtyBox = true;
            f2.linkSeries();
            d(a2, true) && f2.redraw(b2);
          }
          var h2 = this, f2 = h2.chart;
          false !== c2 ? w(h2, "remove", null, e2) : e2();
        }, update: function(b2, c2) {
          var e2 = this, h2 = e2.chart, f2 = e2.userOptions, l2 = e2.oldType || e2.type, q2 = b2.type || f2.type || h2.options.chart.type, g = J[l2].prototype, p2, v2 = ["group", "markerGroup", "dataLabelsGroup"], n2 = ["navigatorSeries", "baseSeries"], B = e2.finishedAnimating && { animation: false }, D = ["data", "name", "turboThreshold"], x2 = a.keys(b2), L2 = 0 < x2.length;
          u(x2, function(a2) {
            -1 === y(a2, D) && (L2 = false);
          });
          if (L2)
            b2.data && this.setData(b2.data, false), b2.name && this.setName(b2.name, false);
          else {
            n2 = v2.concat(n2);
            u(n2, function(a2) {
              n2[a2] = e2[a2];
              delete e2[a2];
            });
            b2 = k(f2, B, { index: e2.index, pointStart: d(f2.pointStart, e2.xData[0]) }, { data: e2.options.data }, b2);
            e2.remove(false, null, false);
            for (p2 in g)
              e2[p2] = void 0;
            J[q2 || l2] ? t(e2, J[q2 || l2].prototype) : a.error(17, true);
            u(n2, function(a2) {
              e2[a2] = n2[a2];
            });
            e2.init(h2, b2);
            b2.zIndex !== f2.zIndex && u(v2, function(a2) {
              e2[a2] && e2[a2].attr({ zIndex: b2.zIndex });
            });
            e2.oldType = l2;
            h2.linkSeries();
          }
          w(this, "afterUpdate");
          d(c2, true) && h2.redraw(L2 ? void 0 : false);
        }, setName: function(a2) {
          this.name = this.options.name = this.userOptions.name = a2;
          this.chart.isDirtyLegend = true;
        } });
        t(I.prototype, {
          update: function(a2, b2) {
            var c2 = this.chart, e2 = a2 && a2.events || {};
            a2 = k(this.userOptions, a2);
            c2.options[this.coll].indexOf && (c2.options[this.coll][c2.options[this.coll].indexOf(this.userOptions)] = a2);
            q(c2.options[this.coll].events, function(a3, b3) {
              "undefined" === typeof e2[b3] && (e2[b3] = void 0);
            });
            this.destroy(true);
            this.init(c2, t(a2, { events: e2 }));
            c2.isDirtyBox = true;
            d(b2, true) && c2.redraw();
          },
          remove: function(a2) {
            for (var b2 = this.chart, c2 = this.coll, e2 = this.series, h2 = e2.length; h2--; )
              e2[h2] && e2[h2].remove(false);
            x(b2.axes, this);
            x(b2[c2], this);
            p(b2.options[c2]) ? b2.options[c2].splice(this.options.index, 1) : delete b2.options[c2];
            u(b2[c2], function(a3, b3) {
              a3.options.index = a3.userOptions.index = b3;
            });
            this.destroy();
            b2.isDirtyBox = true;
            d(a2, true) && b2.redraw();
          },
          setTitle: function(a2, b2) {
            this.update({ title: a2 }, b2);
          },
          setCategories: function(a2, b2) {
            this.update({ categories: a2 }, b2);
          }
        });
      })(K);
      (function(a) {
        var C = a.color, F = a.each, I = a.map, n = a.pick, f = a.Series, e = a.seriesType;
        e("area", "line", { softThreshold: false, threshold: 0 }, { singleStacks: false, getStackPoints: function(e2) {
          var f2 = [], t = [], u = this.xAxis, y = this.yAxis, c = y.stacks[this.stackKey], h = {}, p = this.index, k = y.series, q = k.length, d, b = n(y.options.reversedStacks, true) ? 1 : -1, v;
          e2 = e2 || this.points;
          if (this.options.stacking) {
            for (v = 0; v < e2.length; v++)
              e2[v].leftNull = e2[v].rightNull = null, h[e2[v].x] = e2[v];
            a.objectEach(c, function(a2, b2) {
              null !== a2.total && t.push(b2);
            });
            t.sort(function(a2, b2) {
              return a2 - b2;
            });
            d = I(k, function() {
              return this.visible;
            });
            F(
              t,
              function(a2, e3) {
                var l = 0, k2, n2;
                if (h[a2] && !h[a2].isNull)
                  f2.push(h[a2]), F([-1, 1], function(f3) {
                    var l2 = 1 === f3 ? "rightNull" : "leftNull", m = 0, u2 = c[t[e3 + f3]];
                    if (u2)
                      for (v = p; 0 <= v && v < q; )
                        k2 = u2.points[v], k2 || (v === p ? h[a2][l2] = true : d[v] && (n2 = c[a2].points[v]) && (m -= n2[1] - n2[0])), v += b;
                    h[a2][1 === f3 ? "rightCliff" : "leftCliff"] = m;
                  });
                else {
                  for (v = p; 0 <= v && v < q; ) {
                    if (k2 = c[a2].points[v]) {
                      l = k2[1];
                      break;
                    }
                    v += b;
                  }
                  l = y.translate(l, 0, 1, 0, 1);
                  f2.push({ isNull: true, plotX: u.translate(a2, 0, 0, 0, 1), x: a2, plotY: l, yBottom: l });
                }
              }
            );
          }
          return f2;
        }, getGraphPath: function(a2) {
          var e2 = f.prototype.getGraphPath, t = this.options, u = t.stacking, y = this.yAxis, c, h, p = [], k = [], q = this.index, d, b = y.stacks[this.stackKey], v = t.threshold, J = y.getThreshold(t.threshold), l, t = t.connectNulls || "percent" === u, L = function(c2, e3, h2) {
            var f2 = a2[c2];
            c2 = u && b[f2.x].points[q];
            var l2 = f2[h2 + "Null"] || 0;
            h2 = f2[h2 + "Cliff"] || 0;
            var m, n2, f2 = true;
            h2 || l2 ? (m = (l2 ? c2[0] : c2[1]) + h2, n2 = c2[0] + h2, f2 = !!l2) : !u && a2[e3] && a2[e3].isNull && (m = n2 = v);
            void 0 !== m && (k.push({ plotX: d, plotY: null === m ? J : y.getThreshold(m), isNull: f2, isCliff: true }), p.push({ plotX: d, plotY: null === n2 ? J : y.getThreshold(n2), doCurve: false }));
          };
          a2 = a2 || this.points;
          u && (a2 = this.getStackPoints(a2));
          for (c = 0; c < a2.length; c++)
            if (h = a2[c].isNull, d = n(a2[c].rectPlotX, a2[c].plotX), l = n(a2[c].yBottom, J), !h || t)
              t || L(c, c - 1, "left"), h && !u && t || (k.push(a2[c]), p.push({ x: c, plotX: d, plotY: l })), t || L(c, c + 1, "right");
          c = e2.call(this, k, true, true);
          p.reversed = true;
          h = e2.call(this, p, true, true);
          h.length && (h[0] = "L");
          h = c.concat(h);
          e2 = e2.call(this, k, false, t);
          h.xMap = c.xMap;
          this.areaPath = h;
          return e2;
        }, drawGraph: function() {
          this.areaPath = [];
          f.prototype.drawGraph.apply(this);
          var a2 = this, e2 = this.areaPath, t = this.options, w = [["area", "highcharts-area", this.color, t.fillColor]];
          F(this.zones, function(e3, c) {
            w.push(["zone-area-" + c, "highcharts-area highcharts-zone-area-" + c + " " + e3.className, e3.color || a2.color, e3.fillColor || t.fillColor]);
          });
          F(w, function(f2) {
            var c = f2[0], h = a2[c];
            h ? (h.endX = a2.preventGraphAnimation ? null : e2.xMap, h.animate({ d: e2 })) : (h = a2[c] = a2.chart.renderer.path(e2).addClass(f2[1]).attr({ fill: n(f2[3], C(f2[2]).setOpacity(n(t.fillOpacity, 0.75)).get()), zIndex: 0 }).add(a2.group), h.isArea = true);
            h.startX = e2.xMap;
            h.shiftUnit = t.step ? 2 : 1;
          });
        }, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle });
      })(K);
      (function(a) {
        var C = a.pick;
        a = a.seriesType;
        a("spline", "line", {}, { getPointSpline: function(a2, I, n) {
          var f = I.plotX, e = I.plotY, u = a2[n - 1];
          n = a2[n + 1];
          var x, t, w, y;
          if (u && !u.isNull && false !== u.doCurve && !I.isCliff && n && !n.isNull && false !== n.doCurve && !I.isCliff) {
            a2 = u.plotY;
            w = n.plotX;
            n = n.plotY;
            var c = 0;
            x = (1.5 * f + u.plotX) / 2.5;
            t = (1.5 * e + a2) / 2.5;
            w = (1.5 * f + w) / 2.5;
            y = (1.5 * e + n) / 2.5;
            w !== x && (c = (y - t) * (w - f) / (w - x) + e - y);
            t += c;
            y += c;
            t > a2 && t > e ? (t = Math.max(a2, e), y = 2 * e - t) : t < a2 && t < e && (t = Math.min(a2, e), y = 2 * e - t);
            y > n && y > e ? (y = Math.max(n, e), t = 2 * e - y) : y < n && y < e && (y = Math.min(n, e), t = 2 * e - y);
            I.rightContX = w;
            I.rightContY = y;
          }
          I = ["C", C(u.rightContX, u.plotX), C(u.rightContY, u.plotY), C(x, f), C(t, e), f, e];
          u.rightContX = u.rightContY = null;
          return I;
        } });
      })(K);
      (function(a) {
        var C = a.seriesTypes.area.prototype, F = a.seriesType;
        F("areaspline", "spline", a.defaultPlotOptions.area, { getStackPoints: C.getStackPoints, getGraphPath: C.getGraphPath, drawGraph: C.drawGraph, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle });
      })(K);
      (function(a) {
        var C = a.animObject, F = a.color, I = a.each, n = a.extend, f = a.defined, e = a.isNumber, u = a.merge, x = a.pick, t = a.Series, w = a.seriesType, y = a.svg;
        w("column", "line", { borderRadius: 0, crisp: true, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: false, brightness: 0.1 }, select: { color: "#cccccc", borderColor: "#000000" } }, dataLabels: { align: null, verticalAlign: null, y: null }, softThreshold: false, startFromThreshold: true, stickyTracking: false, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" }, { cropShoulder: 0, directTouch: true, trackerGroups: [
          "group",
          "dataLabelsGroup"
        ], negStacks: true, init: function() {
          t.prototype.init.apply(this, arguments);
          var a2 = this, e2 = a2.chart;
          e2.hasRendered && I(e2.series, function(c) {
            c.type === a2.type && (c.isDirty = true);
          });
        }, getColumnMetrics: function() {
          var a2 = this, e2 = a2.options, f2 = a2.xAxis, k = a2.yAxis, q = f2.options.reversedStacks, q = f2.reversed && !q || !f2.reversed && q, d, b = {}, v = 0;
          false === e2.grouping ? v = 1 : I(a2.chart.series, function(c) {
            var e3 = c.options, f3 = c.yAxis, h;
            c.type !== a2.type || !c.visible && a2.chart.options.chart.ignoreHiddenSeries || k.len !== f3.len || k.pos !== f3.pos || (e3.stacking ? (d = c.stackKey, void 0 === b[d] && (b[d] = v++), h = b[d]) : false !== e3.grouping && (h = v++), c.columnIndex = h);
          });
          var n2 = Math.min(Math.abs(f2.transA) * (f2.ordinalSlope || e2.pointRange || f2.closestPointRange || f2.tickInterval || 1), f2.len), l = n2 * e2.groupPadding, t2 = (n2 - 2 * l) / (v || 1), e2 = Math.min(e2.maxPointWidth || f2.len, x(e2.pointWidth, t2 * (1 - 2 * e2.pointPadding)));
          a2.columnMetrics = { width: e2, offset: (t2 - e2) / 2 + (l + ((a2.columnIndex || 0) + (q ? 1 : 0)) * t2 - n2 / 2) * (q ? -1 : 1) };
          return a2.columnMetrics;
        }, crispCol: function(a2, e2, f2, k) {
          var c = this.chart, d = this.borderWidth, b = -(d % 2 ? 0.5 : 0), d = d % 2 ? 0.5 : 1;
          c.inverted && c.renderer.isVML && (d += 1);
          this.options.crisp && (f2 = Math.round(a2 + f2) + b, a2 = Math.round(a2) + b, f2 -= a2);
          k = Math.round(e2 + k) + d;
          b = 0.5 >= Math.abs(e2) && 0.5 < k;
          e2 = Math.round(e2) + d;
          k -= e2;
          b && k && (--e2, k += 1);
          return { x: a2, y: e2, width: f2, height: k };
        }, translate: function() {
          var a2 = this, e2 = a2.chart, p = a2.options, k = a2.dense = 2 > a2.closestPointRange * a2.xAxis.transA, k = a2.borderWidth = x(p.borderWidth, k ? 0 : 1), q = a2.yAxis, d = p.threshold, b = a2.translatedThreshold = q.getThreshold(d), v = x(p.minPointLength, 5), n2 = a2.getColumnMetrics(), l = n2.width, u2 = a2.barW = Math.max(l, 1 + 2 * k), B = a2.pointXOffset = n2.offset;
          e2.inverted && (b -= 0.5);
          p.pointPadding && (u2 = Math.ceil(u2));
          t.prototype.translate.apply(a2);
          I(a2.points, function(c) {
            var h = x(c.yBottom, b), k2 = 999 + Math.abs(h), p2 = l, k2 = Math.min(Math.max(-k2, c.plotY), q.len + k2), n3 = c.plotX + B, t2 = u2, g = Math.min(k2, h), r, w2 = Math.max(k2, h) - g;
            v && Math.abs(w2) < v && (w2 = v, r = !q.reversed && !c.negative || q.reversed && c.negative, c.y === d && a2.dataMax <= d && q.min < d && (r = !r), g = Math.abs(g - b) > v ? h - v : b - (r ? v : 0));
            f(c.options.pointWidth) && (p2 = t2 = Math.ceil(c.options.pointWidth), n3 -= Math.round((p2 - l) / 2));
            c.barX = n3;
            c.pointWidth = p2;
            c.tooltipPos = e2.inverted ? [q.len + q.pos - e2.plotLeft - k2, a2.xAxis.len - n3 - t2 / 2, w2] : [n3 + t2 / 2, k2 + q.pos - e2.plotTop, w2];
            c.shapeType = "rect";
            c.shapeArgs = a2.crispCol.apply(a2, c.isNull ? [n3, b, t2, 0] : [n3, g, t2, w2]);
          });
        }, getSymbol: a.noop, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle, drawGraph: function() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        }, pointAttribs: function(a2, e2) {
          var c = this.options, f2, h = this.pointAttrToOptions || {};
          f2 = h.stroke || "borderColor";
          var d = h["stroke-width"] || "borderWidth", b = a2 && a2.color || this.color, n2 = a2 && a2[f2] || c[f2] || this.color || b, t2 = a2 && a2[d] || c[d] || this[d] || 0, h = c.dashStyle;
          a2 && this.zones.length && (b = a2.getZone(), b = a2.options.color || b && b.color || this.color);
          e2 && (a2 = u(c.states[e2], a2.options.states && a2.options.states[e2] || {}), e2 = a2.brightness, b = a2.color || void 0 !== e2 && F(b).brighten(a2.brightness).get() || b, n2 = a2[f2] || n2, t2 = a2[d] || t2, h = a2.dashStyle || h);
          f2 = { fill: b, stroke: n2, "stroke-width": t2 };
          h && (f2.dashstyle = h);
          return f2;
        }, drawPoints: function() {
          var a2 = this, f2 = this.chart, p = a2.options, k = f2.renderer, q = p.animationLimit || 250, d;
          I(a2.points, function(b) {
            var c = b.graphic, h = c && f2.pointCount < q ? "animate" : "attr";
            if (e(b.plotY) && null !== b.y) {
              d = b.shapeArgs;
              if (c)
                c[h](u(d));
              else
                b.graphic = c = k[b.shapeType](d).add(b.group || a2.group);
              p.borderRadius && c.attr({ r: p.borderRadius });
              c[h](a2.pointAttribs(b, b.selected && "select")).shadow(p.shadow, null, p.stacking && !p.borderRadius);
              c.addClass(b.getClassName(), true);
            } else
              c && (b.graphic = c.destroy());
          });
        }, animate: function(a2) {
          var c = this, e2 = this.yAxis, f2 = c.options, q = this.chart.inverted, d = {}, b = q ? "translateX" : "translateY", v;
          y && (a2 ? (d.scaleY = 1e-3, a2 = Math.min(e2.pos + e2.len, Math.max(e2.pos, e2.toPixels(f2.threshold))), q ? d.translateX = a2 - e2.len : d.translateY = a2, c.group.attr(d)) : (v = c.group.attr(b), c.group.animate({ scaleY: 1 }, n(C(c.options.animation), { step: function(a3, f3) {
            d[b] = v + f3.pos * (e2.pos - v);
            c.group.attr(d);
          } })), c.animate = null));
        }, remove: function() {
          var a2 = this, e2 = a2.chart;
          e2.hasRendered && I(e2.series, function(c) {
            c.type === a2.type && (c.isDirty = true);
          });
          t.prototype.remove.apply(a2, arguments);
        } });
      })(K);
      (function(a) {
        a = a.seriesType;
        a("bar", "column", null, { inverted: true });
      })(K);
      (function(a) {
        var C = a.Series;
        a = a.seriesType;
        a("scatter", "line", { lineWidth: 0, findNearestPointBy: "xy", marker: { enabled: true }, tooltip: { headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.85em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } }, {
          sorted: false,
          requireSorting: false,
          noSharedTooltip: true,
          trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
          takeOrdinalPosition: false,
          drawGraph: function() {
            this.options.lineWidth && C.prototype.drawGraph.call(this);
          }
        });
      })(K);
      (function(a) {
        var C = a.deg2rad, F = a.isNumber, I = a.pick, n = a.relativeLength;
        a.CenteredSeriesMixin = { getCenter: function() {
          var a2 = this.options, e = this.chart, u = 2 * (a2.slicedOffset || 0), x = e.plotWidth - 2 * u, e = e.plotHeight - 2 * u, t = a2.center, t = [I(t[0], "50%"), I(t[1], "50%"), a2.size || "100%", a2.innerSize || 0], w = Math.min(x, e), y, c;
          for (y = 0; 4 > y; ++y)
            c = t[y], a2 = 2 > y || 2 === y && /%$/.test(c), t[y] = n(c, [x, e, w, t[2]][y]) + (a2 ? u : 0);
          t[3] > t[2] && (t[3] = t[2]);
          return t;
        }, getStartAndEndRadians: function(a2, e) {
          a2 = F(a2) ? a2 : 0;
          e = F(e) && e > a2 && 360 > e - a2 ? e : a2 + 360;
          return { start: C * (a2 + -90), end: C * (e + -90) };
        } };
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.CenteredSeriesMixin, I = a.defined, n = a.each, f = a.extend, e = F.getStartAndEndRadians, u = a.inArray, x = a.noop, t = a.pick, w = a.Point, y = a.Series, c = a.seriesType, h = a.setAnimation;
        c("pie", "line", { center: [null, null], clip: false, colorByPoint: true, dataLabels: {
          allowOverlap: true,
          distance: 30,
          enabled: true,
          formatter: function() {
            return this.point.isNull ? void 0 : this.point.name;
          },
          x: 0
        }, ignoreHiddenPoint: true, legendType: "point", marker: null, size: null, showInLegend: false, slicedOffset: 10, stickyTracking: false, tooltip: { followPointer: true }, borderColor: "#ffffff", borderWidth: 1, states: { hover: { brightness: 0.1 } } }, {
          isCartesian: false,
          requireSorting: false,
          directTouch: true,
          noSharedTooltip: true,
          trackerGroups: ["group", "dataLabelsGroup"],
          axisTypes: [],
          pointAttribs: a.seriesTypes.column.prototype.pointAttribs,
          animate: function(a2) {
            var c2 = this, e2 = c2.points, d = c2.startAngleRad;
            a2 || (n(e2, function(a3) {
              var b = a3.graphic, e3 = a3.shapeArgs;
              b && (b.attr({ r: a3.startR || c2.center[3] / 2, start: d, end: d }), b.animate({ r: e3.r, start: e3.start, end: e3.end }, c2.options.animation));
            }), c2.animate = null);
          },
          updateTotals: function() {
            var a2, c2 = 0, e2 = this.points, d = e2.length, b, f2 = this.options.ignoreHiddenPoint;
            for (a2 = 0; a2 < d; a2++)
              b = e2[a2], c2 += f2 && !b.visible ? 0 : b.isNull ? 0 : b.y;
            this.total = c2;
            for (a2 = 0; a2 < d; a2++)
              b = e2[a2], b.percentage = 0 < c2 && (b.visible || !f2) ? b.y / c2 * 100 : 0, b.total = c2;
          },
          generatePoints: function() {
            y.prototype.generatePoints.call(this);
            this.updateTotals();
          },
          translate: function(a2) {
            this.generatePoints();
            var c2 = 0, f2 = this.options, d = f2.slicedOffset, b = d + (f2.borderWidth || 0), h2, n2, l, p = e(f2.startAngle, f2.endAngle), u2 = this.startAngleRad = p.start, p = (this.endAngleRad = p.end) - u2, w2 = this.points, m, x2 = f2.dataLabels.distance, f2 = f2.ignoreHiddenPoint, A, y2 = w2.length, E;
            a2 || (this.center = a2 = this.getCenter());
            this.getX = function(b2, c3, d2) {
              l = Math.asin(Math.min((b2 - a2[1]) / (a2[2] / 2 + d2.labelDistance), 1));
              return a2[0] + (c3 ? -1 : 1) * Math.cos(l) * (a2[2] / 2 + d2.labelDistance);
            };
            for (A = 0; A < y2; A++) {
              E = w2[A];
              E.labelDistance = t(E.options.dataLabels && E.options.dataLabels.distance, x2);
              this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, E.labelDistance);
              h2 = u2 + c2 * p;
              if (!f2 || E.visible)
                c2 += E.percentage / 100;
              n2 = u2 + c2 * p;
              E.shapeType = "arc";
              E.shapeArgs = { x: a2[0], y: a2[1], r: a2[2] / 2, innerR: a2[3] / 2, start: Math.round(1e3 * h2) / 1e3, end: Math.round(1e3 * n2) / 1e3 };
              l = (n2 + h2) / 2;
              l > 1.5 * Math.PI ? l -= 2 * Math.PI : l < -Math.PI / 2 && (l += 2 * Math.PI);
              E.slicedTranslation = { translateX: Math.round(Math.cos(l) * d), translateY: Math.round(Math.sin(l) * d) };
              n2 = Math.cos(l) * a2[2] / 2;
              m = Math.sin(l) * a2[2] / 2;
              E.tooltipPos = [a2[0] + 0.7 * n2, a2[1] + 0.7 * m];
              E.half = l < -Math.PI / 2 || l > Math.PI / 2 ? 1 : 0;
              E.angle = l;
              h2 = Math.min(b, E.labelDistance / 5);
              E.labelPos = [a2[0] + n2 + Math.cos(l) * E.labelDistance, a2[1] + m + Math.sin(l) * E.labelDistance, a2[0] + n2 + Math.cos(l) * h2, a2[1] + m + Math.sin(l) * h2, a2[0] + n2, a2[1] + m, 0 > E.labelDistance ? "center" : E.half ? "right" : "left", l];
            }
          },
          drawGraph: null,
          drawPoints: function() {
            var a2 = this, c2 = a2.chart.renderer, e2, d, b, h2, t2 = a2.options.shadow;
            t2 && !a2.shadowGroup && (a2.shadowGroup = c2.g("shadow").add(a2.group));
            n(a2.points, function(l) {
              d = l.graphic;
              if (l.isNull)
                d && (l.graphic = d.destroy());
              else {
                h2 = l.shapeArgs;
                e2 = l.getTranslate();
                var k = l.shadowGroup;
                t2 && !k && (k = l.shadowGroup = c2.g("shadow").add(a2.shadowGroup));
                k && k.attr(e2);
                b = a2.pointAttribs(l, l.selected && "select");
                d ? d.setRadialReference(a2.center).attr(b).animate(f(h2, e2)) : (l.graphic = d = c2[l.shapeType](h2).setRadialReference(a2.center).attr(e2).add(a2.group), d.attr(b).attr({ "stroke-linejoin": "round" }).shadow(t2, k));
                d.attr({ visibility: l.visible ? "inherit" : "hidden" });
                d.addClass(l.getClassName());
              }
            });
          },
          searchPoint: x,
          sortByAngle: function(a2, c2) {
            a2.sort(function(a3, d) {
              return void 0 !== a3.angle && (d.angle - a3.angle) * c2;
            });
          },
          drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
          getCenter: F.getCenter,
          getSymbol: x
        }, { init: function() {
          w.prototype.init.apply(this, arguments);
          var a2 = this, c2;
          a2.name = t(a2.name, "Slice");
          c2 = function(c3) {
            a2.slice("select" === c3.type);
          };
          C(a2, "select", c2);
          C(a2, "unselect", c2);
          return a2;
        }, isValid: function() {
          return a.isNumber(this.y, true) && 0 <= this.y;
        }, setVisible: function(a2, c2) {
          var e2 = this, d = e2.series, b = d.chart, f2 = d.options.ignoreHiddenPoint;
          c2 = t(c2, f2);
          a2 !== e2.visible && (e2.visible = e2.options.visible = a2 = void 0 === a2 ? !e2.visible : a2, d.options.data[u(e2, d.data)] = e2.options, n(["graphic", "dataLabel", "connector", "shadowGroup"], function(b2) {
            if (e2[b2])
              e2[b2][a2 ? "show" : "hide"](true);
          }), e2.legendItem && b.legend.colorizeItem(e2, a2), a2 || "hover" !== e2.state || e2.setState(""), f2 && (d.isDirty = true), c2 && b.redraw());
        }, slice: function(a2, c2, e2) {
          var d = this.series;
          h(e2, d.chart);
          t(c2, true);
          this.sliced = this.options.sliced = I(a2) ? a2 : !this.sliced;
          d.options.data[u(this, d.data)] = this.options;
          this.graphic.animate(this.getTranslate());
          this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
        }, getTranslate: function() {
          return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 };
        }, haloPath: function(a2) {
          var c2 = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c2.x, c2.y, c2.r + a2, c2.r + a2, { innerR: this.shapeArgs.r - 1, start: c2.start, end: c2.end });
        } });
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.arrayMax, I = a.defined, n = a.each, f = a.extend, e = a.format, u = a.map, x = a.merge, t = a.noop, w = a.pick, y = a.relativeLength, c = a.Series, h = a.seriesTypes, p = a.some, k = a.stableSort, q = a.isArray, d = a.splat;
        a.distribute = function(b, c2, d2) {
          function e2(a2, b2) {
            return a2.target - b2.target;
          }
          var f2, h2 = true, q2 = b, m = [], v;
          v = 0;
          var t2 = q2.reducedLen || c2;
          for (f2 = b.length; f2--; )
            v += b[f2].size;
          if (v > t2) {
            k(b, function(a2, b2) {
              return (b2.rank || 0) - (a2.rank || 0);
            });
            for (v = f2 = 0; v <= t2; )
              v += b[f2].size, f2++;
            m = b.splice(f2 - 1, b.length);
          }
          k(b, e2);
          for (b = u(b, function(a2) {
            return { size: a2.size, targets: [a2.target], align: w(a2.align, 0.5) };
          }); h2; ) {
            for (f2 = b.length; f2--; )
              h2 = b[f2], v = (Math.min.apply(0, h2.targets) + Math.max.apply(
                0,
                h2.targets
              )) / 2, h2.pos = Math.min(Math.max(0, v - h2.size * h2.align), c2 - h2.size);
            f2 = b.length;
            for (h2 = false; f2--; )
              0 < f2 && b[f2 - 1].pos + b[f2 - 1].size > b[f2].pos && (b[f2 - 1].size += b[f2].size, b[f2 - 1].targets = b[f2 - 1].targets.concat(b[f2].targets), b[f2 - 1].align = 0.5, b[f2 - 1].pos + b[f2 - 1].size > c2 && (b[f2 - 1].pos = c2 - b[f2 - 1].size), b.splice(f2, 1), h2 = true);
          }
          q2.push.apply(q2, m);
          f2 = 0;
          p(b, function(b2) {
            var e3 = 0;
            if (p(b2.targets, function() {
              q2[f2].pos = b2.pos + e3;
              if (Math.abs(q2[f2].pos - q2[f2].target) > d2)
                return n(q2.slice(0, f2 + 1), function(a2) {
                  delete a2.pos;
                }), q2.reducedLen = (q2.reducedLen || c2) - 0.1 * c2, q2.reducedLen > 0.1 * c2 && a.distribute(q2, c2, d2), true;
              e3 += q2[f2].size;
              f2++;
            }))
              return true;
          });
          k(q2, e2);
        };
        c.prototype.drawDataLabels = function() {
          function b(a2, b2) {
            var c3 = b2.filter;
            return c3 ? (b2 = c3.operator, a2 = a2[c3.property], c3 = c3.value, ">" === b2 && a2 > c3 || "<" === b2 && a2 < c3 || ">=" === b2 && a2 >= c3 || "<=" === b2 && a2 <= c3 || "==" === b2 && a2 == c3 || "===" === b2 && a2 === c3 ? true : false) : true;
          }
          function c2(a2, b2) {
            var c3 = [], d2;
            if (q(a2) && !q(b2))
              c3 = u(a2, function(a3) {
                return x(a3, b2);
              });
            else if (q(b2) && !q(a2))
              c3 = u(b2, function(b3) {
                return x(a2, b3);
              });
            else if (q(a2) || q(b2))
              for (d2 = Math.max(
                a2.length,
                b2.length
              ); d2--; )
                c3[d2] = x(a2[d2], b2[d2]);
            else
              c3 = x(a2, b2);
            return c3;
          }
          var f2 = this, h2 = f2.chart, k2 = f2.options, p2 = k2.dataLabels, t2 = f2.points, m, y2 = f2.hasRendered || 0, A, F2 = w(p2.defer, !!k2.animation), E = h2.renderer, p2 = c2(c2(h2.options.plotOptions && h2.options.plotOptions.series && h2.options.plotOptions.series.dataLabels, h2.options.plotOptions && h2.options.plotOptions[f2.type] && h2.options.plotOptions[f2.type].dataLabels), p2);
          if (q(p2) || p2.enabled || f2._hasPointLabels)
            A = f2.plotGroup("dataLabelsGroup", "data-labels", F2 && !y2 ? "hidden" : "visible", p2.zIndex || 6), F2 && (A.attr({ opacity: +y2 }), y2 || C(f2, "afterAnimate", function() {
              f2.visible && A.show(true);
              A[k2.animation ? "animate" : "attr"]({ opacity: 1 }, { duration: 200 });
            })), n(t2, function(g) {
              m = d(c2(p2, g.dlOptions || g.options && g.options.dataLabels));
              n(m, function(c3, d2) {
                var l = c3.enabled && !g.isNull && b(g, c3), m2, n2, q2, r, p3 = g.dataLabels ? g.dataLabels[d2] : g.dataLabel, v = g.connectors ? g.connectors[d2] : g.connector, t3 = !p3;
                l && (m2 = g.getLabelConfig(), n2 = c3[g.formatPrefix + "Format"] || c3.format, m2 = I(n2) ? e(n2, m2, h2.time) : (c3[g.formatPrefix + "Formatter"] || c3.formatter).call(m2, c3), n2 = c3.style, q2 = c3.rotation, n2.color = w(c3.color, n2.color, f2.color, "#000000"), "contrast" === n2.color && (g.contrastColor = E.getContrast(g.color || f2.color), n2.color = c3.inside || 0 > w(c3.distance, g.labelDistance) || k2.stacking ? g.contrastColor : "#000000"), k2.cursor && (n2.cursor = k2.cursor), r = { fill: c3.backgroundColor, stroke: c3.borderColor, "stroke-width": c3.borderWidth, r: c3.borderRadius || 0, rotation: q2, padding: c3.padding, zIndex: 1 }, a.objectEach(r, function(a2, b2) {
                  void 0 === a2 && delete r[b2];
                }));
                !p3 || l && I(m2) ? l && I(m2) && (p3 ? r.text = m2 : (g.dataLabels = g.dataLabels || [], p3 = g.dataLabels[d2] = q2 ? E.text(m2, 0, -9999).addClass("highcharts-data-label") : E.label(m2, 0, -9999, c3.shape, null, null, c3.useHTML, null, "data-label"), d2 || (g.dataLabel = p3), p3.addClass(" highcharts-data-label-color-" + g.colorIndex + " " + (c3.className || "") + (c3.useHTML ? " highcharts-tracker" : ""))), p3.options = c3, p3.attr(r), p3.css(n2).shadow(c3.shadow), p3.added || p3.add(A), f2.alignDataLabel(g, p3, c3, null, t3)) : (g.dataLabel = g.dataLabel.destroy(), g.dataLabels && (1 === g.dataLabels.length ? delete g.dataLabels : delete g.dataLabels[d2]), d2 || delete g.dataLabel, v && (g.connector = g.connector.destroy(), g.connectors && (1 === g.connectors.length ? delete g.connectors : delete g.connectors[d2])));
              });
            });
          a.fireEvent(this, "afterDrawDataLabels");
        };
        c.prototype.alignDataLabel = function(a2, c2, d2, e2, h2) {
          var b = this.chart, l = b.inverted, m = w(a2.dlBox && a2.dlBox.centerX, a2.plotX, -9999), k2 = w(a2.plotY, -9999), n2 = c2.getBBox(), q2, p2 = d2.rotation, g = d2.align, r = this.visible && (a2.series.forceDL || b.isInsidePlot(m, Math.round(k2), l) || e2 && b.isInsidePlot(m, l ? e2.x + 1 : e2.y + e2.height - 1, l)), v = "justify" === w(d2.overflow, "justify");
          if (r && (q2 = d2.style.fontSize, q2 = b.renderer.fontMetrics(q2, c2).b, e2 = f({ x: l ? this.yAxis.len - k2 : m, y: Math.round(l ? this.xAxis.len - m : k2), width: 0, height: 0 }, e2), f(d2, { width: n2.width, height: n2.height }), p2 ? (v = false, m = b.renderer.rotCorr(q2, p2), m = { x: e2.x + d2.x + e2.width / 2 + m.x, y: e2.y + d2.y + { top: 0, middle: 0.5, bottom: 1 }[d2.verticalAlign] * e2.height }, c2[h2 ? "attr" : "animate"](m).attr({ align: g }), k2 = (p2 + 720) % 360, k2 = 180 < k2 && 360 > k2, "left" === g ? m.y -= k2 ? n2.height : 0 : "center" === g ? (m.x -= n2.width / 2, m.y -= n2.height / 2) : "right" === g && (m.x -= n2.width, m.y -= k2 ? 0 : n2.height), c2.placed = true, c2.alignAttr = m) : (c2.align(d2, null, e2), m = c2.alignAttr), v && 0 <= e2.height ? a2.isLabelJustified = this.justifyDataLabel(c2, d2, m, n2, e2, h2) : w(d2.crop, true) && (r = b.isInsidePlot(m.x, m.y) && b.isInsidePlot(m.x + n2.width, m.y + n2.height)), d2.shape && !p2))
            c2[h2 ? "attr" : "animate"]({ anchorX: l ? b.plotWidth - a2.plotY : a2.plotX, anchorY: l ? b.plotHeight - a2.plotX : a2.plotY });
          r || (c2.attr({ y: -9999 }), c2.placed = false);
        };
        c.prototype.justifyDataLabel = function(a2, c2, d2, e2, f2, h2) {
          var b = this.chart, l = c2.align, k2 = c2.verticalAlign, n2, q2, p2 = a2.box ? 0 : a2.padding || 0;
          n2 = d2.x + p2;
          0 > n2 && ("right" === l ? c2.align = "left" : c2.x = -n2, q2 = true);
          n2 = d2.x + e2.width - p2;
          n2 > b.plotWidth && ("left" === l ? c2.align = "right" : c2.x = b.plotWidth - n2, q2 = true);
          n2 = d2.y + p2;
          0 > n2 && ("bottom" === k2 ? c2.verticalAlign = "top" : c2.y = -n2, q2 = true);
          n2 = d2.y + e2.height - p2;
          n2 > b.plotHeight && ("top" === k2 ? c2.verticalAlign = "bottom" : c2.y = b.plotHeight - n2, q2 = true);
          q2 && (a2.placed = !h2, a2.align(c2, null, f2));
          return q2;
        };
        h.pie && (h.pie.prototype.drawDataLabels = function() {
          var b = this, d2 = b.data, e2, f2 = b.chart, h2 = b.options.dataLabels, k2 = w(h2.connectorPadding, 10), q2 = w(h2.connectorWidth, 1), m = f2.plotWidth, p2 = f2.plotHeight, t2 = Math.round(f2.chartWidth / 3), u2, x2 = b.center, g = x2[2] / 2, r = x2[1], y2, C2, H, K2, Q = [[], []], z, P, T, S2, U = [0, 0, 0, 0];
          b.visible && (h2.enabled || b._hasPointLabels) && (n(d2, function(a2) {
            a2.dataLabel && a2.visible && a2.dataLabel.shortened && (a2.dataLabel.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), a2.dataLabel.shortened = false);
          }), c.prototype.drawDataLabels.apply(b), n(d2, function(a2) {
            a2.dataLabel && (a2.visible ? (Q[a2.half].push(a2), a2.dataLabel._pos = null, !I(h2.style.width) && !I(a2.options.dataLabels && a2.options.dataLabels.style && a2.options.dataLabels.style.width) && a2.dataLabel.getBBox().width > t2 && (a2.dataLabel.css({ width: 0.7 * t2 }), a2.dataLabel.shortened = true)) : (a2.dataLabel = a2.dataLabel.destroy(), a2.dataLabels && 1 === a2.dataLabels.length && delete a2.dataLabels));
          }), n(Q, function(c2, d3) {
            var l, q3, t3 = c2.length, v = [], u3;
            if (t3)
              for (b.sortByAngle(c2, d3 - 0.5), 0 < b.maxLabelDistance && (l = Math.max(0, r - g - b.maxLabelDistance), q3 = Math.min(r + g + b.maxLabelDistance, f2.plotHeight), n(c2, function(a2) {
                0 < a2.labelDistance && a2.dataLabel && (a2.top = Math.max(0, r - g - a2.labelDistance), a2.bottom = Math.min(r + g + a2.labelDistance, f2.plotHeight), u3 = a2.dataLabel.getBBox().height || 21, a2.distributeBox = { target: a2.labelPos[1] - a2.top + u3 / 2, size: u3, rank: a2.y }, v.push(a2.distributeBox));
              }), l = q3 + u3 - l, a.distribute(v, l, l / 5)), S2 = 0; S2 < t3; S2++)
                e2 = c2[S2], H = e2.labelPos, y2 = e2.dataLabel, T = false === e2.visible ? "hidden" : "inherit", P = l = H[1], v && I(e2.distributeBox) && (void 0 === e2.distributeBox.pos ? T = "hidden" : (K2 = e2.distributeBox.size, P = e2.top + e2.distributeBox.pos)), delete e2.positionIndex, z = h2.justify ? x2[0] + (d3 ? -1 : 1) * (g + e2.labelDistance) : b.getX(P < e2.top + 2 || P > e2.bottom - 2 ? l : P, d3, e2), y2._attr = { visibility: T, align: H[6] }, y2._pos = { x: z + h2.x + ({ left: k2, right: -k2 }[H[6]] || 0), y: P + h2.y - 10 }, H.x = z, H.y = P, w(h2.crop, true) && (C2 = y2.getBBox().width, l = null, z - C2 < k2 && 1 === d3 ? (l = Math.round(C2 - z + k2), U[3] = Math.max(l, U[3])) : z + C2 > m - k2 && 0 === d3 && (l = Math.round(z + C2 - m + k2), U[1] = Math.max(l, U[1])), 0 > P - K2 / 2 ? U[0] = Math.max(Math.round(-P + K2 / 2), U[0]) : P + K2 / 2 > p2 && (U[2] = Math.max(Math.round(P + K2 / 2 - p2), U[2])), y2.sideOverflow = l);
          }), 0 === F(U) || this.verifyDataLabelOverflow(U)) && (this.placeDataLabels(), q2 && n(this.points, function(a2) {
            var c2;
            u2 = a2.connector;
            if ((y2 = a2.dataLabel) && y2._pos && a2.visible && 0 < a2.labelDistance) {
              T = y2._attr.visibility;
              if (c2 = !u2)
                a2.connector = u2 = f2.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a2.colorIndex + (a2.className ? " " + a2.className : "")).add(b.dataLabelsGroup), u2.attr({ "stroke-width": q2, stroke: h2.connectorColor || a2.color || "#666666" });
              u2[c2 ? "attr" : "animate"]({ d: b.connectorPath(a2.labelPos) });
              u2.attr("visibility", T);
            } else
              u2 && (a2.connector = u2.destroy());
          }));
        }, h.pie.prototype.connectorPath = function(a2) {
          var b = a2.x, c2 = a2.y;
          return w(
            this.options.dataLabels.softConnector,
            true
          ) ? ["M", b + ("left" === a2[6] ? 5 : -5), c2, "C", b, c2, 2 * a2[2] - a2[4], 2 * a2[3] - a2[5], a2[2], a2[3], "L", a2[4], a2[5]] : ["M", b + ("left" === a2[6] ? 5 : -5), c2, "L", a2[2], a2[3], "L", a2[4], a2[5]];
        }, h.pie.prototype.placeDataLabels = function() {
          n(this.points, function(a2) {
            var b = a2.dataLabel;
            b && a2.visible && ((a2 = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({ width: b._attr.width + "px", textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis" }), b.shortened = true), b.attr(b._attr), b[b.moved ? "animate" : "attr"](a2), b.moved = true) : b && b.attr({ y: -9999 }));
          }, this);
        }, h.pie.prototype.alignDataLabel = t, h.pie.prototype.verifyDataLabelOverflow = function(a2) {
          var b = this.center, c2 = this.options, d2 = c2.center, e2 = c2.minSize || 80, f2, h2 = null !== c2.size;
          h2 || (null !== d2[0] ? f2 = Math.max(b[2] - Math.max(a2[1], a2[3]), e2) : (f2 = Math.max(b[2] - a2[1] - a2[3], e2), b[0] += (a2[3] - a2[1]) / 2), null !== d2[1] ? f2 = Math.max(Math.min(f2, b[2] - Math.max(a2[0], a2[2])), e2) : (f2 = Math.max(Math.min(f2, b[2] - a2[0] - a2[2]), e2), b[1] += (a2[0] - a2[2]) / 2), f2 < b[2] ? (b[2] = f2, b[3] = Math.min(y(c2.innerSize || 0, f2), f2), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : h2 = true);
          return h2;
        });
        h.column && (h.column.prototype.alignDataLabel = function(a2, d2, e2, f2, h2) {
          var b = this.chart.inverted, l = a2.series, m = a2.dlBox || a2.shapeArgs, k2 = w(a2.below, a2.plotY > w(this.translatedThreshold, l.yAxis.len)), n2 = w(e2.inside, !!this.options.stacking);
          m && (f2 = x(m), 0 > f2.y && (f2.height += f2.y, f2.y = 0), m = f2.y + f2.height - l.yAxis.len, 0 < m && (f2.height -= m), b && (f2 = { x: l.yAxis.len - f2.y - f2.height, y: l.xAxis.len - f2.x - f2.width, width: f2.height, height: f2.width }), n2 || (b ? (f2.x += k2 ? 0 : f2.width, f2.width = 0) : (f2.y += k2 ? f2.height : 0, f2.height = 0)));
          e2.align = w(e2.align, !b || n2 ? "center" : k2 ? "right" : "left");
          e2.verticalAlign = w(e2.verticalAlign, b || n2 ? "middle" : k2 ? "top" : "bottom");
          c.prototype.alignDataLabel.call(this, a2, d2, e2, f2, h2);
          a2.isLabelJustified && a2.contrastColor && d2.css({ color: a2.contrastColor });
        });
      })(K);
      (function(a) {
        var C = a.Chart, F = a.each, I = a.isArray, n = a.objectEach, f = a.pick;
        a = a.addEvent;
        a(C, "render", function() {
          var a2 = [];
          F(this.labelCollectors || [], function(e) {
            a2 = a2.concat(e());
          });
          F(this.yAxis || [], function(e) {
            e.options.stackLabels && !e.options.stackLabels.allowOverlap && n(e.stacks, function(e2) {
              n(e2, function(e3) {
                a2.push(e3.label);
              });
            });
          });
          F(this.series || [], function(e) {
            var n2 = e.options.dataLabels;
            e.visible && (false !== n2.enabled || e._hasPointLabels) && F(e.points, function(e2) {
              if (e2.visible) {
                var n3 = I(e2.dataLabels) ? e2.dataLabels : e2.dataLabel ? [e2.dataLabel] : [];
                F(n3, function(n4) {
                  var c = n4.options;
                  n4.labelrank = f(c.labelrank, e2.labelrank, e2.shapeArgs && e2.shapeArgs.height);
                  c.allowOverlap || a2.push(n4);
                });
              }
            });
          });
          this.hideOverlappingLabels(a2);
        });
        C.prototype.hideOverlappingLabels = function(a2) {
          var e = a2.length, f2 = this.renderer, n2, w, y, c, h, p, k = function(a3, c2, b, e2, f3, h2, k2, n3) {
            return !(f3 > a3 + b || f3 + k2 < a3 || h2 > c2 + e2 || h2 + n3 < c2);
          };
          y = function(a3) {
            var c2, b, e2, h2 = a3.box ? 0 : a3.padding || 0;
            e2 = 0;
            if (a3 && (!a3.alignAttr || a3.placed))
              return c2 = a3.alignAttr || { x: a3.attr("x"), y: a3.attr("y") }, b = a3.parentGroup, a3.width || (e2 = a3.getBBox(), a3.width = e2.width, a3.height = e2.height, e2 = f2.fontMetrics(null, a3.element).h), { x: c2.x + (b.translateX || 0) + h2, y: c2.y + (b.translateY || 0) + h2 - e2, width: a3.width - 2 * h2, height: a3.height - 2 * h2 };
          };
          for (w = 0; w < e; w++)
            if (n2 = a2[w])
              n2.oldOpacity = n2.opacity, n2.newOpacity = 1, n2.absoluteBox = y(n2);
          a2.sort(function(a3, c2) {
            return (c2.labelrank || 0) - (a3.labelrank || 0);
          });
          for (w = 0; w < e; w++)
            for (p = (y = a2[w]) && y.absoluteBox, n2 = w + 1; n2 < e; ++n2)
              if (h = (c = a2[n2]) && c.absoluteBox, p && h && y !== c && 0 !== y.newOpacity && 0 !== c.newOpacity && (h = k(p.x, p.y, p.width, p.height, h.x, h.y, h.width, h.height)))
                (y.labelrank < c.labelrank ? y : c).newOpacity = 0;
          F(a2, function(a3) {
            var c2, b;
            a3 && (b = a3.newOpacity, a3.oldOpacity !== b && (a3.alignAttr && a3.placed ? (b ? a3.show(true) : c2 = function() {
              a3.hide();
            }, a3.alignAttr.opacity = b, a3[a3.isOld ? "animate" : "attr"](a3.alignAttr, null, c2)) : a3.attr({ opacity: b })), a3.isOld = true);
          });
        };
      })(K);
      (function(a) {
        var C = a.addEvent, F = a.Chart, I = a.createElement, n = a.css, f = a.defaultOptions, e = a.defaultPlotOptions, u = a.each, x = a.extend, t = a.fireEvent, w = a.hasTouch, y = a.inArray, c = a.isObject, h = a.Legend, p = a.merge, k = a.pick, q = a.Point, d = a.Series, b = a.seriesTypes, v = a.svg, J;
        J = a.TrackerMixin = { drawTrackerPoint: function() {
          var a2 = this, b2 = a2.chart.pointer, c2 = function(a3) {
            var c3 = b2.getPointFromEvent(a3);
            void 0 !== c3 && (b2.isDirectTouch = true, c3.onMouseOver(a3));
          };
          u(a2.points, function(a3) {
            a3.graphic && (a3.graphic.element.point = a3);
            a3.dataLabel && (a3.dataLabel.div ? a3.dataLabel.div.point = a3 : a3.dataLabel.element.point = a3);
          });
          a2._hasTracking || (u(a2.trackerGroups, function(d2) {
            if (a2[d2]) {
              a2[d2].addClass("highcharts-tracker").on("mouseover", c2).on("mouseout", function(a3) {
                b2.onTrackerMouseOut(a3);
              });
              if (w)
                a2[d2].on("touchstart", c2);
              a2.options.cursor && a2[d2].css(n).css({ cursor: a2.options.cursor });
            }
          }), a2._hasTracking = true);
          t(this, "afterDrawTracker");
        }, drawTrackerGraph: function() {
          var a2 = this, b2 = a2.options, c2 = b2.trackByArea, d2 = [].concat(c2 ? a2.areaPath : a2.graphPath), e2 = d2.length, f2 = a2.chart, h2 = f2.pointer, k2 = f2.renderer, n2 = f2.options.tooltip.snap, g = a2.tracker, q2, p2 = function() {
            if (f2.hoverSeries !== a2)
              a2.onMouseOver();
          }, x2 = "rgba(192,192,192," + (v ? 1e-4 : 2e-3) + ")";
          if (e2 && !c2)
            for (q2 = e2 + 1; q2--; )
              "M" === d2[q2] && d2.splice(q2 + 1, 0, d2[q2 + 1] - n2, d2[q2 + 2], "L"), (q2 && "M" === d2[q2] || q2 === e2) && d2.splice(q2, 0, "L", d2[q2 - 2] + n2, d2[q2 - 1]);
          g ? g.attr({ d: d2 }) : a2.graph && (a2.tracker = k2.path(d2).attr({ "stroke-linejoin": "round", stroke: x2, fill: c2 ? x2 : "none", "stroke-width": a2.graph.strokeWidth() + (c2 ? 0 : 2 * n2), visibility: a2.visible ? "visible" : "hidden", zIndex: 2 }).addClass(c2 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a2.group), u([a2.tracker, a2.markerGroup], function(a3) {
            a3.addClass("highcharts-tracker").on("mouseover", p2).on("mouseout", function(a4) {
              h2.onTrackerMouseOut(a4);
            });
            b2.cursor && a3.css({ cursor: b2.cursor });
            if (w)
              a3.on("touchstart", p2);
          }));
          t(this, "afterDrawTracker");
        } };
        b.column && (b.column.prototype.drawTracker = J.drawTrackerPoint);
        b.pie && (b.pie.prototype.drawTracker = J.drawTrackerPoint);
        b.scatter && (b.scatter.prototype.drawTracker = J.drawTrackerPoint);
        f.legend.itemStyle.cursor = "pointer";
        x(
          h.prototype,
          { setItemEvents: function(a2, b2, c2) {
            var d2 = this, e2 = d2.chart.renderer.boxWrapper, f2 = "highcharts-legend-" + (a2 instanceof q ? "point" : "series") + "-active";
            (c2 ? b2 : a2.legendGroup).on("mouseover", function() {
              a2.setState("hover");
              e2.addClass(f2);
              b2.css(d2.options.itemHoverStyle);
            }).on("mouseout", function() {
              b2.css(p(a2.visible ? d2.itemStyle : d2.itemHiddenStyle));
              e2.removeClass(f2);
              a2.setState();
            }).on("click", function(b3) {
              var c3 = function() {
                a2.setVisible && a2.setVisible();
              };
              e2.removeClass(f2);
              b3 = { browserEvent: b3 };
              a2.firePointEvent ? a2.firePointEvent(
                "legendItemClick",
                b3,
                c3
              ) : t(a2, "legendItemClick", b3, c3);
            });
          }, createCheckboxForItem: function(a2) {
            a2.checkbox = I("input", { type: "checkbox", className: "highcharts-legend-checkbox", checked: a2.selected, defaultChecked: a2.selected }, this.options.itemCheckboxStyle, this.chart.container);
            C(a2.checkbox, "click", function(b2) {
              t(a2.series || a2, "checkboxClick", { checked: b2.target.checked, item: a2 }, function() {
                a2.select();
              });
            });
          } }
        );
        x(F.prototype, { showResetZoom: function() {
          function a2() {
            b2.zoomOut();
          }
          var b2 = this, c2 = f.lang, d2 = b2.options.chart.resetZoomButton, e2 = d2.theme, h2 = e2.states, k2 = "chart" === d2.relativeTo ? null : "plotBox";
          t(this, "beforeShowResetZoom", null, function() {
            b2.resetZoomButton = b2.renderer.button(c2.resetZoom, null, null, a2, e2, h2 && h2.hover).attr({ align: d2.position.align, title: c2.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(d2.position, false, k2);
          });
        }, zoomOut: function() {
          t(this, "selection", { resetSelection: true }, this.zoom);
        }, zoom: function(a2) {
          var b2, d2 = this.pointer, e2 = false, f2;
          !a2 || a2.resetSelection ? (u(this.axes, function(a3) {
            b2 = a3.zoom();
          }), d2.initiated = false) : u(
            a2.xAxis.concat(a2.yAxis),
            function(a3) {
              var c2 = a3.axis;
              d2[c2.isXAxis ? "zoomX" : "zoomY"] && (b2 = c2.zoom(a3.min, a3.max), c2.displayBtn && (e2 = true));
            }
          );
          f2 = this.resetZoomButton;
          e2 && !f2 ? this.showResetZoom() : !e2 && c(f2) && (this.resetZoomButton = f2.destroy());
          b2 && this.redraw(k(this.options.chart.animation, a2 && a2.animation, 100 > this.pointCount));
        }, pan: function(a2, b2) {
          var c2 = this, d2 = c2.hoverPoints, e2;
          d2 && u(d2, function(a3) {
            a3.setState();
          });
          u("xy" === b2 ? [1, 0] : [1], function(b3) {
            b3 = c2[b3 ? "xAxis" : "yAxis"][0];
            var d3 = b3.horiz, f2 = a2[d3 ? "chartX" : "chartY"], d3 = d3 ? "mouseDownX" : "mouseDownY", h2 = c2[d3], g = (b3.pointRange || 0) / 2, l = b3.reversed && !c2.inverted || !b3.reversed && c2.inverted ? -1 : 1, m = b3.getExtremes(), k2 = b3.toValue(h2 - f2, true) + g * l, l = b3.toValue(h2 + b3.len - f2, true) - g * l, n2 = l < k2, h2 = n2 ? l : k2, k2 = n2 ? k2 : l, l = Math.min(m.dataMin, g ? m.min : b3.toValue(b3.toPixels(m.min) - b3.minPixelPadding)), g = Math.max(m.dataMax, g ? m.max : b3.toValue(b3.toPixels(m.max) + b3.minPixelPadding)), n2 = l - h2;
            0 < n2 && (k2 += n2, h2 = l);
            n2 = k2 - g;
            0 < n2 && (k2 = g, h2 -= n2);
            b3.series.length && h2 !== m.min && k2 !== m.max && (b3.setExtremes(h2, k2, false, false, { trigger: "pan" }), e2 = true);
            c2[d3] = f2;
          });
          e2 && c2.redraw(false);
          n(c2.container, { cursor: "move" });
        } });
        x(
          q.prototype,
          {
            select: function(a2, b2) {
              var c2 = this, d2 = c2.series, e2 = d2.chart;
              a2 = k(a2, !c2.selected);
              c2.firePointEvent(a2 ? "select" : "unselect", { accumulate: b2 }, function() {
                c2.selected = c2.options.selected = a2;
                d2.options.data[y(c2, d2.data)] = c2.options;
                c2.setState(a2 && "select");
                b2 || u(e2.getSelectedPoints(), function(a3) {
                  a3.selected && a3 !== c2 && (a3.selected = a3.options.selected = false, d2.options.data[y(a3, d2.data)] = a3.options, a3.setState(""), a3.firePointEvent("unselect"));
                });
              });
            },
            onMouseOver: function(a2) {
              var b2 = this.series.chart, c2 = b2.pointer;
              a2 = a2 ? c2.normalize(a2) : c2.getChartCoordinatesFromPoint(
                this,
                b2.inverted
              );
              c2.runPointActions(a2, this);
            },
            onMouseOut: function() {
              var a2 = this.series.chart;
              this.firePointEvent("mouseOut");
              u(a2.hoverPoints || [], function(a3) {
                a3.setState();
              });
              a2.hoverPoints = a2.hoverPoint = null;
            },
            importEvents: function() {
              if (!this.hasImportedEvents) {
                var b2 = this, c2 = p(b2.series.options.point, b2.options).events;
                b2.events = c2;
                a.objectEach(c2, function(a2, c3) {
                  C(b2, c3, a2);
                });
                this.hasImportedEvents = true;
              }
            },
            setState: function(a2, b2) {
              var c2 = Math.floor(this.plotX), d2 = this.plotY, f2 = this.series, h2 = f2.options.states[a2 || "normal"] || {}, l = e[f2.type].marker && f2.options.marker, n2 = l && false === l.enabled, q2 = l && l.states && l.states[a2 || "normal"] || {}, g = false === q2.enabled, p2 = f2.stateMarkerGraphic, v2 = this.marker || {}, u2 = f2.chart, w2 = f2.halo, y2, C2 = l && f2.markerAttribs;
              a2 = a2 || "";
              if (!(a2 === this.state && !b2 || this.selected && "select" !== a2 || false === h2.enabled || a2 && (g || n2 && false === q2.enabled) || a2 && v2.states && v2.states[a2] && false === v2.states[a2].enabled)) {
                C2 && (y2 = f2.markerAttribs(this, a2));
                if (this.graphic)
                  this.state && this.graphic.removeClass("highcharts-point-" + this.state), a2 && this.graphic.addClass("highcharts-point-" + a2), this.graphic.animate(f2.pointAttribs(this, a2), k(u2.options.chart.animation, h2.animation)), y2 && this.graphic.animate(y2, k(u2.options.chart.animation, q2.animation, l.animation)), p2 && p2.hide();
                else {
                  if (a2 && q2) {
                    l = v2.symbol || f2.symbol;
                    p2 && p2.currentSymbol !== l && (p2 = p2.destroy());
                    if (p2)
                      p2[b2 ? "animate" : "attr"]({ x: y2.x, y: y2.y });
                    else
                      l && (f2.stateMarkerGraphic = p2 = u2.renderer.symbol(l, y2.x, y2.y, y2.width, y2.height).add(f2.markerGroup), p2.currentSymbol = l);
                    p2 && p2.attr(f2.pointAttribs(this, a2));
                  }
                  p2 && (p2[a2 && u2.isInsidePlot(c2, d2, u2.inverted) ? "show" : "hide"](), p2.element.point = this);
                }
                (c2 = h2.halo) && c2.size ? (w2 || (f2.halo = w2 = u2.renderer.path().add((this.graphic || p2).parentGroup)), w2.show()[b2 ? "animate" : "attr"]({ d: this.haloPath(c2.size) }), w2.attr({ "class": "highcharts-halo highcharts-color-" + k(this.colorIndex, f2.colorIndex) + (this.className ? " " + this.className : ""), zIndex: -1 }), w2.point = this, w2.attr(x({ fill: this.color || f2.color, "fill-opacity": c2.opacity }, c2.attributes))) : w2 && w2.point && w2.point.haloPath && w2.animate({ d: w2.point.haloPath(0) }, null, w2.hide);
                this.state = a2;
                t(this, "afterSetState");
              }
            },
            haloPath: function(a2) {
              return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a2, this.plotY - a2, 2 * a2, 2 * a2);
            }
          }
        );
        x(d.prototype, { onMouseOver: function() {
          var a2 = this.chart, b2 = a2.hoverSeries;
          if (b2 && b2 !== this)
            b2.onMouseOut();
          this.options.events.mouseOver && t(this, "mouseOver");
          this.setState("hover");
          a2.hoverSeries = this;
        }, onMouseOut: function() {
          var a2 = this.options, b2 = this.chart, c2 = b2.tooltip, d2 = b2.hoverPoint;
          b2.hoverSeries = null;
          if (d2)
            d2.onMouseOut();
          this && a2.events.mouseOut && t(this, "mouseOut");
          !c2 || this.stickyTracking || c2.shared && !this.noSharedTooltip || c2.hide();
          this.setState();
        }, setState: function(a2) {
          var b2 = this, c2 = b2.options, d2 = b2.graph, e2 = c2.states, f2 = c2.lineWidth, c2 = 0;
          a2 = a2 || "";
          if (b2.state !== a2 && (u([b2.group, b2.markerGroup, b2.dataLabelsGroup], function(c3) {
            c3 && (b2.state && c3.removeClass("highcharts-series-" + b2.state), a2 && c3.addClass("highcharts-series-" + a2));
          }), b2.state = a2, !e2[a2] || false !== e2[a2].enabled) && (a2 && (f2 = e2[a2].lineWidth || f2 + (e2[a2].lineWidthPlus || 0)), d2 && !d2.dashstyle))
            for (f2 = { "stroke-width": f2 }, d2.animate(f2, k(
              e2[a2 || "normal"] && e2[a2 || "normal"].animation,
              b2.chart.options.chart.animation
            )); b2["zone-graph-" + c2]; )
              b2["zone-graph-" + c2].attr(f2), c2 += 1;
        }, setVisible: function(a2, b2) {
          var c2 = this, d2 = c2.chart, e2 = c2.legendItem, f2, h2 = d2.options.chart.ignoreHiddenSeries, k2 = c2.visible;
          f2 = (c2.visible = a2 = c2.options.visible = c2.userOptions.visible = void 0 === a2 ? !k2 : a2) ? "show" : "hide";
          u(["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"], function(a3) {
            if (c2[a3])
              c2[a3][f2]();
          });
          if (d2.hoverSeries === c2 || (d2.hoverPoint && d2.hoverPoint.series) === c2)
            c2.onMouseOut();
          e2 && d2.legend.colorizeItem(c2, a2);
          c2.isDirty = true;
          c2.options.stacking && u(d2.series, function(a3) {
            a3.options.stacking && a3.visible && (a3.isDirty = true);
          });
          u(c2.linkedSeries, function(b3) {
            b3.setVisible(a2, false);
          });
          h2 && (d2.isDirtyBox = true);
          t(c2, f2);
          false !== b2 && d2.redraw();
        }, show: function() {
          this.setVisible(true);
        }, hide: function() {
          this.setVisible(false);
        }, select: function(a2) {
          this.selected = a2 = void 0 === a2 ? !this.selected : a2;
          this.checkbox && (this.checkbox.checked = a2);
          t(this, a2 ? "select" : "unselect");
        }, drawTracker: J.drawTrackerGraph });
      })(K);
      (function(a) {
        var C = a.Chart, F = a.each, I = a.inArray, n = a.isArray, f = a.isObject, e = a.pick, u = a.splat;
        C.prototype.setResponsive = function(e2) {
          var f2 = this.options.responsive, n2 = [], u2 = this.currentResponsive;
          f2 && f2.rules && F(f2.rules, function(c2) {
            void 0 === c2._id && (c2._id = a.uniqueKey());
            this.matchResponsiveRule(c2, n2, e2);
          }, this);
          var c = a.merge.apply(0, a.map(n2, function(c2) {
            return a.find(f2.rules, function(a2) {
              return a2._id === c2;
            }).chartOptions;
          })), n2 = n2.toString() || void 0;
          n2 !== (u2 && u2.ruleIds) && (u2 && this.update(u2.undoOptions, e2), n2 ? (this.currentResponsive = { ruleIds: n2, mergedOptions: c, undoOptions: this.currentOptions(c) }, this.update(c, e2)) : this.currentResponsive = void 0);
        };
        C.prototype.matchResponsiveRule = function(a2, f2) {
          var n2 = a2.condition;
          (n2.callback || function() {
            return this.chartWidth <= e(n2.maxWidth, Number.MAX_VALUE) && this.chartHeight <= e(n2.maxHeight, Number.MAX_VALUE) && this.chartWidth >= e(n2.minWidth, 0) && this.chartHeight >= e(n2.minHeight, 0);
          }).call(this) && f2.push(a2._id);
        };
        C.prototype.currentOptions = function(e2) {
          function t(e3, c, h, p) {
            var k;
            a.objectEach(e3, function(a2, d) {
              if (!p && -1 < I(d, ["series", "xAxis", "yAxis"]))
                for (a2 = u(a2), h[d] = [], k = 0; k < a2.length; k++)
                  c[d][k] && (h[d][k] = {}, t(a2[k], c[d][k], h[d][k], p + 1));
              else
                f(a2) ? (h[d] = n(a2) ? [] : {}, t(a2, c[d] || {}, h[d], p + 1)) : h[d] = c[d] || null;
            });
          }
          var w = {};
          t(e2, this.options, w, 0);
          return w;
        };
      })(K);
      return K;
    });
  }
});

// node_modules/react-highcharts/dist/ReactHighcharts.js
var require_ReactHighcharts = __commonJS({
  "node_modules/react-highcharts/dist/ReactHighcharts.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(require_react(), require_highcharts()) : "function" == typeof define && define.amd ? define(["react", "highcharts"], e) : "object" == typeof exports ? exports.ReactHighcharts = e(require_react(), require_highcharts()) : t.ReactHighcharts = e(t.React, t.Highcharts);
    }("undefined" != typeof self ? self : exports, function(t, e) {
      return function(t2) {
        var e2 = {};
        function r(n) {
          if (e2[n])
            return e2[n].exports;
          var o = e2[n] = { i: n, l: false, exports: {} };
          return t2[n].call(o.exports, o, o.exports, r), o.l = true, o.exports;
        }
        return r.m = t2, r.c = e2, r.d = function(t3, e3, n) {
          r.o(t3, e3) || Object.defineProperty(t3, e3, { configurable: false, enumerable: true, get: n });
        }, r.n = function(t3) {
          var e3 = t3 && t3.__esModule ? function() {
            return t3.default;
          } : function() {
            return t3;
          };
          return r.d(e3, "a", e3), e3;
        }, r.o = function(t3, e3) {
          return Object.prototype.hasOwnProperty.call(t3, e3);
        }, r.p = "", r(r.s = 4);
      }([function(e2, r) {
        e2.exports = t;
      }, function(t2, e2, r) {
        "use strict";
        (function(n) {
          Object.defineProperty(e2, "__esModule", { value: true });
          var o, i = Object.assign || function(t3) {
            for (var e3 = 1; e3 < arguments.length; e3++) {
              var r2 = arguments[e3];
              for (var n2 in r2)
                Object.prototype.hasOwnProperty.call(r2, n2) && (t3[n2] = r2[n2]);
            }
            return t3;
          }, a = function() {
            function t3(t4, e3) {
              for (var r2 = 0; r2 < e3.length; r2++) {
                var n2 = e3[r2];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, n2.key, n2);
              }
            }
            return function(e3, r2, n2) {
              return r2 && t3(e3.prototype, r2), n2 && t3(e3, n2), e3;
            };
          }(), c = r(0), u = (o = c) && o.__esModule ? o : { default: o };
          var s = void 0 === n ? window : n;
          e2.default = function(e3, r2) {
            var n2 = function(t3) {
              function n3() {
                !function(t5, e4) {
                  if (!(t5 instanceof e4))
                    throw new TypeError("Cannot call a class as a function");
                }(this, n3);
                var t4 = function(t5, e4) {
                  if (!t5)
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return !e4 || "object" != typeof e4 && "function" != typeof e4 ? t5 : e4;
                }(this, (n3.__proto__ || Object.getPrototypeOf(n3)).call(this));
                return t4.chartType = e3, t4.Highcharts = r2, t4.displayName = "Highcharts" + e3, t4;
              }
              return function(t4, e4) {
                if ("function" != typeof e4 && null !== e4)
                  throw new TypeError("Super expression must either be null or a function, not " + typeof e4);
                t4.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t4, enumerable: false, writable: true, configurable: true } }), e4 && (Object.setPrototypeOf ? Object.setPrototypeOf(t4, e4) : t4.__proto__ = e4);
              }(n3, c.Component), a(n3, [{ key: "setChartRef", value: function(t4) {
                this.chartRef = t4;
              } }, { key: "renderChart", value: function(t4) {
                var e4 = this;
                if (!t4)
                  throw new Error("Config must be specified for the " + this.displayName + " component");
                var r3 = t4.chart;
                this.chart && this.chart.destroy(), this.chart = new this.Highcharts[this.chartType](i({}, t4, { chart: i({}, r3, { renderTo: this.chartRef }) }), this.props.callback), this.props.neverReflow || s && s.requestAnimationFrame && requestAnimationFrame(function() {
                  e4.chart && e4.chart.options && e4.chart.reflow();
                });
              } }, { key: "shouldComponentUpdate", value: function(t4) {
                return !!(t4.neverReflow || t4.isPureConfig && this.props.config === t4.config) || (this.renderChart(t4.config), false);
              } }, { key: "getChart", value: function() {
                if (!this.chart)
                  throw new Error("getChart() should not be called before the component is mounted");
                return this.chart;
              } }, { key: "componentDidMount", value: function() {
                this.renderChart(this.props.config);
              } }, { key: "componentWillUnmount", value: function() {
                this.chart.destroy();
              } }, { key: "render", value: function() {
                return u.default.createElement("div", i({ ref: this.setChartRef.bind(this) }, this.props.domProps));
              } }]), n3;
            }();
            n2.defaultProps = { callback: function() {
            }, domProps: {} };
            var o2 = n2;
            return o2.Highcharts = r2, o2.withHighcharts = function(r3) {
              return t2.exports(e3, r3);
            }, o2;
          }, t2.exports = e2.default;
        }).call(e2, r(2));
      }, function(t2, e2) {
        var r;
        r = function() {
          return this;
        }();
        try {
          r = r || Function("return this")() || (0, eval)("this");
        } catch (t3) {
          "object" == typeof window && (r = window);
        }
        t2.exports = r;
      }, , function(t2, e2, r) {
        t2.exports = r(5);
      }, function(t2, e2, r) {
        "use strict";
        Object.defineProperty(e2, "__esModule", { value: true });
        var n = i(r(1)), o = i(r(6));
        function i(t3) {
          return t3 && t3.__esModule ? t3 : { default: t3 };
        }
        e2.default = (0, n.default)("Chart", o.default), t2.exports = e2.default;
      }, function(t2, r) {
        t2.exports = e;
      }]);
    });
  }
});
export default require_ReactHighcharts();
//# sourceMappingURL=react-highcharts.js.map
