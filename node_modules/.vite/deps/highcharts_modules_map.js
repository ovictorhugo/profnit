import {
  __commonJS
} from "./chunk-TFWDKVI3.js";

// node_modules/highcharts/modules/map.js
var require_map = __commonJS({
  "node_modules/highcharts/modules/map.js"(exports, module) {
    (function(a) {
      "object" === typeof module && module.exports ? (a["default"] = a, module.exports = a) : "function" === typeof define && define.amd ? define("highcharts/modules/map", ["highcharts"], function(y) {
        a(y);
        a.Highcharts = y;
        return a;
      }) : a("undefined" !== typeof Highcharts ? Highcharts : void 0);
    })(function(a) {
      function y(a2, n, q, z) {
        a2.hasOwnProperty(n) || (a2[n] = z.apply(null, q), "function" === typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: n, module: a2[n] } })));
      }
      a = a ? a._modules : {};
      y(a, "Core/Axis/Color/ColorAxisComposition.js", [a["Core/Color/Color.js"], a["Core/Utilities.js"]], function(a2, n) {
        const { parse: q } = a2, { addEvent: g, extend: k, merge: l, pick: A, splat: w } = n;
        var x;
        (function(t) {
          function h() {
            const b2 = this.options;
            this.colorAxis = [];
            b2.colorAxis && (b2.colorAxis = w(b2.colorAxis), b2.colorAxis.forEach((b3) => {
              new v(this, b3);
            }));
          }
          function a3(b2) {
            const u = (u2) => {
              u2 = b2.allItems.indexOf(u2);
              -1 !== u2 && (this.destroyItem(b2.allItems[u2]), b2.allItems.splice(u2, 1));
            };
            let d2 = [], p2, e2;
            (this.chart.colorAxis || []).forEach(function(b3) {
              (p2 = b3.options) && p2.showInLegend && (p2.dataClasses && p2.visible ? d2 = d2.concat(b3.getDataClassLegendSymbols()) : p2.visible && d2.push(b3), b3.series.forEach(function(b4) {
                if (!b4.options.showInLegend || p2.dataClasses)
                  "point" === b4.options.legendType ? b4.points.forEach(function(b5) {
                    u(b5);
                  }) : u(b4);
              }));
            });
            for (e2 = d2.length; e2--; )
              b2.allItems.unshift(d2[e2]);
          }
          function f(b2) {
            b2.visible && b2.item.legendColor && b2.item.legendItem.symbol.attr({ fill: b2.item.legendColor });
          }
          function c() {
            const b2 = this.chart.colorAxis;
            b2 && b2.forEach(function(b3, d2, p2) {
              b3.update({}, p2);
            });
          }
          function e() {
            (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();
          }
          function b() {
            const b2 = this.axisTypes;
            b2 ? -1 === b2.indexOf("colorAxis") && b2.push("colorAxis") : this.axisTypes = ["colorAxis"];
          }
          function d(b2) {
            const u = this, d2 = b2 ? "show" : "hide";
            u.visible = u.options.visible = !!b2;
            ["graphic", "dataLabel"].forEach(function(b3) {
              if (u[b3])
                u[b3][d2]();
            });
            this.series.buildKDTree();
          }
          function E() {
            const b2 = this, u = this.options.nullColor, d2 = this.colorAxis, p2 = this.colorKey;
            (this.data.length ? this.data : this.points).forEach((e2) => {
              var c2 = e2.getNestedProperty(p2);
              (c2 = e2.options.color || (e2.isNull || null === e2.value ? u : d2 && "undefined" !== typeof c2 ? d2.toColor(c2, e2) : e2.color || b2.color)) && e2.color !== c2 && (e2.color = c2, "point" === b2.options.legendType && e2.legendItem && e2.legendItem.label && b2.chart.legend.colorizeItem(e2, e2.visible));
            });
          }
          function p(b2) {
            const u = b2.prototype.createAxis;
            b2.prototype.createAxis = function(b3, d2) {
              if ("colorAxis" !== b3)
                return u.apply(this, arguments);
              const e2 = new v(this, l(d2.axis, { index: this[b3].length, isX: false }));
              this.isDirtyLegend = true;
              this.axes.forEach(function(b4) {
                b4.series = [];
              });
              this.series.forEach(function(b4) {
                b4.bindAxes();
                b4.isDirtyData = true;
              });
              A(d2.redraw, true) && this.redraw(d2.animation);
              return e2;
            };
          }
          function C() {
            this.elem.attr("fill", q(this.start).tweenTo(q(this.end), this.pos), void 0, true);
          }
          function m() {
            this.elem.attr("stroke", q(this.start).tweenTo(q(this.end), this.pos), void 0, true);
          }
          const r = [];
          let v;
          t.compose = function(t2, u, B, D, H) {
            v || (v = t2);
            n.pushUnique(r, u) && (t2 = u.prototype, t2.collectionsWithUpdate.push("colorAxis"), t2.collectionsWithInit.colorAxis = [t2.addColorAxis], g(u, "afterGetAxes", h), p(u));
            n.pushUnique(r, B) && (u = B.prototype, u.fillSetter = C, u.strokeSetter = m);
            n.pushUnique(r, D) && (g(D, "afterGetAllItems", a3), g(D, "afterColorizeItem", f), g(D, "afterUpdate", c));
            n.pushUnique(r, H) && (k(H.prototype, { optionalAxis: "colorAxis", translateColors: E }), k(H.prototype.pointClass.prototype, { setVisible: d }), g(H, "afterTranslate", e, { order: 1 }), g(H, "bindAxes", b));
          };
          t.pointSetVisible = d;
        })(x || (x = {}));
        return x;
      });
      y(a, "Core/Axis/Color/ColorAxisDefaults.js", [], function() {
        return {
          lineWidth: 0,
          minPadding: 0,
          maxPadding: 0,
          gridLineColor: "#ffffff",
          gridLineWidth: 1,
          tickPixelInterval: 72,
          startOnTick: true,
          endOnTick: true,
          offset: 0,
          marker: { animation: { duration: 50 }, width: 0.01, color: "#999999" },
          labels: { distance: 8, overflow: "justify", rotation: 0 },
          minColor: "#e6e9ff",
          maxColor: "#0022ff",
          tickLength: 5,
          showInLegend: true
        };
      });
      y(
        a,
        "Core/Axis/Color/ColorAxis.js",
        [a["Core/Axis/Axis.js"], a["Core/Color/Color.js"], a["Core/Axis/Color/ColorAxisComposition.js"], a["Core/Axis/Color/ColorAxisDefaults.js"], a["Core/Legend/LegendSymbol.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]],
        function(a2, n, q, z, k, l, A) {
          const { parse: g } = n, { series: x } = l, { extend: t, isArray: h, isNumber: F, merge: f, pick: c } = A;
          class e extends a2 {
            static compose(b, d, c2, p) {
              q.compose(e, b, d, c2, p);
            }
            constructor(b, d) {
              super(b, d);
              this.beforePadding = false;
              this.chart = void 0;
              this.coll = "colorAxis";
              this.stops = this.options = this.dataClasses = void 0;
              this.visible = true;
              this.init(b, d);
            }
            init(b, d) {
              var c2 = b.options.legend || {};
              const p = d.layout ? "vertical" !== d.layout : "vertical" !== c2.layout, C = d.visible;
              c2 = f(e.defaultColorAxisOptions, d, {
                showEmpty: false,
                title: null,
                visible: c2.enabled && false !== C
              });
              this.side = d.side || p ? 2 : 1;
              this.reversed = d.reversed || !p;
              this.opposite = !p;
              super.init(b, c2, "colorAxis");
              this.userOptions = d;
              h(b.userOptions.colorAxis) && (b.userOptions.colorAxis[this.index] = d);
              d.dataClasses && this.initDataClasses(d);
              this.initStops();
              this.horiz = p;
              this.zoomEnabled = false;
            }
            initDataClasses(b) {
              const d = this.chart, e2 = this.legendItem = this.legendItem || {}, p = b.dataClasses.length, c2 = this.options;
              let m, r = 0, v = d.options.chart.colorCount;
              this.dataClasses = m = [];
              e2.labels = [];
              (b.dataClasses || []).forEach(function(b2, u) {
                b2 = f(b2);
                m.push(b2);
                if (d.styledMode || !b2.color)
                  "category" === c2.dataClassColor ? (d.styledMode || (u = d.options.colors, v = u.length, b2.color = u[r]), b2.colorIndex = r, r++, r === v && (r = 0)) : b2.color = g(c2.minColor).tweenTo(g(c2.maxColor), 2 > p ? 0.5 : u / (p - 1));
              });
            }
            hasData() {
              return !!(this.tickPositions || []).length;
            }
            setTickPositions() {
              if (!this.dataClasses)
                return super.setTickPositions();
            }
            initStops() {
              this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];
              this.stops.forEach(function(b) {
                b.color = g(b[1]);
              });
            }
            setOptions(b) {
              super.setOptions(b);
              this.options.crosshair = this.options.marker;
            }
            setAxisSize() {
              var b = this.legendItem && this.legendItem.symbol;
              const d = this.chart;
              var c2 = d.options.legend || {};
              let p, f2;
              b ? (this.left = c2 = b.attr("x"), this.top = p = b.attr("y"), this.width = f2 = b.attr("width"), this.height = b = b.attr("height"), this.right = d.chartWidth - c2 - f2, this.bottom = d.chartHeight - p - b, this.len = this.horiz ? f2 : b, this.pos = this.horiz ? c2 : p) : this.len = (this.horiz ? c2.symbolWidth : c2.symbolHeight) || e.defaultLegendLength;
            }
            normalizedValue(b) {
              this.logarithmic && (b = this.logarithmic.log2lin(b));
              return 1 - (this.max - b) / (this.max - this.min || 1);
            }
            toColor(b, d) {
              const e2 = this.dataClasses;
              var c2 = this.stops;
              let f2, m, r, v;
              if (e2)
                for (v = e2.length; v--; ) {
                  if (r = e2[v], f2 = r.from, c2 = r.to, ("undefined" === typeof f2 || b >= f2) && ("undefined" === typeof c2 || b <= c2)) {
                    m = r.color;
                    d && (d.dataClass = v, d.colorIndex = r.colorIndex);
                    break;
                  }
                }
              else {
                b = this.normalizedValue(b);
                for (v = c2.length; v-- && !(b > c2[v][0]); )
                  ;
                f2 = c2[v] || c2[v + 1];
                c2 = c2[v + 1] || f2;
                b = 1 - (c2[0] - b) / (c2[0] - f2[0] || 1);
                m = f2.color.tweenTo(c2.color, b);
              }
              return m;
            }
            getOffset() {
              const b = this.legendItem && this.legendItem.group, d = this.chart.axisOffset[this.side];
              if (b) {
                this.axisParent = b;
                super.getOffset();
                const c2 = this.chart.legend;
                c2.allItems.forEach(function(b2) {
                  b2 instanceof e && b2.drawLegendSymbol(c2, b2);
                });
                c2.render();
                this.chart.getMargins(true);
                this.added || (this.added = true, this.labelLeft = 0, this.labelRight = this.width);
                this.chart.axisOffset[this.side] = d;
              }
            }
            setLegendColor() {
              var b = this.reversed, d = b ? 1 : 0;
              b = b ? 0 : 1;
              d = this.horiz ? [d, 0, b, 0] : [0, b, 0, d];
              this.legendColor = { linearGradient: {
                x1: d[0],
                y1: d[1],
                x2: d[2],
                y2: d[3]
              }, stops: this.stops };
            }
            drawLegendSymbol(b, d) {
              var f2;
              d = d.legendItem || {};
              const p = b.padding, h2 = b.options, m = this.options.labels, r = c(h2.itemDistance, 10), v = this.horiz, t2 = c(h2.symbolWidth, v ? e.defaultLegendLength : 12), u = c(h2.symbolHeight, v ? 12 : e.defaultLegendLength), B = c(h2.labelPadding, v ? 16 : 30);
              this.setLegendColor();
              d.symbol || (d.symbol = this.chart.renderer.symbol("roundedRect", 0, b.baseline - 11, t2, u, { r: null !== (f2 = h2.symbolRadius) && void 0 !== f2 ? f2 : 3 }).attr({ zIndex: 1 }).add(d.group));
              d.labelWidth = t2 + p + (v ? r : c(m.x, m.distance) + this.maxLabelLength);
              d.labelHeight = u + p + (v ? B : 0);
            }
            setState(b) {
              this.series.forEach(function(d) {
                d.setState(b);
              });
            }
            setVisible() {
            }
            getSeriesExtremes() {
              const b = this.series;
              let d;
              let e2, p, f2 = b.length, m, r;
              this.dataMin = Infinity;
              for (this.dataMax = -Infinity; f2--; ) {
                p = b[f2];
                d = p.colorKey = c(p.options.colorKey, p.colorKey, p.pointValKey, p.zoneAxis, "y");
                var v = p.pointArrayMap;
                e2 = p[d + "Min"] && p[d + "Max"];
                if (p[d + "Data"])
                  var h2 = p[d + "Data"];
                else if (v) {
                  if (h2 = [], v = v.indexOf(d), m = p.yData, 0 <= v && m)
                    for (r = 0; r < m.length; r++)
                      h2.push(c(m[r][v], m[r]));
                } else
                  h2 = p.yData;
                e2 ? (p.minColorValue = p[d + "Min"], p.maxColorValue = p[d + "Max"]) : (h2 = x.prototype.getExtremes.call(p, h2), p.minColorValue = h2.dataMin, p.maxColorValue = h2.dataMax);
                "undefined" !== typeof p.minColorValue && (this.dataMin = Math.min(this.dataMin, p.minColorValue), this.dataMax = Math.max(this.dataMax, p.maxColorValue));
                e2 || x.prototype.applyExtremes.call(p);
              }
            }
            drawCrosshair(b, d) {
              const c2 = this.legendItem || {}, e2 = d && d.plotX, f2 = d && d.plotY, m = this.pos, h2 = this.len;
              let v;
              d && (v = this.toPixels(d.getNestedProperty(d.series.colorKey)), v < m ? v = m - 2 : v > m + h2 && (v = m + h2 + 2), d.plotX = v, d.plotY = this.len - v, super.drawCrosshair(b, d), d.plotX = e2, d.plotY = f2, this.cross && !this.cross.addedToColorAxis && c2.group && (this.cross.addClass("highcharts-coloraxis-marker").add(c2.group), this.cross.addedToColorAxis = true, this.chart.styledMode || "object" !== typeof this.crosshair || this.cross.attr({ fill: this.crosshair.color })));
            }
            getPlotLinePath(b) {
              const d = this.left, c2 = b.translatedValue, e2 = this.top;
              return F(c2) ? this.horiz ? [["M", c2 - 4, e2 - 6], ["L", c2 + 4, e2 - 6], ["L", c2, e2], ["Z"]] : [["M", d, c2], [
                "L",
                d - 6,
                c2 + 6
              ], ["L", d - 6, c2 - 6], ["Z"]] : super.getPlotLinePath(b);
            }
            update(b, d) {
              const c2 = this.chart.legend;
              this.series.forEach((b2) => {
                b2.isDirtyData = true;
              });
              (b.dataClasses && c2.allItems || this.dataClasses) && this.destroyItems();
              super.update(b, d);
              this.legendItem && this.legendItem.label && (this.setLegendColor(), c2.colorizeItem(this, true));
            }
            destroyItems() {
              const b = this.chart, d = this.legendItem || {};
              if (d.label)
                b.legend.destroyItem(this);
              else if (d.labels)
                for (const c2 of d.labels)
                  b.legend.destroyItem(c2);
              b.isDirtyLegend = true;
            }
            destroy() {
              this.chart.isDirtyLegend = true;
              this.destroyItems();
              super.destroy(...[].slice.call(arguments));
            }
            remove(b) {
              this.destroyItems();
              super.remove(b);
            }
            getDataClassLegendSymbols() {
              const b = this, d = b.chart, e2 = b.legendItem && b.legendItem.labels || [], f2 = d.options.legend, h2 = c(f2.valueDecimals, -1), m = c(f2.valueSuffix, ""), r = (d2) => b.series.reduce((b2, c2) => {
                b2.push(...c2.points.filter((b3) => b3.dataClass === d2));
                return b2;
              }, []);
              let v;
              e2.length || b.dataClasses.forEach((c2, u) => {
                const f3 = c2.from, p = c2.to, { numberFormatter: a3 } = d;
                let C = true;
                v = "";
                "undefined" === typeof f3 ? v = "< " : "undefined" === typeof p && (v = "> ");
                "undefined" !== typeof f3 && (v += a3(f3, h2) + m);
                "undefined" !== typeof f3 && "undefined" !== typeof p && (v += " - ");
                "undefined" !== typeof p && (v += a3(p, h2) + m);
                e2.push(t({ chart: d, name: v, options: {}, drawLegendSymbol: k.rectangle, visible: true, isDataClass: true, setState: (b2) => {
                  for (const c3 of r(u))
                    c3.setState(b2);
                }, setVisible: function() {
                  this.visible = C = b.visible = !C;
                  for (const b2 of r(u))
                    b2.setVisible(C);
                  d.legend.colorizeItem(this, C);
                } }, c2));
              });
              return e2;
            }
          }
          e.defaultColorAxisOptions = z;
          e.defaultLegendLength = 200;
          e.keepProps = ["legendItem"];
          Array.prototype.push.apply(a2.keepProps, e.keepProps);
          "";
          return e;
        }
      );
      y(a, "Maps/MapNavigationDefaults.js", [a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, n) {
        ({ extend: n } = n);
        const g = { buttonOptions: { alignTo: "plotBox", align: "left", verticalAlign: "top", x: 0, width: 18, height: 18, padding: 5, style: { color: "#666666", fontSize: "1em", fontWeight: "bold" }, theme: { fill: "#ffffff", stroke: "#e6e6e6", "stroke-width": 1, "text-align": "center" } }, buttons: { zoomIn: { onclick: function() {
          this.mapZoom(0.5);
        }, text: "+", y: 0 }, zoomOut: {
          onclick: function() {
            this.mapZoom(2);
          },
          text: "-",
          y: 28
        } }, mouseWheelSensitivity: 1.1 };
        n(a2.defaultOptions.lang, { zoomIn: "Zoom in", zoomOut: "Zoom out" });
        return a2.defaultOptions.mapNavigation = g;
      });
      y(a, "Maps/MapNavigation.js", [a["Core/Chart/Chart.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, n, q) {
        function g(f) {
          f && (f.preventDefault && f.preventDefault(), f.stopPropagation && f.stopPropagation(), f.cancelBubble = true);
        }
        function k(f) {
          this.navButtons = [];
          this.init(f);
        }
        const { doc: l } = n, { addEvent: A, extend: w, isNumber: x, merge: t, objectEach: h, pick: F } = q;
        k.prototype.init = function(f) {
          this.chart = f;
        };
        k.prototype.update = function(f) {
          let c = this, e = this.chart, b = e.options.mapNavigation, d, a3 = function(b2) {
            this.handler.call(e, b2);
            g(b2);
          }, p = c.navButtons;
          f && (b = e.options.mapNavigation = t(e.options.mapNavigation, f));
          for (; p.length; )
            p.pop().destroy();
          F(b.enableButtons, b.enabled) && !e.renderer.forExport && (c.navButtonsGroup || (c.navButtonsGroup = e.renderer.g().attr({ zIndex: 4 }).add()), h(b.buttons, function(f2, m) {
            var h2;
            f2 = t(b.buttonOptions, f2);
            !e.styledMode && f2.theme && (d = f2.theme, d.style = t(f2.theme.style, f2.style));
            const { text: v, width: E = 0, height: u = 0, padding: B = 0 } = f2, D = e.renderer.button("+" !== v && "-" !== v && v || "", 0, 0, a3, d, void 0, void 0, void 0, "zoomIn" === m ? "topbutton" : "bottombutton").addClass("highcharts-map-navigation highcharts-" + { zoomIn: "zoom-in", zoomOut: "zoom-out" }[m]).attr({ width: E, height: u, title: e.options.lang[m], padding: f2.padding, zIndex: 5 }).add(c.navButtonsGroup);
            if ("+" === v || "-" === v) {
              m = E + 1;
              const b2 = [["M", B + 3, B + u / 2], ["L", B + m - 3, B + u / 2]];
              "+" === v && b2.push(["M", B + m / 2, B + 3], ["L", B + m / 2, B + u - 3]);
              e.renderer.path(b2).addClass("highcharts-button-symbol").attr(e.styledMode ? {} : { stroke: null === (h2 = f2.style) || void 0 === h2 ? void 0 : h2.color, "stroke-width": 3, "stroke-linecap": "round" }).add(D);
            }
            D.handler = f2.onclick;
            A(D.element, "dblclick", g);
            p.push(D);
            w(f2, { width: D.width, height: 2 * D.height });
            if (e.hasLoaded)
              D.align(f2, false, f2.alignTo);
            else {
              const b2 = A(e, "load", () => {
                D.element && D.align(f2, false, f2.alignTo);
                b2();
              });
            }
          }), f = function() {
            var d2 = e.exportingGroup && e.exportingGroup.getBBox();
            if (d2) {
              const e2 = c.navButtonsGroup.getBBox();
              if (!(e2.x >= d2.x + d2.width || e2.x + e2.width <= d2.x || e2.y >= d2.y + d2.height || e2.y + e2.height <= d2.y)) {
                const f2 = -e2.y - e2.height + d2.y - 5;
                d2 = d2.y + d2.height - e2.y + 5;
                c.navButtonsGroup.attr({ translateY: "bottom" === (b.buttonOptions && b.buttonOptions.verticalAlign) ? f2 : d2 });
              }
            }
          }, e.hasLoaded || A(e, "render", f));
          this.updateEvents(b);
        };
        k.prototype.updateEvents = function(f) {
          const c = this.chart;
          F(f.enableDoubleClickZoom, f.enabled) || f.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || A(c.container, "dblclick", function(e) {
            c.pointer.onContainerDblClick(e);
          }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());
          F(f.enableMouseWheelZoom, f.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || A(c.container, void 0 !== l.onwheel ? "wheel" : void 0 !== l.onmousewheel ? "mousewheel" : "DOMMouseScroll", function(e) {
            c.pointer.inClass(e.target, "highcharts-no-mousewheel") || (c.pointer.onContainerMouseWheel(e), g(e));
            return false;
          }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());
        };
        w(a2.prototype, { fitToBox: function(f, c) {
          [["x", "width"], ["y", "height"]].forEach(function(e) {
            const b = e[0];
            e = e[1];
            f[b] + f[e] > c[b] + c[e] && (f[e] > c[e] ? (f[e] = c[e], f[b] = c[b]) : f[b] = c[b] + c[e] - f[e]);
            f[e] > c[e] && (f[e] = c[e]);
            f[b] < c[b] && (f[b] = c[b]);
          });
          return f;
        }, mapZoom: function(f, c, e, b, d) {
          this.mapView && (x(f) && (f = Math.log(f) / Math.log(0.5)), this.mapView.zoomBy(f, x(c) && x(e) ? this.mapView.projection.inverse([c, e]) : void 0, x(b) && x(d) ? [b, d] : void 0));
        } });
        A(a2, "beforeRender", function() {
          this.mapNavigation = new k(this);
          this.mapNavigation.update();
        });
        n.MapNavigation = k;
      });
      y(
        a,
        "Maps/MapPointer.js",
        [a["Core/Pointer.js"], a["Core/Utilities.js"]],
        function(a2, n) {
          const { defined: g, extend: z, pick: k, wrap: l } = n, A = a2.prototype.normalize;
          let w = 0, x;
          z(a2.prototype, { normalize: function(t, h) {
            const a3 = this.chart;
            t = A.call(this, t, h);
            a3 && a3.mapView && (h = a3.mapView.pixelsToLonLat({ x: t.chartX - a3.plotLeft, y: t.chartY - a3.plotTop })) && z(t, h);
            return t;
          }, onContainerDblClick: function(a3) {
            const h = this.chart;
            a3 = this.normalize(a3);
            h.options.mapNavigation.enableDoubleClickZoomTo ? h.pointer.inClass(a3.target, "highcharts-tracker") && h.hoverPoint && h.hoverPoint.zoomTo() : h.isInsidePlot(a3.chartX - h.plotLeft, a3.chartY - h.plotTop) && h.mapZoom(0.5, void 0, void 0, a3.chartX, a3.chartY);
          }, onContainerMouseWheel: function(a3) {
            const h = this.chart;
            a3 = this.normalize(a3);
            const t = g(a3.wheelDelta) && -a3.wheelDelta / 120 || a3.deltaY || a3.detail;
            1 <= Math.abs(t) && (w += Math.abs(t), x && clearTimeout(x), x = setTimeout(() => {
              w = 0;
            }, 50));
            10 > w && h.isInsidePlot(a3.chartX - h.plotLeft, a3.chartY - h.plotTop) && h.mapView && h.mapView.zoomBy((h.options.mapNavigation.mouseWheelSensitivity - 1) * -t, void 0, [a3.chartX, a3.chartY], 1 > Math.abs(t) ? false : void 0);
          } });
          l(
            a2.prototype,
            "zoomOption",
            function(a3) {
              const h = this.chart.options.mapNavigation;
              k(h.enableTouchZoom, h.enabled) && (this.chart.zooming.pinchType = "xy");
              a3.apply(this, [].slice.call(arguments, 1));
            }
          );
          l(a2.prototype, "pinchTranslate", function(a3, h, k2, f, c, e, b) {
            a3.call(this, h, k2, f, c, e, b);
            "map" === this.chart.options.chart.type && this.hasZoom && (a3 = f.scaleX > f.scaleY, this.pinchTranslateDirection(!a3, h, k2, f, c, e, b, a3 ? f.scaleX : f.scaleY));
          });
        }
      );
      y(a, "Series/ColorMapComposition.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n) {
        const { column: { prototype: g } } = a2.seriesTypes, { addEvent: z, defined: k } = n;
        var l;
        (function(a3) {
          function l2(a4) {
            this.moveToTopOnHover && this.graphic && this.graphic.attr({ zIndex: a4 && "hover" === a4.state ? 1 : 0 });
          }
          const q = [];
          a3.pointMembers = { dataLabelOnNull: true, moveToTopOnHover: true, isValid: function() {
            return null !== this.value && Infinity !== this.value && -Infinity !== this.value && (void 0 === this.value || !isNaN(this.value));
          } };
          a3.seriesMembers = {
            colorKey: "value",
            axisTypes: ["xAxis", "yAxis", "colorAxis"],
            parallelArrays: ["x", "y", "value"],
            pointArrayMap: ["value"],
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            colorAttribs: function(a4) {
              const h = {};
              !k(a4.color) || a4.state && "normal" !== a4.state || (h[this.colorProp || "fill"] = a4.color);
              return h;
            },
            pointAttribs: g.pointAttribs
          };
          a3.compose = function(a4) {
            const h = a4.prototype.pointClass;
            n.pushUnique(q, h) && z(h, "afterSetState", l2);
            return a4;
          };
        })(l || (l = {}));
        return l;
      });
      y(a, "Maps/MapSymbols.js", [a["Core/Renderer/SVG/SVGRenderer.js"]], function(a2) {
        const { prototype: { symbols: g } } = a2;
        g.bottombutton = function(a3, n, k, l, A) {
          if (A) {
            const a4 = (null === A || void 0 === A ? void 0 : A.r) || 0;
            A.brBoxY = n - a4;
            A.brBoxHeight = l + a4;
          }
          return g.roundedRect(a3, n, k, l, A);
        };
        g.topbutton = function(a3, n, k, l, A) {
          A && (A.brBoxHeight = l + ((null === A || void 0 === A ? void 0 : A.r) || 0));
          return g.roundedRect(a3, n, k, l, A);
        };
        return g;
      });
      y(a, "Core/Chart/MapChart.js", [a["Core/Chart/Chart.js"], a["Core/Defaults.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, n, q, z) {
        const { getOptions: k } = n, { merge: g, pick: A } = z;
        class w extends a2 {
          init(a3, t) {
            const h = k().credits;
            a3 = g({ chart: { panning: { enabled: true, type: "xy" }, type: "map" }, credits: { mapText: A(h.mapText, ' Â© <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'), mapTextFull: A(h.mapTextFull, "{geojson.copyright}") }, mapView: {}, tooltip: { followTouchMove: false } }, a3);
            super.init(a3, t);
          }
        }
        (function(a3) {
          a3.maps = {};
          a3.mapChart = function(t, h, k2) {
            return new a3(t, h, k2);
          };
          a3.splitPath = function(a4) {
            "string" === typeof a4 && (a4 = a4.replace(/([A-Za-z])/g, " $1 ").replace(/^\s*/, "").replace(/\s*$/, ""), a4 = a4.split(/[ ,;]+/).map((a5) => /[A-za-z]/.test(a5) ? a5 : parseFloat(a5)));
            return q.prototype.pathToSegments(a4);
          };
        })(w || (w = {}));
        return w;
      });
      y(a, "Maps/MapUtilities.js", [], function() {
        return { boundsFromPath: function(a2) {
          let g = -Number.MAX_VALUE, q = Number.MAX_VALUE, z = -Number.MAX_VALUE, k = Number.MAX_VALUE, l;
          a2.forEach((a3) => {
            const w = a3[a3.length - 2];
            a3 = a3[a3.length - 1];
            "number" === typeof w && "number" === typeof a3 && (q = Math.min(q, w), g = Math.max(g, w), k = Math.min(k, a3), z = Math.max(z, a3), l = true);
          });
          if (l)
            return { x1: q, y1: k, x2: g, y2: z };
        }, pointInPolygon: function(a2, n) {
          let g, z, k, l = false, A = a2.x, w = a2.y;
          a2 = 0;
          for (g = n.length - 1; a2 < n.length; g = a2++)
            z = n[a2][1] > w, k = n[g][1] > w, z !== k && A < (n[g][0] - n[a2][0]) * (w - n[a2][1]) / (n[g][1] - n[a2][1]) + n[a2][0] && (l = !l);
          return l;
        } };
      });
      y(a, "Series/Map/MapPoint.js", [a["Series/ColorMapComposition.js"], a["Maps/MapUtilities.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n, q, z) {
        const { boundsFromPath: k } = n;
        ({ seriesTypes: { scatter: n } } = q);
        const { extend: l, isNumber: g, pick: w } = z;
        class x extends n.prototype.pointClass {
          constructor() {
            super(...arguments);
            this.series = this.path = this.options = void 0;
          }
          static getProjectedPath(a3, h) {
            a3.projectedPath || (h && a3.geometry ? (h.hasCoordinates = true, a3.projectedPath = h.path(a3.geometry)) : a3.projectedPath = a3.path);
            return a3.projectedPath || [];
          }
          applyOptions(a3, h) {
            const k2 = this.series;
            a3 = super.applyOptions.call(this, a3, h);
            h = k2.joinBy;
            k2.mapData && k2.mapMap && (h = super.getNestedProperty.call(a3, h[1]), (h = "undefined" !== typeof h && k2.mapMap[h]) ? l(a3, h) : -1 !== k2.pointArrayMap.indexOf("value") && (a3.value = a3.value || null));
            return a3;
          }
          getProjectedBounds(a3) {
            var h = x.getProjectedPath(this, a3);
            h = k(h);
            var l2 = this.properties;
            const f = this.series.chart.mapView;
            if (h) {
              const c = l2 && l2["hc-middle-lon"], e = l2 && l2["hc-middle-lat"];
              f && g(c) && g(e) ? (a3 = a3.forward([c, e]), h.midX = a3[0], h.midY = a3[1]) : (a3 = l2 && l2["hc-middle-x"], l2 = l2 && l2["hc-middle-y"], h.midX = h.x1 + (h.x2 - h.x1) * w(this.middleX, g(a3) ? a3 : 0.5), a3 = w(this.middleY, g(l2) ? l2 : 0.5), this.geometry || (a3 = 1 - a3), h.midY = h.y2 - (h.y2 - h.y1) * a3);
              return h;
            }
          }
          onMouseOver(a3) {
            z.clearTimeout(this.colorInterval);
            if (!this.isNull && this.visible || this.series.options.nullInteraction)
              super.onMouseOver.call(
                this,
                a3
              );
            else
              this.series.onMouseOut(a3);
          }
          setVisible(a3) {
            const h = a3 ? "show" : "hide";
            this.visible = this.options.visible = !!a3;
            if (this.dataLabel)
              this.dataLabel[h]();
            this.graphic && this.graphic.attr(this.series.pointAttribs(this));
          }
          zoomTo(a3) {
            const h = this.series.chart, k2 = h.mapView;
            var f = this.bounds;
            if (k2 && f) {
              const e = g(this.insetIndex) && k2.insets[this.insetIndex];
              if (e) {
                var c = e.projectedUnitsToPixels({ x: f.x1, y: f.y1 });
                f = e.projectedUnitsToPixels({ x: f.x2, y: f.y2 });
                c = k2.pixelsToProjectedUnits({ x: c.x, y: c.y });
                f = k2.pixelsToProjectedUnits({
                  x: f.x,
                  y: f.y
                });
                f = { x1: c.x, y1: c.y, x2: f.x, y2: f.y };
              }
              k2.fitToBounds(f, void 0, false);
              this.series.isDirty = true;
              h.redraw(a3);
            }
          }
        }
        l(x.prototype, { dataLabelOnNull: a2.pointMembers.dataLabelOnNull, moveToTopOnHover: a2.pointMembers.moveToTopOnHover, isValid: a2.pointMembers.isValid });
        return x;
      });
      y(a, "Maps/MapViewOptionsDefault.js", [], function() {
        return { center: [0, 0], fitToGeometry: void 0, maxZoom: void 0, padding: 0, projection: { name: void 0, parallels: void 0, rotation: void 0 }, zoom: void 0 };
      });
      y(a, "Maps/MapViewInsetsOptionsDefault.js", [], function() {
        return {
          borderColor: "#cccccc",
          borderWidth: 1,
          center: [0, 0],
          padding: "10%",
          relativeTo: "mapBoundingBox",
          units: "percent"
        };
      });
      y(a, "Extensions/GeoJSON.js", [a["Core/Chart/Chart.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]], function(a2, n, q, z) {
        function k(a3, c) {
          c || (c = Object.keys(a3.objects)[0]);
          c = a3.objects[c];
          if (c["hc-decoded-geojson"])
            return c["hc-decoded-geojson"];
          let e = a3.arcs;
          if (a3.transform) {
            const { scale: b2, translate: d2 } = a3.transform;
            e = a3.arcs.map((a4) => {
              let c2 = 0, e2 = 0;
              return a4.map((a5) => {
                a5 = a5.slice();
                a5[0] = (c2 += a5[0]) * b2[0] + d2[0];
                a5[1] = (e2 += a5[1]) * b2[1] + d2[1];
                return a5;
              });
            });
          }
          const b = (a4) => "number" === typeof a4[0] ? a4.reduce((b2, a5, d2) => {
            let c2 = 0 > a5 ? e[~a5] : e[a5];
            0 > a5 ? (c2 = c2.slice(0, 0 === d2 ? c2.length : c2.length - 1), c2.reverse()) : d2 && (c2 = c2.slice(1));
            return b2.concat(c2);
          }, []) : a4.map(b), d = c.geometries.map((a4) => ({ type: "Feature", properties: a4.properties, geometry: { type: a4.type, coordinates: a4.coordinates || b(a4.arcs) } }));
          a3 = {
            type: "FeatureCollection",
            copyright: a3.copyright,
            copyrightShort: a3.copyrightShort,
            copyrightUrl: a3.copyrightUrl,
            features: d,
            "hc-recommended-mapview": c["hc-recommended-mapview"],
            bbox: a3.bbox,
            title: a3.title
          };
          return c["hc-decoded-geojson"] = a3;
        }
        function l(a3, c = "map", e) {
          const b = [];
          a3 = "Topology" === a3.type ? k(a3) : a3;
          a3.features.forEach(function(a4) {
            var d = a4.geometry || {}, e2 = d.type;
            d = d.coordinates;
            a4 = a4.properties;
            let f;
            "map" !== c && "mapbubble" !== c || "Polygon" !== e2 && "MultiPolygon" !== e2 ? "mapline" !== c || "LineString" !== e2 && "MultiLineString" !== e2 ? "mappoint" === c && "Point" === e2 && d.length && (f = { geometry: { coordinates: d, type: e2 } }) : d.length && (f = { geometry: { coordinates: d, type: e2 } }) : d.length && (f = { geometry: {
              coordinates: d,
              type: e2
            } });
            if (f) {
              e2 = a4 && (a4.name || a4.NAME);
              d = a4 && a4.lon;
              const c2 = a4 && a4.lat;
              b.push(t(f, { lat: "number" === typeof c2 ? c2 : void 0, lon: "number" === typeof d ? d : void 0, name: "string" === typeof e2 ? e2 : void 0, properties: a4 }));
            }
          });
          e && a3.copyrightShort && (e.chart.mapCredits = g(e.chart.options.credits.mapText, { geojson: a3 }), e.chart.mapCreditsFull = g(e.chart.options.credits.mapTextFull, { geojson: a3 }));
          return b;
        }
        const { format: g } = n, { win: w } = q, { error: x, extend: t, merge: h, wrap: F } = z;
        "";
        a2.prototype.transformFromLatLon = function(a3, c) {
          var e = this.options.chart.proj4 || w.proj4;
          if (e) {
            var { jsonmarginX: b = 0, jsonmarginY: d = 0, jsonres: f = 1, scale: h2 = 1, xoffset: k2 = 0, xpan: m = 0, yoffset: r = 0, ypan: v = 0 } = c;
            a3 = e(c.crs, [a3.lon, a3.lat]);
            e = c.cosAngle || c.rotation && Math.cos(c.rotation);
            var l2 = c.sinAngle || c.rotation && Math.sin(c.rotation);
            c = c.rotation ? [a3[0] * e + a3[1] * l2, -a3[0] * l2 + a3[1] * e] : a3;
            return { x: ((c[0] - k2) * h2 + m) * f + b, y: -(((r - c[1]) * h2 + v) * f - d) };
          }
          x(21, false, this);
        };
        a2.prototype.transformToLatLon = function(a3, c) {
          const e = this.options.chart.proj4 || w.proj4;
          if (!e)
            x(21, false, this);
          else if (null !== a3.y) {
            var {
              jsonmarginX: b = 0,
              jsonmarginY: d = 0,
              jsonres: f = 1,
              scale: h2 = 1,
              xoffset: k2 = 0,
              xpan: m = 0,
              yoffset: r = 0,
              ypan: v = 0
            } = c;
            a3 = { x: ((a3.x - b) / f - m) / h2 + k2, y: ((a3.y - d) / f + v) / h2 + r };
            var l2 = c.cosAngle || c.rotation && Math.cos(c.rotation), u = c.sinAngle || c.rotation && Math.sin(c.rotation);
            c = e(c.crs, "WGS84", c.rotation ? { x: a3.x * l2 + a3.y * -u, y: a3.x * u + a3.y * l2 } : a3);
            return { lat: c.y, lon: c.x };
          }
        };
        a2.prototype.fromPointToLatLon = function(a3) {
          return this.mapView && this.mapView.projectedUnitsToLonLat(a3);
        };
        a2.prototype.fromLatLonToPoint = function(a3) {
          return this.mapView && this.mapView.lonLatToProjectedUnits(a3);
        };
        F(a2.prototype, "addCredits", function(a3, c) {
          c = h(true, this.options.credits, c);
          this.mapCredits && (c.href = null);
          a3.call(this, c);
          this.credits && this.mapCreditsFull && this.credits.attr({ title: this.mapCreditsFull });
        });
        q.geojson = l;
        q.topo2geo = k;
        return { geojson: l, topo2geo: k };
      });
      y(a, "Core/Geometry/PolygonClip.js", [], function() {
        const a2 = (a3, k, l) => (k[0] - a3[0]) * (l[1] - a3[1]) > (k[1] - a3[1]) * (l[0] - a3[0]), n = (a3, k, l, g) => {
          var w = [a3[0] - k[0], a3[1] - k[1]];
          const q2 = [l[0] - g[0], l[1] - g[1]];
          a3 = a3[0] * k[1] - a3[1] * k[0];
          l = l[0] * g[1] - l[1] * g[0];
          g = 1 / (w[0] * q2[1] - w[1] * q2[0]);
          w = [(a3 * q2[0] - l * w[0]) * g, (a3 * q2[1] - l * w[1]) * g];
          w.isIntersection = true;
          return w;
        };
        var q;
        (function(g) {
          g.clipLineString = (a3, l) => {
            const k = [];
            a3 = g.clipPolygon(a3, l, false);
            for (l = 1; l < a3.length; l++)
              a3[l].isIntersection && a3[l - 1].isIntersection && (k.push(a3.splice(0, l)), l = 0), l === a3.length - 1 && k.push(a3);
            return k;
          };
          g.clipPolygon = (k, l, g2 = true) => {
            let q2 = l[l.length - 1], x, t, h = k;
            for (let w = 0; w < l.length; w++) {
              const f = h;
              k = l[w];
              h = [];
              x = g2 ? f[f.length - 1] : f[0];
              for (let c = 0; c < f.length; c++)
                t = f[c], a2(q2, k, t) ? (a2(q2, k, x) || h.push(n(q2, k, x, t)), h.push(t)) : a2(q2, k, x) && h.push(n(q2, k, x, t)), x = t;
              q2 = k;
            }
            return h;
          };
        })(q || (q = {}));
        return q;
      });
      y(a, "Maps/Projections/LambertConformalConic.js", [], function() {
        const a2 = Math.sign || ((a3) => 0 === a3 ? 0 : 0 < a3 ? 1 : -1), n = Math.PI / 180, q = Math.PI / 2;
        class z {
          constructor(k) {
            var l, g = (k.parallels || []).map((a3) => a3 * n);
            const w = g[0] || 0;
            g = null !== (l = g[1]) && void 0 !== l ? l : w;
            l = Math.cos(w);
            "object" === typeof k.projectedBounds && (this.projectedBounds = k.projectedBounds);
            k = w === g ? Math.sin(w) : Math.log(l / Math.cos(g)) / Math.log(Math.tan((q + g) / 2) / Math.tan((q + w) / 2));
            1e-10 > Math.abs(k) && (k = 1e-10 * (a2(k) || 1));
            this.n = k;
            this.c = l * Math.pow(Math.tan((q + w) / 2), k) / k;
          }
          forward(a3) {
            var l = a3[0] * n;
            const { c: k, n: g, projectedBounds: x } = this;
            a3 = a3[1] * n;
            0 < k ? a3 < -q + 1e-6 && (a3 = -q + 1e-6) : a3 > q - 1e-6 && (a3 = q - 1e-6);
            var t = k / Math.pow(Math.tan((q + a3) / 2), g);
            a3 = t * Math.sin(g * l) * 63.78137;
            l = 63.78137 * (k - t * Math.cos(g * l));
            t = [a3, l];
            x && (a3 < x.x1 || a3 > x.x2 || l < x.y1 || l > x.y2) && (t.outside = true);
            return t;
          }
          inverse(k) {
            const l = k[0] / 63.78137;
            k = k[1] / 63.78137;
            const { c: g, n: w } = this;
            k = g - k;
            const x = a2(w) * Math.sqrt(l * l + k * k);
            let t = Math.atan2(l, Math.abs(k)) * a2(k);
            0 > k * w && (t -= Math.PI * a2(l) * a2(k));
            return [t / w / n, (2 * Math.atan(Math.pow(g / x, 1 / w)) - q) / n];
          }
        }
        return z;
      });
      y(a, "Maps/Projections/EqualEarth.js", [], function() {
        const a2 = Math.sqrt(3) / 2;
        class n {
          constructor() {
            this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -97.52595454902263, y2: 97.52595454902263 };
          }
          forward(g) {
            const q = Math.PI / 180, k = Math.asin(a2 * Math.sin(g[1] * q)), l = k * k, n2 = l * l * l;
            return [g[0] * q * Math.cos(k) * 74.03120656864502 / (a2 * (1.340264 + 3 * -0.081106 * l + n2 * (7 * 893e-6 + 0.034164 * l))), 74.03120656864502 * k * (1.340264 + -0.081106 * l + n2 * (893e-6 + 3796e-6 * l))];
          }
          inverse(g) {
            const q = g[0] / 74.03120656864502;
            g = g[1] / 74.03120656864502;
            const k = 180 / Math.PI;
            let l = g;
            let n2;
            let w;
            for (w = 0; 12 > w; ++w) {
              var x = l * l;
              n2 = x * x * x;
              var t = l * (1.340264 + -0.081106 * x + n2 * (893e-6 + 3796e-6 * x)) - g;
              x = 1.340264 + 3 * -0.081106 * x + n2 * (7 * 893e-6 + 0.034164 * x);
              l -= t /= x;
              if (1e-9 > Math.abs(t))
                break;
            }
            x = l * l;
            return [k * a2 * q * (1.340264 + 3 * -0.081106 * x + x * x * x * (7 * 893e-6 + 0.034164 * x)) / Math.cos(l), k * Math.asin(Math.sin(l) / a2)];
          }
        }
        return n;
      });
      y(a, "Maps/Projections/Miller.js", [], function() {
        const a2 = Math.PI / 4, n = Math.PI / 180;
        class q {
          constructor() {
            this.bounds = { x1: -200.37508342789243, x2: 200.37508342789243, y1: -146.91480769173063, y2: 146.91480769173063 };
          }
          forward(g) {
            return [g[0] * n * 63.78137, 79.7267125 * Math.log(Math.tan(a2 + 0.4 * g[1] * n))];
          }
          inverse(g) {
            return [g[0] / 63.78137 / n, 2.5 * (Math.atan(Math.exp(g[1] / 63.78137 * 0.8)) - a2) / n];
          }
        }
        return q;
      });
      y(a, "Maps/Projections/Orthographic.js", [], function() {
        const a2 = Math.PI / 180;
        class n {
          constructor() {
            this.antimeridianCutting = false;
            this.bounds = {
              x1: -63.78460826781007,
              x2: 63.78460826781007,
              y1: -63.78460826781007,
              y2: 63.78460826781007
            };
          }
          forward(g) {
            const n2 = g[0];
            g = g[1] * a2;
            g = [Math.cos(g) * Math.sin(n2 * a2) * 63.78460826781007, 63.78460826781007 * Math.sin(g)];
            if (-90 > n2 || 90 < n2)
              g.outside = true;
            return g;
          }
          inverse(g) {
            const n2 = g[0] / 63.78460826781007;
            g = g[1] / 63.78460826781007;
            const k = Math.sqrt(n2 * n2 + g * g), l = Math.asin(k), q = Math.sin(l);
            return [Math.atan2(n2 * q, k * Math.cos(l)) / a2, Math.asin(k && g * q / k) / a2];
          }
        }
        return n;
      });
      y(a, "Maps/Projections/WebMercator.js", [], function() {
        const a2 = Math.PI / 180;
        class n {
          constructor() {
            this.bounds = {
              x1: -200.37508342789243,
              x2: 200.37508342789243,
              y1: -200.3750834278071,
              y2: 200.3750834278071
            };
            this.maxLatitude = 85.0511287798;
          }
          forward(g) {
            var n2 = Math.sin(g[1] * a2);
            n2 = [63.78137 * g[0] * a2, 63.78137 * Math.log((1 + n2) / (1 - n2)) / 2];
            85.0511287798 < Math.abs(g[1]) && (n2.outside = true);
            return n2;
          }
          inverse(g) {
            return [g[0] / (63.78137 * a2), (2 * Math.atan(Math.exp(g[1] / 63.78137)) - Math.PI / 2) / a2];
          }
        }
        return n;
      });
      y(a, "Maps/Projections/ProjectionRegistry.js", [
        a["Maps/Projections/LambertConformalConic.js"],
        a["Maps/Projections/EqualEarth.js"],
        a["Maps/Projections/Miller.js"],
        a["Maps/Projections/Orthographic.js"],
        a["Maps/Projections/WebMercator.js"]
      ], function(a2, n, q, z, k) {
        return { EqualEarth: n, LambertConformalConic: a2, Miller: q, Orthographic: z, WebMercator: k };
      });
      y(a, "Maps/Projection.js", [a["Core/Geometry/PolygonClip.js"], a["Maps/Projections/ProjectionRegistry.js"], a["Core/Utilities.js"]], function(a2, n, q) {
        const { clipLineString: g, clipPolygon: k } = a2, { clamp: l, erase: A } = q, w = 2 * Math.PI / 360, x = (a3) => {
          -180 > a3 && (a3 += 360);
          180 < a3 && (a3 -= 360);
          return a3;
        };
        class t {
          static add(a3, g2) {
            t.registry[a3] = g2;
          }
          static greatCircle(a3, g2, f) {
            const {
              atan2: c,
              cos: e,
              sin: b,
              sqrt: d
            } = Math, h = a3[1] * w, p = a3[0] * w, l2 = g2[1] * w, m = g2[0] * w;
            var r = l2 - h, v = m - p;
            r = b(r / 2) * b(r / 2) + e(h) * e(l2) * b(v / 2) * b(v / 2);
            r = 2 * c(d(r), d(1 - r));
            var k2 = Math.round(6371e3 * r / 5e5);
            v = [];
            f && v.push(a3);
            if (1 < k2)
              for (a3 = 1 / k2, k2 = a3; 0.999 > k2; k2 += a3) {
                var u = b((1 - k2) * r) / b(r);
                const a4 = b(k2 * r) / b(r);
                var B = u * e(h) * e(p) + a4 * e(l2) * e(m);
                const f2 = u * e(h) * b(p) + a4 * e(l2) * b(m);
                u = u * b(h) + a4 * b(l2);
                u = c(u, d(B * B + f2 * f2));
                B = c(f2, B);
                v.push([B / w, u / w]);
              }
            f && v.push(g2);
            return v;
          }
          static insertGreatCircles(a3) {
            let h = a3.length - 1;
            for (; h--; )
              if (10 < Math.max(Math.abs(a3[h][0] - a3[h + 1][0]), Math.abs(a3[h][1] - a3[h + 1][1]))) {
                const f = t.greatCircle(a3[h], a3[h + 1]);
                f.length && a3.splice(h + 1, 0, ...f);
              }
          }
          static toString(a3) {
            const { name: h, rotation: f } = a3 || {};
            return [h, f && f.join(",")].join(";");
          }
          constructor(a3 = {}) {
            this.hasGeoProjection = this.hasCoordinates = false;
            this.maxLatitude = 90;
            this.options = a3;
            const { name: h, projectedBounds: f, rotation: c } = a3;
            this.rotator = c ? this.getRotator(c) : void 0;
            const e = h ? t.registry[h] : void 0;
            e && (this.def = new e(a3));
            const { def: b, rotator: d } = this;
            b && (this.maxLatitude = b.maxLatitude || 90, this.hasGeoProjection = true);
            d && b ? (this.forward = (a4) => b.forward(d.forward(a4)), this.inverse = (a4) => d.inverse(b.inverse(a4))) : b ? (this.forward = (a4) => b.forward(a4), this.inverse = (a4) => b.inverse(a4)) : d && (this.forward = d.forward, this.inverse = d.inverse);
            this.bounds = "world" === f ? b && b.bounds : f;
          }
          lineIntersectsBounds(a3) {
            const { x1: h, x2: f, y1: c, y2: e } = this.bounds || {}, b = (a4, b2, d2) => {
              const [c2, e2] = a4;
              a4 = b2 ? 0 : 1;
              if ("number" === typeof d2 && c2[b2] >= d2 !== e2[b2] >= d2)
                return a4 = c2[a4] + (d2 - c2[b2]) / (e2[b2] - c2[b2]) * (e2[a4] - c2[a4]), b2 ? [a4, d2] : [d2, a4];
            };
            let d, g2 = a3[0];
            if (d = b(a3, 0, h))
              g2 = d, a3[1] = d;
            else if (d = b(a3, 0, f))
              g2 = d, a3[1] = d;
            if (d = b(a3, 1, c))
              g2 = d;
            else if (d = b(a3, 1, e))
              g2 = d;
            return g2;
          }
          getRotator(a3) {
            const h = a3[0] * w, f = (a3[1] || 0) * w;
            a3 = (a3[2] || 0) * w;
            const c = Math.cos(f), e = Math.sin(f), b = Math.cos(a3), d = Math.sin(a3);
            if (0 !== h || 0 !== f || 0 !== a3)
              return { forward: (a4) => {
                var f2 = a4[0] * w + h, g2 = a4[1] * w, m = Math.cos(g2);
                a4 = Math.cos(f2) * m;
                f2 = Math.sin(f2) * m;
                g2 = Math.sin(g2);
                m = g2 * c + a4 * e;
                return [Math.atan2(f2 * b - m * d, a4 * c - g2 * e) / w, Math.asin(m * b + f2 * d) / w];
              }, inverse: (a4) => {
                var f2 = a4[0] * w, g2 = a4[1] * w, m = Math.cos(g2);
                a4 = Math.cos(f2) * m;
                f2 = Math.sin(f2) * m;
                g2 = Math.sin(g2);
                m = g2 * b - f2 * d;
                return [(Math.atan2(f2 * b + g2 * d, a4 * c + m * e) - h) / w, Math.asin(m * c - a4 * e) / w];
              } };
          }
          forward(a3) {
            return a3;
          }
          inverse(a3) {
            return a3;
          }
          cutOnAntimeridian(a3, g2) {
            const f = [], c = [a3];
            a3.forEach((b2, d2) => {
              let c2 = a3[d2 - 1];
              if (!d2) {
                if (!g2)
                  return;
                c2 = a3[a3.length - 1];
              }
              const e2 = c2[0];
              var u = b2[0];
              (-90 > e2 || 90 < e2) && (-90 > u || 90 < u) && 0 < e2 !== 0 < u && (u = l((180 - (e2 + 360) % 360) / ((u + 360) % 360 - (e2 + 360) % 360), 0, 1), f.push({ i: d2, lat: c2[1] + u * (b2[1] - c2[1]), direction: 0 > e2 ? 1 : -1, previousLonLat: c2, lonLat: b2 }));
            });
            if (f.length)
              if (g2) {
                if (1 === f.length % 2) {
                  var e = f.slice().sort((a4, b2) => Math.abs(b2.lat) - Math.abs(a4.lat))[0];
                  A(f, e);
                }
                for (var b = f.length - 2; 0 <= b; ) {
                  var d = f[b].i, h = x(180 + 1e-6 * f[b].direction), p = x(180 - 1e-6 * f[b].direction);
                  d = a3.splice(d, f[b + 1].i - d, ...t.greatCircle([h, f[b].lat], [h, f[b + 1].lat], true));
                  d.push(...t.greatCircle([p, f[b + 1].lat], [p, f[b].lat], true));
                  c.push(d);
                  b -= 2;
                }
                if (e)
                  for (d = 0; d < c.length; d++) {
                    const { direction: a4, lat: f2 } = e;
                    b = c[d];
                    p = b.indexOf(e.lonLat);
                    if (-1 < p) {
                      d = (0 > f2 ? -1 : 1) * this.maxLatitude;
                      var k2 = x(180 + 1e-6 * a4);
                      h = x(180 - 1e-6 * a4);
                      const c2 = t.greatCircle([k2, f2], [k2, d], true);
                      for (k2 += 120 * a4; -180 < k2 && 180 > k2; k2 += 120 * a4)
                        c2.push([k2, d]);
                      c2.push(...t.greatCircle([
                        h,
                        d
                      ], [h, e.lat], true));
                      b.splice(p, 0, ...c2);
                      break;
                    }
                  }
              } else
                for (e = f.length; e--; )
                  b = a3.splice(f[e].i, a3.length, [x(180 + 1e-6 * f[e].direction), f[e].lat]), b.unshift([x(180 - 1e-6 * f[e].direction), f[e].lat]), c.push(b);
            return c;
          }
          path(a3) {
            const { bounds: h, def: f, rotator: c } = this, e = [], b = "Polygon" === a3.type || "MultiPolygon" === a3.type, d = this.hasGeoProjection, l2 = !f || false !== f.antimeridianCutting, p = l2 ? c : void 0, n2 = l2 ? f || this : this;
            let m;
            h && (m = [[h.x1, h.y1], [h.x2, h.y1], [h.x2, h.y2], [h.x1, h.y2]]);
            const r = (a4) => {
              a4 = a4.map((a5) => {
                if (l2) {
                  p && (a5 = p.forward(a5));
                  let b2 = a5[0];
                  1e-6 > Math.abs(b2 - 180) && (b2 = 180 > b2 ? 179.999999 : 180.000001);
                  a5 = [b2, a5[1]];
                }
                return a5;
              });
              let c2 = [a4];
              d && (t.insertGreatCircles(a4), l2 && (c2 = this.cutOnAntimeridian(a4, b)));
              c2.forEach((a5) => {
                if (!(2 > a5.length)) {
                  var c3 = false, u = false, f2 = (a6) => {
                    c3 ? e.push(["L", a6[0], a6[1]]) : (e.push(["M", a6[0], a6[1]]), c3 = true);
                  }, v = false, p2 = false, r2 = a5.map((a6) => {
                    a6 = n2.forward(a6);
                    a6.outside ? v = true : p2 = true;
                    Infinity === a6[1] ? a6[1] = 1e10 : -Infinity === a6[1] && (a6[1] = -1e10);
                    return a6;
                  });
                  if (l2) {
                    b && r2.push(r2[0]);
                    if (v) {
                      if (!p2)
                        return;
                      if (m) {
                        if (b)
                          r2 = k(r2, m);
                        else if (h) {
                          g(r2, m).forEach((a6) => {
                            c3 = false;
                            a6.forEach(f2);
                          });
                          return;
                        }
                      }
                    }
                    r2.forEach(f2);
                  } else
                    for (let e2 = 0; e2 < r2.length; e2++) {
                      const g2 = a5[e2], h2 = r2[e2];
                      if (h2.outside)
                        u = true;
                      else {
                        if (b && !w2) {
                          var w2 = g2;
                          a5.push(g2);
                          r2.push(h2);
                        }
                        u && q2 && (b && d ? t.greatCircle(q2, g2).forEach((a6) => f2(n2.forward(a6))) : c3 = false);
                        f2(h2);
                        var q2 = g2;
                        u = false;
                      }
                    }
                }
              });
            };
            "LineString" === a3.type ? r(a3.coordinates) : "MultiLineString" === a3.type ? a3.coordinates.forEach((a4) => r(a4)) : "Polygon" === a3.type ? (a3.coordinates.forEach((a4) => r(a4)), e.length && e.push(["Z"])) : "MultiPolygon" === a3.type && (a3.coordinates.forEach((a4) => {
              a4.forEach((a5) => r(a5));
            }), e.length && e.push(["Z"]));
            return e;
          }
        }
        t.registry = n;
        return t;
      });
      y(a, "Maps/MapView.js", [a["Maps/MapViewOptionsDefault.js"], a["Maps/MapViewInsetsOptionsDefault.js"], a["Extensions/GeoJSON.js"], a["Core/Chart/MapChart.js"], a["Maps/MapUtilities.js"], a["Maps/Projection.js"], a["Core/Utilities.js"]], function(a2, n, q, z, k, l, A) {
        const { topo2geo: g } = q, { maps: x } = z, { boundsFromPath: t, pointInPolygon: h } = k, { addEvent: F, clamp: f, fireEvent: c, isArray: e, isNumber: b, isObject: d, isString: E, merge: p, pick: C, relativeLength: m } = A, r = (a3, b2) => {
          const { width: c2, height: d2 } = b2;
          return Math.log(400.979322 / Math.max((a3.x2 - a3.x1) / (c2 / 256), (a3.y2 - a3.y1) / (d2 / 256))) / Math.log(2);
        };
        class v {
          static mergeInsets(a3, b2) {
            const c2 = (a4) => {
              const b3 = {};
              a4.forEach((a5, c3) => {
                b3[a5 && a5.id || `i${c3}`] = a5;
              });
              return b3;
            }, d2 = p(c2(a3), c2(b2));
            return Object.keys(d2).map((a4) => d2[a4]);
          }
          createInsets() {
            const a3 = this.options, b2 = a3.insets;
            b2 && b2.forEach((b3) => {
              b3 = new G(this, p(a3.insetOptions, b3));
              this.insets.push(b3);
            });
          }
          constructor(d2, e2) {
            this.allowTransformAnimation = true;
            this.insets = [];
            this.padding = [0, 0, 0, 0];
            this.eventsToUnbind = [];
            let u, f2;
            if (!(this instanceof G)) {
              var g2 = [
                d2.options.chart.map,
                ...(d2.options.series || []).map((a4) => a4.mapData)
              ].map((a4) => this.getGeoMap(a4));
              const a3 = [];
              g2.forEach((b3) => {
                if (b3 && (u || (u = b3["hc-recommended-mapview"]), b3.bbox)) {
                  const [c2, d3, e3, u2] = b3.bbox;
                  a3.push({ x1: c2, y1: d3, x2: e3, y2: u2 });
                }
              });
              const b2 = a3.length && v.compositeBounds(a3);
              c(d2, "beforeMapViewInit", { geoBounds: b2 }, function() {
                if (b2) {
                  const { x1: a4, y1: c2, x2: d3, y2: e3 } = b2;
                  f2 = 180 < d3 - a4 && 90 < e3 - c2 ? { name: "EqualEarth" } : { name: "LambertConformalConic", parallels: [c2, e3], rotation: [-(a4 + d3) / 2] };
                }
              });
              this.geoMap = g2[0];
            }
            this.userOptions = e2 || {};
            d2.options.mapView && d2.options.mapView.recommendedMapView && (u = d2.options.mapView.recommendedMapView);
            g2 = p(a2, { projection: f2 }, u, e2);
            const h2 = u && u.insets;
            e2 = e2 && e2.insets;
            h2 && e2 && (g2.insets = v.mergeInsets(h2, e2));
            this.chart = d2;
            this.center = g2.center;
            this.options = g2;
            this.projection = new l(g2.projection);
            this.playingField = d2.plotBox;
            this.zoom = g2.zoom || 0;
            this.minZoom = g2.minZoom;
            this.createInsets();
            this.eventsToUnbind.push(F(d2, "afterSetChartSize", () => {
              this.playingField = this.getField();
              if (void 0 === this.minZoom || this.minZoom === this.zoom)
                this.fitToBounds(void 0, void 0, false), !this.chart.hasRendered && b(this.userOptions.zoom) && (this.zoom = this.userOptions.zoom), this.userOptions.center && p(true, this.center, this.userOptions.center);
            }));
            this.setUpEvents();
          }
          fitToBounds(a3, b2, c2 = true, d2) {
            const u = a3 || this.getProjectedBounds();
            if (u) {
              var f2 = C(b2, a3 ? 0 : this.options.padding);
              b2 = this.getField(false);
              f2 = e(f2) ? f2 : [f2, f2, f2, f2];
              this.padding = [m(f2[0], b2.height), m(f2[1], b2.width), m(f2[2], b2.height), m(f2[3], b2.width)];
              this.playingField = this.getField();
              b2 = r(u, this.playingField);
              a3 || (this.minZoom = b2);
              a3 = this.projection.inverse([(u.x2 + u.x1) / 2, (u.y2 + u.y1) / 2]);
              this.setView(a3, b2, c2, d2);
            }
          }
          getField(a3 = true) {
            a3 = a3 ? this.padding : [0, 0, 0, 0];
            return { x: a3[3], y: a3[0], width: this.chart.plotWidth - a3[1] - a3[3], height: this.chart.plotHeight - a3[0] - a3[2] };
          }
          getGeoMap(a3) {
            if (E(a3))
              return x[a3] && "Topology" === x[a3].type ? g(x[a3]) : x[a3];
            if (d(a3, true)) {
              if ("FeatureCollection" === a3.type)
                return a3;
              if ("Topology" === a3.type)
                return g(a3);
            }
          }
          getMapBBox() {
            const a3 = this.getProjectedBounds(), b2 = this.getScale();
            if (a3) {
              const c2 = this.padding, d2 = this.projectedUnitsToPixels({ x: a3.x1, y: a3.y2 });
              return {
                width: (a3.x2 - a3.x1) * b2 + c2[1] + c2[3],
                height: (a3.y2 - a3.y1) * b2 + c2[0] + c2[2],
                x: d2.x - c2[3],
                y: d2.y - c2[0]
              };
            }
          }
          getProjectedBounds() {
            const a3 = this.projection;
            var b2 = this.chart.series.reduce((a4, b3) => {
              const c3 = b3.getProjectedBounds && b3.getProjectedBounds();
              c3 && false !== b3.options.affectsMapView && a4.push(c3);
              return a4;
            }, []), c2 = this.options.fitToGeometry;
            return c2 ? (this.fitToGeometryCache || ("MultiPoint" === c2.type ? (c2 = c2.coordinates.map((b3) => a3.forward(b3)), b2 = c2.map((a4) => a4[0]), c2 = c2.map((a4) => a4[1]), this.fitToGeometryCache = {
              x1: Math.min.apply(0, b2),
              x2: Math.max.apply(0, b2),
              y1: Math.min.apply(0, c2),
              y2: Math.max.apply(0, c2)
            }) : this.fitToGeometryCache = t(a3.path(c2))), this.fitToGeometryCache) : this.projection.bounds || v.compositeBounds(b2);
          }
          getScale() {
            return 256 / 400.979322 * Math.pow(2, this.zoom);
          }
          getSVGTransform() {
            const { x: a3, y: b2, width: c2, height: d2 } = this.playingField, e2 = this.projection.forward(this.center);
            var f2 = this.projection.hasCoordinates ? -1 : 1;
            const g2 = this.getScale();
            f2 *= g2;
            return { scaleX: g2, scaleY: f2, translateX: a3 + c2 / 2 - e2[0] * g2, translateY: b2 + d2 / 2 - e2[1] * f2 };
          }
          lonLatToPixels(a3) {
            if (a3 = this.lonLatToProjectedUnits(a3))
              return this.projectedUnitsToPixels(a3);
          }
          lonLatToProjectedUnits(a3) {
            const b2 = this.chart, c2 = b2.mapTransforms;
            if (c2) {
              for (const e2 in c2)
                if (Object.hasOwnProperty.call(c2, e2) && c2[e2].hitZone) {
                  var d2 = b2.transformFromLatLon(a3, c2[e2]);
                  if (d2 && h(d2, c2[e2].hitZone.coordinates[0]))
                    return d2;
                }
              return b2.transformFromLatLon(a3, c2["default"]);
            }
            for (d2 of this.insets)
              if (d2.options.geoBounds && h({ x: a3.lon, y: a3.lat }, d2.options.geoBounds.coordinates[0]))
                return a3 = d2.projection.forward([a3.lon, a3.lat]), a3 = d2.projectedUnitsToPixels({ x: a3[0], y: a3[1] }), this.pixelsToProjectedUnits(a3);
            a3 = this.projection.forward([a3.lon, a3.lat]);
            if (!a3.outside)
              return {
                x: a3[0],
                y: a3[1]
              };
          }
          projectedUnitsToLonLat(a3) {
            var b2 = this.chart;
            const c2 = b2.mapTransforms;
            if (c2) {
              for (const d3 in c2)
                if (Object.hasOwnProperty.call(c2, d3) && c2[d3].hitZone && h(a3, c2[d3].hitZone.coordinates[0]))
                  return b2.transformToLatLon(a3, c2[d3]);
              return b2.transformToLatLon(a3, c2["default"]);
            }
            b2 = this.projectedUnitsToPixels(a3);
            for (var d2 of this.insets)
              if (d2.hitZone && h(b2, d2.hitZone.coordinates[0]))
                return a3 = d2.pixelsToProjectedUnits(b2), d2 = d2.projection.inverse([a3.x, a3.y]), { lon: d2[0], lat: d2[1] };
            d2 = this.projection.inverse([a3.x, a3.y]);
            return {
              lon: d2[0],
              lat: d2[1]
            };
          }
          redraw(a3) {
            this.chart.series.forEach((a4) => {
              a4.useMapGeometry && (a4.isDirty = true);
            });
            this.chart.redraw(a3);
          }
          setView(a3, d2, e2 = true, f2) {
            a3 && (this.center = a3);
            "number" === typeof d2 && ("number" === typeof this.minZoom && (d2 = Math.max(d2, this.minZoom)), "number" === typeof this.options.maxZoom && (d2 = Math.min(d2, this.options.maxZoom)), b(d2) && (this.zoom = d2));
            var g2 = this.getProjectedBounds();
            if (g2) {
              a3 = this.projection.forward(this.center);
              const { x: b2, y: c2, width: e3, height: f3 } = this.playingField;
              d2 = this.getScale();
              var h2 = this.projectedUnitsToPixels({
                x: g2.x1,
                y: g2.y1
              }), u = this.projectedUnitsToPixels({ x: g2.x2, y: g2.y2 });
              g2 = [(g2.x1 + g2.x2) / 2, (g2.y1 + g2.y2) / 2];
              if (!this.chart.series.some((a4) => a4.isDrilling)) {
                const m2 = h2.x, r2 = u.y;
                u = u.x;
                h2 = h2.y;
                u - m2 < e3 ? a3[0] = g2[0] : m2 < b2 && u < b2 + e3 ? a3[0] += Math.max(m2 - b2, u - e3 - b2) / d2 : u > b2 + e3 && m2 > b2 && (a3[0] += Math.min(u - e3 - b2, m2 - b2) / d2);
                h2 - r2 < f3 ? a3[1] = g2[1] : r2 < c2 && h2 < c2 + f3 ? a3[1] -= Math.max(r2 - c2, h2 - f3 - c2) / d2 : h2 > c2 + f3 && r2 > c2 && (a3[1] -= Math.min(h2 - f3 - c2, r2 - c2) / d2);
                this.center = this.projection.inverse(a3);
              }
              this.insets.forEach((a4) => {
                a4.options.field && (a4.hitZone = a4.getHitZone(), a4.playingField = a4.getField());
              });
              this.render();
            }
            c(
              this,
              "afterSetView"
            );
            e2 && this.redraw(f2);
          }
          projectedUnitsToPixels(a3) {
            const b2 = this.getScale(), c2 = this.projection.forward(this.center), d2 = this.playingField;
            return { x: d2.x + d2.width / 2 - b2 * (c2[0] - a3.x), y: d2.y + d2.height / 2 + b2 * (c2[1] - a3.y) };
          }
          pixelsToLonLat(a3) {
            return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(a3));
          }
          pixelsToProjectedUnits(a3) {
            const { x: b2, y: c2 } = a3;
            a3 = this.getScale();
            const d2 = this.projection.forward(this.center), e2 = this.playingField;
            return { x: d2[0] + (b2 - (e2.x + e2.width / 2)) / a3, y: d2[1] - (c2 - (e2.y + e2.height / 2)) / a3 };
          }
          setUpEvents() {
            const { chart: a3 } = this;
            let c2, d2, e2;
            const g2 = (g3) => {
              var h2 = a3.pointer.pinchDown, m2 = this.projection;
              let { mouseDownX: u, mouseDownY: p2 } = a3;
              1 === h2.length && (u = h2[0].chartX, p2 = h2[0].chartY);
              if ("number" === typeof u && "number" === typeof p2) {
                h2 = `${u},${p2}`;
                const { chartX: v2, chartY: k2 } = g3.originalEvent;
                h2 !== d2 && (d2 = h2, c2 = this.projection.forward(this.center), e2 = (this.projection.options.rotation || [0, 0]).slice());
                h2 = (h2 = m2.def && m2.def.bounds) && r(h2, this.playingField) || -Infinity;
                if ("Orthographic" === m2.options.name && (this.minZoom || Infinity) < 1.3 * h2) {
                  if (h2 = 440 / (this.getScale() * Math.min(a3.plotWidth, a3.plotHeight)), e2) {
                    m2 = (u - v2) * h2 - e2[0];
                    h2 = f(-e2[1] - (p2 - k2) * h2, -80, 80);
                    const b2 = this.zoom;
                    this.update({ projection: { rotation: [-m2, -h2] } }, false);
                    this.fitToBounds(void 0, void 0, false);
                    this.zoom = b2;
                    a3.redraw(false);
                  }
                } else
                  b(v2) && b(k2) && (m2 = this.getScale(), m2 = this.projection.inverse([c2[0] + (u - v2) / m2, c2[1] - (p2 - k2) / m2 * (this.projection.hasCoordinates ? 1 : -1)]), this.setView(m2, void 0, true, false));
                g3.preventDefault();
              }
            };
            F(a3, "pan", g2);
            F(a3, "touchpan", g2);
            F(a3, "selection", (b2) => {
              if (b2.resetSelection)
                this.zoomBy();
              else {
                const c3 = b2.x - a3.plotLeft, d3 = b2.y - a3.plotTop, { y: e3, x: f2 } = this.pixelsToProjectedUnits({ x: c3, y: d3 }), { y: g3, x: h2 } = this.pixelsToProjectedUnits({ x: c3 + b2.width, y: d3 + b2.height });
                this.fitToBounds({ x1: f2, y1: e3, x2: h2, y2: g3 }, void 0, true, b2.originalEvent.touches ? false : void 0);
                /^touch/.test(b2.originalEvent.type) || a3.showResetZoom();
                b2.preventDefault();
              }
            });
          }
          render() {
            this.group || (this.group = this.chart.renderer.g("map-view").attr({ zIndex: 4 }).add());
          }
          update(a3, c2 = true, d2) {
            var e2 = a3.projection;
            e2 = e2 && l.toString(e2) !== l.toString(this.options.projection);
            let f2 = false;
            p(
              true,
              this.userOptions,
              a3
            );
            p(true, this.options, a3);
            "insets" in a3 && (this.insets.forEach((a4) => a4.destroy()), this.insets.length = 0, f2 = true);
            (e2 || "fitToGeometry" in a3) && delete this.fitToGeometryCache;
            if (e2 || f2)
              this.chart.series.forEach((a4) => {
                const b2 = a4.transformGroups;
                a4.clearBounds && a4.clearBounds();
                a4.isDirty = true;
                a4.isDirtyData = true;
                if (f2 && b2)
                  for (; 1 < b2.length; )
                    (a4 = b2.pop()) && a4.destroy();
              }), e2 && (this.projection = new l(this.options.projection)), f2 && this.createInsets(), a3.center || !Object.hasOwnProperty.call(a3, "zoom") || b(a3.zoom) || this.fitToBounds(
                void 0,
                void 0,
                false
              );
            a3.center || b(a3.zoom) ? this.setView(this.options.center, a3.zoom, false) : "fitToGeometry" in a3 && this.fitToBounds(void 0, void 0, false);
            c2 && this.chart.redraw(d2);
          }
          zoomBy(a3, b2, c2, d2) {
            var e2 = this.chart;
            const f2 = this.projection.forward(this.center);
            let [g2, h2] = b2 ? this.projection.forward(b2) : [];
            if ("number" === typeof a3) {
              a3 = this.zoom + a3;
              if (c2) {
                const [a4, d3] = c2;
                c2 = this.getScale();
                b2 = d3 - e2.plotTop - e2.plotHeight / 2;
                g2 = f2[0] + (a4 - e2.plotLeft - e2.plotWidth / 2) / c2;
                h2 = f2[1] + b2 / c2;
              }
              if ("number" === typeof g2 && "number" === typeof h2) {
                e2 = 1 - Math.pow(2, this.zoom) / Math.pow(
                  2,
                  a3
                );
                var m2 = f2[1] - h2;
                f2[0] -= (f2[0] - g2) * e2;
                f2[1] += m2 * e2;
                m2 = this.projection.inverse(f2);
              }
              this.setView(m2, a3, void 0, d2);
            } else
              this.fitToBounds(void 0, void 0, void 0, d2);
          }
        }
        v.compositeBounds = (a3) => {
          if (a3.length)
            return a3.slice(1).reduce((a4, b2) => {
              a4.x1 = Math.min(a4.x1, b2.x1);
              a4.y1 = Math.min(a4.y1, b2.y1);
              a4.x2 = Math.max(a4.x2, b2.x2);
              a4.y2 = Math.max(a4.y2, b2.y2);
              return a4;
            }, p(a3[0]));
        };
        class G extends v {
          constructor(a3, b2) {
            super(a3.chart, b2);
            this.id = b2.id;
            this.mapView = a3;
            this.options = p(n, b2);
            this.allBounds = [];
            this.options.geoBounds && (a3 = a3.projection.path(this.options.geoBounds), this.geoBoundsProjectedBox = t(a3), this.geoBoundsProjectedPolygon = a3.map((a4) => [a4[1] || 0, a4[2] || 0]));
          }
          getField(a3 = true) {
            var c2 = this.hitZone;
            if (c2) {
              var d2 = a3 ? this.padding : [0, 0, 0, 0];
              c2 = c2.coordinates[0];
              var e2 = c2.map((a4) => a4[0]);
              const f2 = c2.map((a4) => a4[1]);
              c2 = Math.min.apply(0, e2) + d2[3];
              e2 = Math.max.apply(0, e2) - d2[1];
              const g2 = Math.min.apply(0, f2) + d2[0];
              d2 = Math.max.apply(0, f2) - d2[2];
              if (b(c2) && b(g2))
                return { x: c2, y: g2, width: e2 - c2, height: d2 - g2 };
            }
            return super.getField.call(this, a3);
          }
          getHitZone() {
            const { chart: a3, mapView: b2, options: c2 } = this;
            var { coordinates: d2 } = c2.field || {};
            if (d2) {
              d2 = d2[0];
              if ("percent" === c2.units) {
                const e2 = "mapBoundingBox" === c2.relativeTo && b2.getMapBBox() || p(a3.plotBox, { x: 0, y: 0 });
                d2 = d2.map((a4) => [m(`${a4[0]}%`, e2.width, e2.x), m(`${a4[1]}%`, e2.height, e2.y)]);
              }
              return { type: "Polygon", coordinates: [d2] };
            }
          }
          getProjectedBounds() {
            return v.compositeBounds(this.allBounds);
          }
          isInside(a3) {
            const { geoBoundsProjectedBox: b2, geoBoundsProjectedPolygon: c2 } = this;
            return !!(b2 && a3.x >= b2.x1 && a3.x <= b2.x2 && a3.y >= b2.y1 && a3.y <= b2.y2 && c2 && h(a3, c2));
          }
          render() {
            const { chart: a3, mapView: b2, options: c2 } = this;
            var d2 = c2.borderPath || c2.field;
            if (d2 && b2.group) {
              let e2 = true;
              this.border || (this.border = a3.renderer.path().addClass("highcharts-mapview-inset-border").add(b2.group), e2 = false);
              a3.styledMode || this.border.attr({ stroke: c2.borderColor, "stroke-width": c2.borderWidth });
              const f2 = Math.round(this.border.strokeWidth()) % 2 / 2, g2 = "mapBoundingBox" === c2.relativeTo && b2.getMapBBox() || b2.playingField;
              d2 = (d2.coordinates || []).reduce((b3, d3) => d3.reduce((b4, d4, e3) => {
                let [h2, r2] = d4;
                "percent" === c2.units && (h2 = a3.plotLeft + m(`${h2}%`, g2.width, g2.x), r2 = a3.plotTop + m(`${r2}%`, g2.height, g2.y));
                h2 = Math.floor(h2) + f2;
                r2 = Math.floor(r2) + f2;
                b4.push(0 === e3 ? ["M", h2, r2] : ["L", h2, r2]);
                return b4;
              }, b3), []);
              this.border[e2 ? "animate" : "attr"]({ d: d2 });
            }
          }
          destroy() {
            this.border && (this.border = this.border.destroy());
            this.eventsToUnbind.forEach((a3) => a3());
          }
          setUpEvents() {
          }
        }
        F(z, "afterInit", function() {
          this.mapView = new v(this, this.options.mapView);
        });
        return v;
      });
      y(a, "Series/Map/MapSeries.js", [
        a["Core/Animation/AnimationUtilities.js"],
        a["Series/ColorMapComposition.js"],
        a["Series/CenteredUtilities.js"],
        a["Core/Globals.js"],
        a["Core/Chart/MapChart.js"],
        a["Series/Map/MapPoint.js"],
        a["Maps/MapView.js"],
        a["Core/Series/Series.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Utilities.js"]
      ], function(a2, n, q, z, k, l, A, w, x, t, h) {
        const { animObject: g, stop: f } = a2;
        ({ noop: a2 } = z);
        const { splitPath: c } = k, { seriesTypes: { column: e, scatter: b } } = x, { extend: d, find: E, fireEvent: p, getNestedProperty: C, isArray: m, defined: r, isNumber: v, isObject: G, merge: u, objectEach: B, pick: D, splat: H } = h;
        class y2 extends b {
          constructor() {
            super(...arguments);
            this.points = this.options = this.joinBy = this.group = this.data = this.chart = void 0;
            this.processedData = [];
          }
          animate(a3) {
            const { chart: b2, group: c2 } = this, d2 = g(this.options.animation);
            a3 ? c2.attr({ translateX: b2.plotLeft + b2.plotWidth / 2, translateY: b2.plotTop + b2.plotHeight / 2, scaleX: 1e-3, scaleY: 1e-3 }) : c2.animate({ translateX: b2.plotLeft, translateY: b2.plotTop, scaleX: 1, scaleY: 1 }, d2);
          }
          clearBounds() {
            this.points.forEach((a3) => {
              delete a3.bounds;
              delete a3.insetIndex;
              delete a3.projectedPath;
            });
            delete this.bounds;
          }
          doFullTranslate() {
            return !(!this.isDirtyData && !this.chart.isResizing && this.hasRendered);
          }
          drawMapDataLabels() {
            w.prototype.drawDataLabels.call(this);
            this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
          }
          drawPoints() {
            const a3 = this, { chart: b2, group: c2, transformGroups: d2 = [] } = this, { mapView: h2, renderer: m2 } = b2;
            h2 && (this.transformGroups = d2, d2[0] || (d2[0] = m2.g().add(c2)), h2.insets.forEach((a4, b3) => {
              d2[b3 + 1] || d2.push(m2.g().add(c2));
            }), this.doFullTranslate() && (this.points.forEach((a4) => {
              const { graphic: c3, shapeArgs: e2 } = a4;
              a4.group = d2["number" === typeof a4.insetIndex ? a4.insetIndex + 1 : 0];
              c3 && c3.parentGroup !== a4.group && c3.add(a4.group);
              e2 && b2.hasRendered && !b2.styledMode && (e2.fill = this.pointAttribs(a4, a4.state).fill);
            }), e.prototype.drawPoints.apply(this), this.points.forEach((c3) => {
              const d3 = c3.graphic;
              if (d3) {
                const e2 = d3.animate;
                let f2 = "";
                c3.name && (f2 += "highcharts-name-" + c3.name.replace(/ /g, "-").toLowerCase());
                c3.properties && c3.properties["hc-key"] && (f2 += " highcharts-key-" + c3.properties["hc-key"].toString().toLowerCase());
                f2 && d3.addClass(f2);
                b2.styledMode && d3.css(this.pointAttribs(c3, c3.selected && "select" || void 0));
                d3.animate = function(c4, f3, g2) {
                  const h3 = v(c4["stroke-width"]) && !v(d3["stroke-width"]), m3 = v(d3["stroke-width"]) && !v(c4["stroke-width"]);
                  if (h3 || m3) {
                    const e3 = D(a3.getStrokeWidth(a3.options), 1) / (b2.mapView && b2.mapView.getScale() || 1);
                    h3 && (d3["stroke-width"] = e3);
                    m3 && (c4["stroke-width"] = e3);
                  }
                  return e2.call(d3, c4, f3, m3 ? function() {
                    d3.element.removeAttribute("stroke-width");
                    delete d3["stroke-width"];
                    g2 && g2.apply(this, arguments);
                  } : g2);
                };
              }
            })), d2.forEach((c3, d3) => {
              const e2 = (0 === d3 ? h2 : h2.insets[d3 - 1]).getSVGTransform(), r2 = D(
                this.getStrokeWidth(this.options),
                1
              ), p2 = e2.scaleX, v2 = 0 < e2.scaleY ? 1 : -1, k2 = (b3) => {
                (a3.points || []).forEach((a4) => {
                  const c4 = a4.graphic;
                  let d4;
                  c4 && c4["stroke-width"] && (d4 = this.getStrokeWidth(a4.options)) && c4.attr({ "stroke-width": d4 / b3 });
                });
              };
              if (m2.globalAnimation && b2.hasRendered && h2.allowTransformAnimation) {
                const a4 = Number(c3.attr("translateX")), b3 = Number(c3.attr("translateY")), f2 = Number(c3.attr("scaleX")), h3 = (d4, g2) => {
                  d4 = f2 + (p2 - f2) * g2.pos;
                  c3.attr({ translateX: a4 + (e2.translateX - a4) * g2.pos, translateY: b3 + (e2.translateY - b3) * g2.pos, scaleX: d4, scaleY: d4 * v2, "stroke-width": r2 / d4 });
                  k2(d4);
                };
                d3 = u(g(m2.globalAnimation));
                const l2 = d3.step;
                d3.step = function(a5) {
                  l2 && l2.apply(this, arguments);
                  h3.apply(this, arguments);
                };
                c3.attr({ animator: 0 }).animate({ animator: 1 }, d3, function() {
                  "boolean" !== typeof m2.globalAnimation && m2.globalAnimation.complete && m2.globalAnimation.complete({ applyDrilldown: true });
                });
              } else
                f(c3), c3.attr(u(e2, { "stroke-width": r2 / p2 })), k2(p2);
            }), this.isDrilling || this.drawMapDataLabels());
          }
          getProjectedBounds() {
            if (!this.bounds && this.chart.mapView) {
              const { insets: a3, projection: b2 } = this.chart.mapView, d2 = [];
              (this.points || []).forEach(function(e2) {
                if (e2.path || e2.geometry) {
                  "string" === typeof e2.path ? e2.path = c(e2.path) : m(e2.path) && "M" === e2.path[0] && (e2.path = t.prototype.pathToSegments(e2.path));
                  if (!e2.bounds) {
                    let c2 = e2.getProjectedBounds(b2);
                    if (c2) {
                      e2.labelrank = D(e2.labelrank, (c2.x2 - c2.x1) * (c2.y2 - c2.y1));
                      const { midX: b3, midY: d3 } = c2;
                      if (a3 && v(b3) && v(d3)) {
                        const f2 = E(a3, (a4) => a4.isInside({ x: b3, y: d3 }));
                        f2 && (delete e2.projectedPath, (c2 = e2.getProjectedBounds(f2.projection)) && f2.allBounds.push(c2), e2.insetIndex = a3.indexOf(f2));
                      }
                      e2.bounds = c2;
                    }
                  }
                  e2.bounds && void 0 === e2.insetIndex && d2.push(e2.bounds);
                }
              });
              this.bounds = A.compositeBounds(d2);
            }
            return this.bounds;
          }
          getStrokeWidth(a3) {
            const b2 = this.pointAttrToOptions;
            return a3[b2 && b2["stroke-width"] || "borderWidth"];
          }
          hasData() {
            return !!this.processedXData.length;
          }
          pointAttribs(a3, b2) {
            var c2;
            const { mapView: d2, styledMode: f2 } = a3.series.chart, g2 = f2 ? this.colorAttribs(a3) : e.prototype.pointAttribs.call(this, a3, b2);
            let h2 = this.getStrokeWidth(a3.options);
            if (b2) {
              b2 = u(this.options.states[b2], a3.options.states && a3.options.states[b2] || {});
              const d3 = this.getStrokeWidth(b2);
              r(d3) && (h2 = d3);
              g2.stroke = null !== (c2 = b2.borderColor) && void 0 !== c2 ? c2 : a3.color;
            }
            h2 && d2 && (h2 /= d2.getScale());
            c2 = this.getStrokeWidth(this.options);
            g2.dashstyle && d2 && v(c2) && (h2 = c2 / d2.getScale());
            a3.visible || (g2.fill = this.options.nullColor);
            r(h2) ? g2["stroke-width"] = h2 : delete g2["stroke-width"];
            g2["stroke-linecap"] = g2["stroke-linejoin"] = this.options.linecap;
            return g2;
          }
          updateData() {
            return this.processedData ? false : super.updateData.apply(this, arguments);
          }
          setData(a3, b2 = true, c2, d2) {
            delete this.bounds;
            super.setData.call(this, a3, false, void 0, d2);
            this.processData();
            this.generatePoints();
            b2 && this.chart.redraw(c2);
          }
          processData() {
            const a3 = this.options, b2 = a3.data;
            var c2 = this.chart.options.chart;
            const d2 = this.joinBy, e2 = a3.keys || this.pointArrayMap, f2 = [], g2 = {};
            var h2 = this.chart.mapView;
            h2 = h2 && (G(a3.mapData, true) ? h2.getGeoMap(a3.mapData) : h2.geoMap);
            var r2 = this.chart.mapTransforms;
            (this.chart.mapTransforms = r2 = c2.mapTransforms || h2 && h2["hc-transform"] || r2) && B(r2, function(a4) {
              a4.rotation && (a4.cosAngle = Math.cos(a4.rotation), a4.sinAngle = Math.sin(a4.rotation));
            });
            let p2;
            m(a3.mapData) ? p2 = a3.mapData : h2 && "FeatureCollection" === h2.type && (this.mapTitle = h2.title, p2 = z.geojson(h2, this.type, this));
            const k2 = this.processedData = [];
            b2 && b2.forEach(function(c3, f3) {
              let h3 = 0;
              if (v(c3))
                k2[f3] = { value: c3 };
              else if (m(c3)) {
                k2[f3] = {};
                !a3.keys && c3.length > e2.length && "string" === typeof c3[0] && (k2[f3]["hc-key"] = c3[0], ++h3);
                for (let a4 = 0; a4 < e2.length; ++a4, ++h3)
                  e2[a4] && "undefined" !== typeof c3[h3] && (0 < e2[a4].indexOf(".") ? l.prototype.setNestedProperty(k2[f3], c3[h3], e2[a4]) : k2[f3][e2[a4]] = c3[h3]);
              } else
                k2[f3] = b2[f3];
              d2 && "_i" === d2[0] && (k2[f3]._i = f3);
            });
            if (p2) {
              this.mapData = p2;
              this.mapMap = {};
              for (r2 = 0; r2 < p2.length; r2++)
                c2 = p2[r2], h2 = c2.properties, c2._i = r2, d2[0] && h2 && h2[d2[0]] && (c2[d2[0]] = h2[d2[0]]), g2[c2[d2[0]]] = c2;
              this.mapMap = g2;
              if (d2[1]) {
                const a4 = d2[1];
                k2.forEach(function(b3) {
                  b3 = C(a4, b3);
                  g2[b3] && f2.push(g2[b3]);
                });
              }
              if (a3.allAreas) {
                if (d2[1]) {
                  const a5 = d2[1];
                  k2.forEach(function(b3) {
                    f2.push(C(a5, b3));
                  });
                }
                const a4 = "|" + f2.map(function(a5) {
                  return a5 && a5[d2[0]];
                }).join("|") + "|";
                p2.forEach(function(b3) {
                  d2[0] && -1 !== a4.indexOf("|" + b3[d2[0]] + "|") || k2.push(u(b3, { value: null }));
                });
              }
            }
            this.processedXData = Array(k2.length);
          }
          setOptions(a3) {
            a3 = w.prototype.setOptions.call(this, a3);
            let b2 = a3.joinBy;
            null === b2 && (b2 = "_i");
            b2 = this.joinBy = H(b2);
            b2[1] || (b2[1] = b2[0]);
            return a3;
          }
          translate() {
            const a3 = this.doFullTranslate(), b2 = this.chart.mapView, c2 = b2 && b2.projection;
            !this.chart.hasRendered || !this.isDirtyData && this.hasRendered || (this.processData(), this.generatePoints(), delete this.bounds, !b2 || b2.userOptions.center || v(b2.userOptions.zoom) || b2.zoom !== b2.minZoom ? this.getProjectedBounds() : b2.fitToBounds(void 0, void 0, false));
            if (b2) {
              const d2 = b2.getSVGTransform();
              this.points.forEach(function(e2) {
                const f2 = v(e2.insetIndex) && b2.insets[e2.insetIndex].getSVGTransform() || d2;
                f2 && e2.bounds && v(e2.bounds.midX) && v(e2.bounds.midY) && (e2.plotX = e2.bounds.midX * f2.scaleX + f2.translateX, e2.plotY = e2.bounds.midY * f2.scaleY + f2.translateY);
                a3 && (e2.shapeType = "path", e2.shapeArgs = { d: l.getProjectedPath(e2, c2) });
                e2.projectedPath && !e2.projectedPath.length ? e2.setVisible(false) : e2.setVisible(true);
              });
            }
            p(this, "afterTranslate");
          }
        }
        y2.defaultOptions = u(b.defaultOptions, {
          affectsMapView: true,
          animation: false,
          dataLabels: { crop: false, formatter: function() {
            const { numberFormatter: a3 } = this.series.chart, { value: b2 } = this.point;
            return v(b2) ? a3(b2, -1) : "";
          }, inside: true, overflow: false, padding: 0, verticalAlign: "middle" },
          linecap: "round",
          marker: null,
          nullColor: "#f7f7f7",
          stickyTracking: false,
          tooltip: { followPointer: true, pointFormat: "{point.name}: {point.value}<br/>" },
          turboThreshold: 0,
          allAreas: true,
          borderColor: "#e6e6e6",
          borderWidth: 1,
          joinBy: "hc-key",
          states: { hover: { halo: void 0, borderColor: "#666666", borderWidth: 2 }, normal: { animation: true }, select: { color: "#cccccc" } },
          legendSymbol: "rectangle"
        });
        d(y2.prototype, {
          type: "map",
          axisTypes: n.seriesMembers.axisTypes,
          colorAttribs: n.seriesMembers.colorAttribs,
          colorKey: n.seriesMembers.colorKey,
          directTouch: true,
          drawDataLabels: a2,
          drawGraph: a2,
          forceDL: true,
          getCenter: q.getCenter,
          getExtremesFromAll: true,
          getSymbol: a2,
          isCartesian: false,
          parallelArrays: n.seriesMembers.parallelArrays,
          pointArrayMap: n.seriesMembers.pointArrayMap,
          pointClass: l,
          preserveAspectRatio: true,
          searchPoint: a2,
          trackerGroups: n.seriesMembers.trackerGroups,
          useMapGeometry: true
        });
        n.compose(y2);
        x.registerSeriesType("map", y2);
        "";
        return y2;
      });
      y(a, "Series/MapLine/MapLineSeries.js", [a["Series/Map/MapSeries.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n, q) {
        const { extend: g, merge: k } = q;
        class l extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
          }
          pointAttribs(g2, k2) {
            g2 = a2.prototype.pointAttribs.call(this, g2, k2);
            g2.fill = this.options.fillColor;
            return g2;
          }
        }
        l.defaultOptions = k(a2.defaultOptions, { lineWidth: 1, fillColor: "none", legendSymbol: "lineMarker" });
        g(l.prototype, { type: "mapline", colorProp: "stroke", pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" } });
        n.registerSeriesType("mapline", l);
        "";
        return l;
      });
      y(a, "Series/MapPoint/MapPointPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n) {
        ({ seriesTypes: { scatter: a2 } } = a2);
        const { isNumber: g } = n;
        class z extends a2.prototype.pointClass {
          constructor() {
            super(...arguments);
            this.series = this.options = void 0;
          }
          isValid() {
            return !!(this.options.geometry || g(this.x) && g(this.y) || g(this.options.lon) && g(this.options.lat));
          }
        }
        return z;
      });
      y(a, "Series/MapPoint/MapPointSeries.js", [a["Core/Globals.js"], a["Series/MapPoint/MapPointPoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Renderer/SVG/SVGRenderer.js"], a["Core/Utilities.js"]], function(a2, n, q, z, k) {
        ({ noop: a2 } = a2);
        const { seriesTypes: { map: g, scatter: A } } = q, { extend: w, fireEvent: x, isNumber: t, merge: h } = k;
        class y2 extends A {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = this.chart = void 0;
            this.clearBounds = g.prototype.clearBounds;
          }
          drawDataLabels() {
            super.drawDataLabels();
            this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);
          }
          projectPoint(a3) {
            const c = this.chart.mapView;
            if (c) {
              const { geometry: e, lon: b, lat: d } = a3;
              a3 = e && "Point" === e.type && e.coordinates;
              t(b) && t(d) && (a3 = [b, d]);
              if (a3)
                return c.lonLatToProjectedUnits({
                  lon: a3[0],
                  lat: a3[1]
                });
            }
          }
          translate() {
            const a3 = this.chart.mapView;
            this.processedXData || this.processData();
            this.generatePoints();
            this.getProjectedBounds && this.isDirtyData && (delete this.bounds, this.getProjectedBounds());
            if (a3) {
              const c = a3.getSVGTransform(), { hasCoordinates: e } = a3.projection;
              this.points.forEach((b) => {
                let { x: d, y: f } = b;
                var h2 = t(b.insetIndex) && a3.insets[b.insetIndex].getSVGTransform() || c;
                const g2 = this.projectPoint(b.options) || b.properties && this.projectPoint(b.properties);
                let m;
                g2 ? (d = g2.x, f = g2.y) : b.bounds && (d = b.bounds.midX, f = b.bounds.midY, h2 && t(d) && t(f) && (b.plotX = d * h2.scaleX + h2.translateX, b.plotY = f * h2.scaleY + h2.translateY, m = true));
                t(d) && t(f) ? m || (h2 = a3.projectedUnitsToPixels({ x: d, y: f }), b.plotX = h2.x, b.plotY = e ? h2.y : this.chart.plotHeight - h2.y) : b.y = b.plotX = b.plotY = void 0;
                b.isInside = this.isPointInside(b);
                b.zone = this.zones.length ? b.getZone() : void 0;
              });
            }
            x(this, "afterTranslate");
          }
        }
        y2.defaultOptions = h(A.defaultOptions, { dataLabels: { crop: false, defer: false, enabled: true, formatter: function() {
          return this.point.name;
        }, overflow: false, style: { color: "#000000" } }, legendSymbol: "lineMarker" });
        z.prototype.symbols.mapmarker = (a3, c, e, b, d) => {
          const f = d && "legend" === d.context;
          f ? (a3 += e / 2, d = c + b) : d && "number" === typeof d.anchorX && "number" === typeof d.anchorY ? (a3 = d.anchorX, d = d.anchorY) : (a3 += e / 2, d = c + b / 2, c -= b);
          b = f ? b / 3 : b / 2;
          return [["M", a3, d], ["C", a3, d, a3 - b, c + 1.5 * b, a3 - b, c + b], ["A", b, b, 1, 1, 1, a3 + b, c + b], ["C", a3 + b, c + 1.5 * b, a3, d, a3, d], ["Z"]];
        };
        w(y2.prototype, { type: "mappoint", axisTypes: ["colorAxis"], forceDL: true, isCartesian: false, pointClass: n, searchPoint: a2, useMapGeometry: true });
        q.registerSeriesType("mappoint", y2);
        "";
        return y2;
      });
      y(
        a,
        "Series/Bubble/BubbleLegendDefaults.js",
        [],
        function() {
          return { borderColor: void 0, borderWidth: 2, className: void 0, color: void 0, connectorClassName: void 0, connectorColor: void 0, connectorDistance: 60, connectorWidth: 1, enabled: false, labels: { className: void 0, allowOverlap: false, format: "", formatter: void 0, align: "right", style: { fontSize: "0.9em", color: "#000000" }, x: 0, y: 0 }, maxSize: 60, minSize: 10, legendIndex: 0, ranges: { value: void 0, borderColor: void 0, color: void 0, connectorColor: void 0 }, sizeBy: "area", sizeByAbsoluteValue: false, zIndex: 1, zThreshold: 0 };
        }
      );
      y(
        a,
        "Series/Bubble/BubbleLegendItem.js",
        [a["Core/Color/Color.js"], a["Core/Templating.js"], a["Core/Globals.js"], a["Core/Utilities.js"]],
        function(a2, n, q, z) {
          const { parse: g } = a2, { noop: l } = q, { arrayMax: A, arrayMin: w, isNumber: x, merge: t, pick: h, stableSort: y2 } = z;
          class f {
            constructor(a3, e) {
              this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legend = this.chart = void 0;
              this.setState = l;
              this.init(a3, e);
            }
            init(a3, e) {
              this.options = a3;
              this.visible = true;
              this.chart = e.chart;
              this.legend = e;
            }
            addToLegend(a3) {
              a3.splice(
                this.options.legendIndex,
                0,
                this
              );
            }
            drawLegendSymbol(a3) {
              const c = h(a3.options.itemDistance, 20), b = this.legendItem || {}, d = this.options;
              var f2 = d.ranges, g2 = d.connectorDistance;
              if (f2 && f2.length && x(f2[0].value)) {
                y2(f2, function(a4, b2) {
                  return b2.value - a4.value;
                });
                this.ranges = f2;
                this.setOptions();
                this.render();
                a3 = this.getMaxLabelSize();
                var k = this.ranges[0].radius;
                f2 = 2 * k;
                g2 = g2 - k + a3.width;
                g2 = 0 < g2 ? g2 : 0;
                this.maxLabel = a3;
                this.movementX = "left" === d.labels.align ? g2 : 0;
                b.labelWidth = f2 + g2 + c;
                b.labelHeight = f2 + a3.height / 2;
              } else
                a3.options.bubbleLegend.autoRanges = true;
            }
            setOptions() {
              const a3 = this.ranges, e = this.options, b = this.chart.series[e.seriesIndex], d = this.legend.baseline, f2 = { zIndex: e.zIndex, "stroke-width": e.borderWidth }, k = { zIndex: e.zIndex, "stroke-width": e.connectorWidth }, l2 = { align: this.legend.options.rtl || "left" === e.labels.align ? "right" : "left", zIndex: e.zIndex }, m = b.options.marker.fillOpacity, r = this.chart.styledMode;
              a3.forEach(function(c, p) {
                r || (f2.stroke = h(c.borderColor, e.borderColor, b.color), f2.fill = h(c.color, e.color, 1 !== m ? g(b.color).setOpacity(m).get("rgba") : b.color), k.stroke = h(
                  c.connectorColor,
                  e.connectorColor,
                  b.color
                ));
                a3[p].radius = this.getRangeRadius(c.value);
                a3[p] = t(a3[p], { center: a3[0].radius - a3[p].radius + d });
                r || t(true, a3[p], { bubbleAttribs: t(f2), connectorAttribs: t(k), labelAttribs: l2 });
              }, this);
            }
            getRangeRadius(a3) {
              const c = this.options;
              return this.chart.series[this.options.seriesIndex].getRadius.call(this, c.ranges[c.ranges.length - 1].value, c.ranges[0].value, c.minSize, c.maxSize, a3);
            }
            render() {
              const a3 = this.legendItem || {}, e = this.chart.renderer, b = this.options.zThreshold;
              this.symbols || (this.symbols = {
                connectors: [],
                bubbleItems: [],
                labels: []
              });
              a3.symbol = e.g("bubble-legend");
              a3.label = e.g("bubble-legend-item").css(this.legend.itemStyle || {});
              a3.symbol.translateX = 0;
              a3.symbol.translateY = 0;
              a3.symbol.add(a3.label);
              a3.label.add(a3.group);
              for (const a4 of this.ranges)
                a4.value >= b && this.renderRange(a4);
              this.hideOverlappingLabels();
            }
            renderRange(a3) {
              var c = this.options;
              const b = c.labels;
              var d = this.chart;
              const f2 = d.series[c.seriesIndex], h2 = d.renderer, g2 = this.symbols;
              d = g2.labels;
              const m = a3.center, r = Math.abs(a3.radius);
              var k = c.connectorDistance || 0;
              const l2 = b.align, n2 = c.connectorWidth, w2 = this.ranges[0].radius || 0, t2 = m - r - c.borderWidth / 2 + n2 / 2, q2 = h2.styledMode;
              k = this.legend.options.rtl || "left" === l2 ? -k : k;
              "center" === l2 && (k = 0, c.connectorDistance = 0, a3.labelAttribs.align = "center");
              g2.bubbleItems.push(h2.circle(w2, m + ((t2 % 1 ? 1 : 0.5) - (n2 % 2 ? 0 : 0.5)), r).attr(q2 ? {} : a3.bubbleAttribs).addClass((q2 ? "highcharts-color-" + f2.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (c.className || "")).add(this.legendItem.symbol));
              g2.connectors.push(h2.path(h2.crispLine(
                [["M", w2, t2], ["L", w2 + k, t2]],
                c.connectorWidth
              )).attr(q2 ? {} : a3.connectorAttribs).addClass((q2 ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (c.connectorClassName || "")).add(this.legendItem.symbol));
              a3 = h2.text(this.formatLabel(a3)).attr(q2 ? {} : a3.labelAttribs).css(q2 ? {} : b.style).addClass("highcharts-bubble-legend-labels " + (c.labels.className || "")).add(this.legendItem.symbol);
              c = { x: w2 + k + c.labels.x, y: t2 + c.labels.y + 0.4 * a3.getBBox().height };
              a3.attr(c);
              d.push(a3);
              a3.placed = true;
              a3.alignAttr = c;
            }
            getMaxLabelSize() {
              let a3, e;
              this.symbols.labels.forEach(function(b) {
                e = b.getBBox(true);
                a3 = a3 ? e.width > a3.width ? e : a3 : e;
              });
              return a3 || {};
            }
            formatLabel(a3) {
              var c = this.options;
              const b = c.labels.formatter;
              c = c.labels.format;
              const { numberFormatter: d } = this.chart;
              return c ? n.format(c, a3) : b ? b.call(a3) : d(a3.value, 1);
            }
            hideOverlappingLabels() {
              const a3 = this.chart, e = this.symbols;
              !this.options.labels.allowOverlap && e && (a3.hideOverlappingLabels(e.labels), e.labels.forEach(function(a4, d) {
                a4.newOpacity ? a4.newOpacity !== a4.oldOpacity && e.connectors[d].show() : e.connectors[d].hide();
              }));
            }
            getRanges() {
              const a3 = this.legend.bubbleLegend, e = a3.options.ranges;
              let b, d, f2 = Number.MAX_VALUE, g2 = -Number.MAX_VALUE;
              a3.chart.series.forEach(function(a4) {
                a4.isBubble && !a4.ignoreSeries && (d = a4.zData.filter(x), d.length && (f2 = h(a4.options.zMin, Math.min(f2, Math.max(w(d), false === a4.options.displayNegative ? a4.options.zThreshold : -Number.MAX_VALUE))), g2 = h(a4.options.zMax, Math.max(g2, A(d)))));
              });
              b = f2 === g2 ? [{ value: g2 }] : [{ value: f2 }, { value: (f2 + g2) / 2 }, { value: g2, autoRanges: true }];
              e.length && e[0].radius && b.reverse();
              b.forEach(function(a4, d2) {
                e && e[d2] && (b[d2] = t(e[d2], a4));
              });
              return b;
            }
            predictBubbleSizes() {
              var a3 = this.chart, e = a3.legend.options, b = e.floating;
              const d = (e = "horizontal" === e.layout) ? a3.legend.lastLineHeight : 0, f2 = a3.plotSizeX, g2 = a3.plotSizeY;
              var h2 = a3.series[this.options.seriesIndex], m = h2.getPxExtremes();
              a3 = Math.ceil(m.minPxSize);
              m = Math.ceil(m.maxPxSize);
              const r = Math.min(g2, f2);
              h2 = h2.options.maxSize;
              if (b || !/%$/.test(h2))
                b = m;
              else if (h2 = parseFloat(h2), b = (r + d) * h2 / 100 / (h2 / 100 + 1), e && g2 - b >= f2 || !e && f2 - b >= g2)
                b = m;
              return [a3, Math.ceil(b)];
            }
            updateRanges(a3, e) {
              const b = this.legend.options.bubbleLegend;
              b.minSize = a3;
              b.maxSize = e;
              b.ranges = this.getRanges();
            }
            correctSizes() {
              const a3 = this.legend, e = this.chart.series[this.options.seriesIndex].getPxExtremes();
              1 < Math.abs(Math.ceil(e.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, e.maxPxSize), a3.render());
            }
          }
          "";
          return f;
        }
      );
      y(a, "Series/Bubble/BubbleLegendComposition.js", [a["Series/Bubble/BubbleLegendDefaults.js"], a["Series/Bubble/BubbleLegendItem.js"], a["Core/Defaults.js"], a["Core/Utilities.js"]], function(a2, n, q, z) {
        function g(a3, d, c2) {
          const b = this.legend;
          var e2 = 0 <= l(this);
          let h2, g2;
          b && b.options.enabled && b.bubbleLegend && b.options.bubbleLegend.autoRanges && e2 ? (h2 = b.bubbleLegend.options, e2 = b.bubbleLegend.predictBubbleSizes(), b.bubbleLegend.updateRanges(e2[0], e2[1]), h2.placed || (b.group.placed = false, b.allItems.forEach((a4) => {
            g2 = a4.legendItem || {};
            g2.group && (g2.group.translateY = null);
          })), b.render(), this.getMargins(), this.axes.forEach(function(a4) {
            a4.visible && a4.render();
            h2.placed || (a4.setScale(), a4.updateNames(), f(a4.ticks, function(a5) {
              a5.isNew = true;
              a5.isNewLabel = true;
            }));
          }), h2.placed = true, this.getMargins(), a3.call(this, d, c2), b.bubbleLegend.correctSizes(), t(b, A(b))) : (a3.call(this, d, c2), b && b.options.enabled && b.bubbleLegend && (b.render(), t(b, A(b))));
        }
        function l(a3) {
          a3 = a3.series;
          let b = 0;
          for (; b < a3.length; ) {
            if (a3[b] && a3[b].isBubble && a3[b].visible && a3[b].zData.length)
              return b;
            b++;
          }
          return -1;
        }
        function A(a3) {
          a3 = a3.allItems;
          const b = [], c2 = a3.length;
          let e2, f2, h2 = 0;
          for (f2 = 0; f2 < c2; f2++) {
            var g2 = a3[f2].legendItem || {};
            e2 = (a3[f2 + 1] || {}).legendItem || {};
            g2.labelHeight && (a3[f2].itemHeight = g2.labelHeight);
            if (a3[f2] === a3[c2 - 1] || g2.y !== e2.y) {
              b.push({ height: 0 });
              g2 = b[b.length - 1];
              for (h2; h2 <= f2; h2++)
                a3[h2].itemHeight > g2.height && (g2.height = a3[h2].itemHeight);
              g2.step = f2;
            }
          }
          return b;
        }
        function w(a3) {
          const b = this.bubbleLegend, c2 = this.options, e2 = c2.bubbleLegend, f2 = l(this.chart);
          b && b.ranges && b.ranges.length && (e2.ranges.length && (e2.autoRanges = !!e2.ranges[0].autoRanges), this.destroyItem(b));
          0 <= f2 && c2.enabled && e2.enabled && (e2.seriesIndex = f2, this.bubbleLegend = new n(e2, this), this.bubbleLegend.addToLegend(a3.allItems));
        }
        function x(a3) {
          if (a3.defaultPrevented)
            return false;
          var b = this.chart;
          a3 = this.visible;
          const c2 = this.chart.legend;
          c2 && c2.bubbleLegend && (this.visible = !a3, this.ignoreSeries = a3, b = 0 <= l(b), c2.bubbleLegend.visible !== b && (c2.update({ bubbleLegend: { enabled: b } }), c2.bubbleLegend.visible = b), this.visible = a3);
        }
        function t(a3, c2) {
          const b = a3.options.rtl;
          let d, e2, f2, h2, g2 = 0;
          a3.allItems.forEach((a4, m) => {
            h2 = a4.legendItem || {};
            if (h2.group) {
              d = h2.group.translateX || 0;
              e2 = h2.y || 0;
              if ((f2 = a4.movementX) || b && a4.ranges)
                f2 = b ? d - a4.options.maxSize / 2 : d + f2, h2.group.attr({ translateX: f2 });
              m > c2[g2].step && g2++;
              h2.group.attr({ translateY: Math.round(e2 + c2[g2].height / 2) });
              h2.y = e2 + c2[g2].height / 2;
            }
          });
        }
        const { setOptions: h } = q, { addEvent: y2, objectEach: f, wrap: c } = z, e = [];
        return { compose: function(b, d, f2) {
          z.pushUnique(e, b) && (h({ legend: { bubbleLegend: a2 } }), c(b.prototype, "drawChartBox", g));
          z.pushUnique(e, d) && y2(d, "afterGetAllItems", w);
          z.pushUnique(e, f2) && y2(f2, "legendItemClick", x);
        } };
      });
      y(a, "Series/Bubble/BubblePoint.js", [a["Core/Series/Point.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n, q) {
        ({ seriesTypes: { scatter: { prototype: { pointClass: n } } } } = n);
        ({ extend: q } = q);
        class g extends n {
          constructor() {
            super(...arguments);
            this.series = this.options = void 0;
          }
          haloPath(g2) {
            return a2.prototype.haloPath.call(this, 0 === g2 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + g2);
          }
        }
        q(g.prototype, { ttBelow: false });
        return g;
      });
      y(a, "Series/Bubble/BubbleSeries.js", [a["Series/Bubble/BubbleLegendComposition.js"], a["Series/Bubble/BubblePoint.js"], a["Core/Color/Color.js"], a["Core/Globals.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n, q, z, k, l) {
        function g() {
          const a3 = this.len, b2 = this.chart, c2 = this.isXAxis, e2 = c2 ? "xData" : "yData", f2 = this.min, h2 = this.max - f2;
          let g2 = 0, m2 = a3, k2 = a3 / h2, l2;
          this.series.forEach((a4) => {
            if (a4.bubblePadding && (a4.visible || !b2.options.chart.ignoreHiddenSeries)) {
              l2 = this.allowZoomOutside = true;
              const b3 = a4[e2];
              c2 && ((a4.onPoint || a4).getRadii(0, 0, a4), a4.onPoint && (a4.radii = a4.onPoint.radii));
              if (0 < h2) {
                let c3 = b3.length;
                for (; c3--; )
                  if (d(b3[c3]) && this.dataMin <= b3[c3] && b3[c3] <= this.max) {
                    const d2 = a4.radii && a4.radii[c3] || 0;
                    g2 = Math.min((b3[c3] - f2) * k2 - d2, g2);
                    m2 = Math.max((b3[c3] - f2) * k2 + d2, m2);
                  }
              }
            }
          });
          l2 && 0 < h2 && !this.logarithmic && (m2 -= a3, k2 *= (a3 + Math.max(0, g2) - Math.min(m2, a3)) / a3, [
            ["min", "userMin", g2],
            ["max", "userMax", m2]
          ].forEach((a4) => {
            "undefined" === typeof p(this.options[a4[0]], this[a4[1]]) && (this[a4[0]] += a4[2] / k2);
          }));
        }
        const { parse: w } = q;
        ({ noop: q } = z);
        const { series: x, seriesTypes: { column: { prototype: t }, scatter: h } } = k, { addEvent: y2, arrayMax: f, arrayMin: c, clamp: e, extend: b, isNumber: d, merge: E, pick: p } = l, C = [];
        class m extends h {
          constructor() {
            super(...arguments);
            this.zData = this.yData = this.radii = this.points = this.options = this.minPxSize = this.maxPxSize = this.data = void 0;
          }
          static compose(b2, c2, d2, e2) {
            a2.compose(c2, d2, e2);
            l.pushUnique(
              C,
              b2
            ) && (b2.prototype.beforePadding = g);
          }
          animate(a3) {
            !a3 && this.points.length < this.options.animationLimit && this.points.forEach(function(a4) {
              const { graphic: b2 } = a4;
              b2 && b2.width && (this.hasRendered || b2.attr({ x: a4.plotX, y: a4.plotY, width: 1, height: 1 }), b2.animate(this.markerAttribs(a4), this.options.animation));
            }, this);
          }
          getRadii() {
            const a3 = this.zData, b2 = this.yData, c2 = [];
            let d2, e2, f2, h2 = this.chart.bubbleZExtremes;
            const { minPxSize: g2, maxPxSize: m2 } = this.getPxExtremes();
            if (!h2) {
              let a4 = Number.MAX_VALUE, b3 = -Number.MAX_VALUE, c3;
              this.chart.series.forEach((d3) => {
                d3.bubblePadding && (d3.visible || !this.chart.options.chart.ignoreHiddenSeries) && (d3 = (d3.onPoint || d3).getZExtremes()) && (a4 = Math.min(p(a4, d3.zMin), d3.zMin), b3 = Math.max(p(b3, d3.zMax), d3.zMax), c3 = true);
              });
              c3 ? (h2 = { zMin: a4, zMax: b3 }, this.chart.bubbleZExtremes = h2) : h2 = { zMin: 0, zMax: 0 };
            }
            e2 = 0;
            for (d2 = a3.length; e2 < d2; e2++)
              f2 = a3[e2], c2.push(this.getRadius(h2.zMin, h2.zMax, g2, m2, f2, b2 && b2[e2]));
            this.radii = c2;
          }
          getRadius(a3, b2, c2, e2, f2, h2) {
            const g2 = this.options, m2 = "width" !== g2.sizeBy, k2 = g2.zThreshold;
            let l2 = b2 - a3, r = 0.5;
            if (null === h2 || null === f2)
              return null;
            if (d(f2)) {
              g2.sizeByAbsoluteValue && (f2 = Math.abs(f2 - k2), l2 = Math.max(b2 - k2, Math.abs(a3 - k2)), a3 = 0);
              if (f2 < a3)
                return c2 / 2 - 1;
              0 < l2 && (r = (f2 - a3) / l2);
            }
            m2 && 0 <= r && (r = Math.sqrt(r));
            return Math.ceil(c2 + r * (e2 - c2)) / 2;
          }
          hasData() {
            return !!this.processedXData.length;
          }
          pointAttribs(a3, b2) {
            const c2 = this.options.marker.fillOpacity;
            a3 = x.prototype.pointAttribs.call(this, a3, b2);
            1 !== c2 && (a3.fill = w(a3.fill).setOpacity(c2).get("rgba"));
            return a3;
          }
          translate() {
            super.translate.call(this);
            this.getRadii();
            this.translateBubble();
          }
          translateBubble() {
            const { data: a3, options: c2, radii: e2 } = this, { minPxSize: f2 } = this.getPxExtremes();
            let h2 = a3.length;
            for (; h2--; ) {
              const g2 = a3[h2], m2 = e2 ? e2[h2] : 0;
              "z" === this.zoneAxis && (g2.negative = (g2.z || 0) < (c2.zThreshold || 0));
              d(m2) && m2 >= f2 / 2 ? (g2.marker = b(g2.marker, { radius: m2, width: 2 * m2, height: 2 * m2 }), g2.dlBox = { x: g2.plotX - m2, y: g2.plotY - m2, width: 2 * m2, height: 2 * m2 }) : (g2.shapeArgs = g2.plotY = g2.dlBox = void 0, g2.isInside = false);
            }
          }
          getPxExtremes() {
            const a3 = Math.min(this.chart.plotWidth, this.chart.plotHeight);
            var b2 = (b3) => {
              let c3;
              "string" === typeof b3 && (c3 = /%$/.test(b3), b3 = parseInt(b3, 10));
              return c3 ? a3 * b3 / 100 : b3;
            };
            const c2 = b2(p(this.options.minSize, 8));
            b2 = Math.max(b2(p(
              this.options.maxSize,
              "20%"
            )), c2);
            return { minPxSize: c2, maxPxSize: b2 };
          }
          getZExtremes() {
            var a3 = this.options;
            const b2 = (this.zData || []).filter(d);
            if (b2.length) {
              const g2 = p(a3.zMin, e(c(b2), false === a3.displayNegative ? a3.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));
              a3 = p(a3.zMax, f(b2));
              if (d(g2) && d(a3))
                return { zMin: g2, zMax: a3 };
            }
          }
        }
        m.defaultOptions = E(h.defaultOptions, { dataLabels: { formatter: function() {
          const { numberFormatter: a3 } = this.series.chart, { z: b2 } = this.point;
          return d(b2) ? a3(b2, -1) : "";
        }, inside: true, verticalAlign: "middle" }, animationLimit: 250, marker: {
          lineColor: null,
          lineWidth: 1,
          fillOpacity: 0.5,
          radius: null,
          states: { hover: { radiusPlus: 0 } },
          symbol: "circle"
        }, minSize: 8, maxSize: "20%", softThreshold: false, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 0, zThreshold: 0, zoneAxis: "z" });
        b(m.prototype, {
          alignDataLabel: t.alignDataLabel,
          applyZones: q,
          bubblePadding: true,
          buildKDTree: q,
          directTouch: true,
          isBubble: true,
          pointArrayMap: ["y", "z"],
          pointClass: n,
          parallelArrays: ["x", "y", "z"],
          trackerGroups: ["group", "dataLabelsGroup"],
          specialGroup: "group",
          zoneAxis: "z"
        });
        y2(m, "updatedData", (a3) => {
          delete a3.target.chart.bubbleZExtremes;
        });
        y2(m, "remove", (a3) => {
          delete a3.target.chart.bubbleZExtremes;
        });
        k.registerSeriesType("bubble", m);
        "";
        "";
        return m;
      });
      y(a, "Series/MapBubble/MapBubblePoint.js", [a["Series/Bubble/BubblePoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n, q) {
        ({ seriesTypes: { map: { prototype: { pointClass: { prototype: n } } } } } = n);
        ({ extend: q } = q);
        class g extends a2 {
          isValid() {
            return "number" === typeof this.z;
          }
        }
        q(g.prototype, {
          applyOptions: n.applyOptions,
          getProjectedBounds: n.getProjectedBounds
        });
        return g;
      });
      y(a, "Series/MapBubble/MapBubbleSeries.js", [a["Series/Bubble/BubbleSeries.js"], a["Series/MapBubble/MapBubblePoint.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n, q, y2) {
        const { seriesTypes: { map: { prototype: g }, mappoint: { prototype: l } } } = q, { extend: z, merge: w } = y2;
        class x extends a2 {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = void 0;
            this.clearBounds = g.clearBounds;
          }
          searchPoint(a3, g2) {
            return this.searchKDTree({ clientX: a3.chartX - this.chart.plotLeft, plotY: a3.chartY - this.chart.plotTop }, g2, a3);
          }
          translate() {
            l.translate.call(this);
            this.getRadii();
            this.translateBubble();
          }
          updateParallelArrays(a3, g2, k) {
            super.updateParallelArrays.call(this, a3, g2, k);
            a3 = this.processedXData;
            g2 = this.xData;
            a3 && g2 && (a3.length = g2.length);
          }
        }
        x.defaultOptions = w(a2.defaultOptions, { lineWidth: 0, animationLimit: 500, joinBy: "hc-key", tooltip: { pointFormat: "{point.name}: {point.z}" } });
        z(x.prototype, {
          type: "mapbubble",
          axisTypes: ["colorAxis"],
          getProjectedBounds: g.getProjectedBounds,
          isCartesian: false,
          pointArrayMap: ["z"],
          pointClass: n,
          processData: g.processData,
          projectPoint: l.projectPoint,
          setData: g.setData,
          setOptions: g.setOptions,
          updateData: g.updateData,
          useMapGeometry: true,
          xyFromShape: true
        });
        q.registerSeriesType("mapbubble", x);
        "";
        return x;
      });
      y(a, "Series/Heatmap/HeatmapPoint.js", [a["Core/Series/SeriesRegistry.js"], a["Core/Utilities.js"]], function(a2, n) {
        ({ seriesTypes: { scatter: { prototype: { pointClass: a2 } } } } = a2);
        const { clamp: g, defined: y2, extend: k, pick: l } = n;
        class A extends a2 {
          constructor() {
            super(...arguments);
            this.y = this.x = this.value = this.series = this.options = void 0;
          }
          applyOptions(a3, g2) {
            (this.isNull || null === this.value) && delete this.color;
            super.applyOptions(a3, g2);
            this.formatPrefix = this.isNull || null === this.value ? "null" : "point";
            return this;
          }
          getCellAttributes() {
            var a3 = this.series;
            const k2 = a3.options, n2 = (k2.colsize || 1) / 2, h = (k2.rowsize || 1) / 2, q = a3.xAxis, f = a3.yAxis, c = this.options.marker || a3.options.marker;
            a3 = a3.pointPlacementToXValue();
            const e = l(this.pointPadding, k2.pointPadding, 0), b = { x1: g(Math.round(q.len - q.translate(
              this.x - n2,
              false,
              true,
              false,
              true,
              -a3
            )), -q.len, 2 * q.len), x2: g(Math.round(q.len - q.translate(this.x + n2, false, true, false, true, -a3)), -q.len, 2 * q.len), y1: g(Math.round(f.translate(this.y - h, false, true, false, true)), -f.len, 2 * f.len), y2: g(Math.round(f.translate(this.y + h, false, true, false, true)), -f.len, 2 * f.len) };
            [["width", "x"], ["height", "y"]].forEach(function(a4) {
              var d = a4[0];
              a4 = a4[1];
              let g2 = a4 + "1", h2 = a4 + "2";
              const m = Math.abs(b[g2] - b[h2]), k3 = c && c.lineWidth || 0, l2 = Math.abs(b[g2] + b[h2]) / 2;
              d = c && c[d];
              y2(d) && d < m && (d = d / 2 + k3 / 2, b[g2] = l2 - d, b[h2] = l2 + d);
              if (e) {
                if ("x" === a4 && q.reversed || "y" === a4 && !f.reversed)
                  g2 = h2, h2 = a4 + "1";
                b[g2] += e;
                b[h2] -= e;
              }
            });
            return b;
          }
          haloPath(a3) {
            if (!a3)
              return [];
            const { x: g2 = 0, y: k2 = 0, width: h = 0, height: l2 = 0 } = this.shapeArgs || {};
            return [["M", g2 - a3, k2 - a3], ["L", g2 - a3, k2 + l2 + a3], ["L", g2 + h + a3, k2 + l2 + a3], ["L", g2 + h + a3, k2 - a3], ["Z"]];
          }
          isValid() {
            return Infinity !== this.value && -Infinity !== this.value;
          }
        }
        k(A.prototype, { dataLabelOnNull: true, moveToTopOnHover: true, ttBelow: false });
        return A;
      });
      y(a, "Series/Heatmap/HeatmapSeries.js", [
        a["Core/Color/Color.js"],
        a["Series/ColorMapComposition.js"],
        a["Core/Globals.js"],
        a["Series/Heatmap/HeatmapPoint.js"],
        a["Core/Series/SeriesRegistry.js"],
        a["Core/Renderer/SVG/SVGRenderer.js"],
        a["Core/Utilities.js"]
      ], function(a2, n, q, y2, k, l, A) {
        const { doc: g } = q, { series: x, seriesTypes: { column: t, scatter: h } } = k, { prototype: { symbols: z } } = l, { clamp: f, extend: c, fireEvent: e, isNumber: b, merge: d, pick: E, defined: p } = A;
        class C extends h {
          constructor() {
            super(...arguments);
            this.points = this.options = this.data = this.context = this.colorAxis = this.canvas = void 0;
            this.valueMin = this.valueMax = NaN;
          }
          drawPoints() {
            const a3 = this;
            var b2 = a3.options, c2 = b2.marker || {};
            if (b2.interpolation) {
              const { image: h2, chart: k2, xAxis: m, yAxis: l2, points: n2 } = a3;
              c2 = n2.length - 1;
              const { len: r, reversed: v } = m, { len: q2, reversed: u } = l2, { min: t2, max: w } = m.getExtremes(), { min: x2, max: y3 } = l2.getExtremes(), [z2, A2] = [E(b2.colsize, 1), E(b2.rowsize, 1)];
              var d2 = k2.inverted, e2 = z2 / 2;
              b2 = m.userOptions.minPadding;
              var g2 = p(b2) && !(0 < b2);
              b2 = d2 || g2;
              e2 = g2 && e2 || 0;
              const [B, G, C2] = [t2 - e2, w + 2 * e2, t2 + z2].map((b3) => f(Math.round(m.len - m.translate(b3, false, true, false, true, -a3.pointPlacementToXValue())), -m.len, 2 * m.len)), [F, I] = v ? [G, B] : [B, G];
              e2 = r / C2 / 2 / 2 / 2;
              d2 = d2 ? {
                width: r,
                height: q2,
                x: 0,
                y: 0
              } : { x: F - e2, width: I - e2, height: q2, y: 0 };
              if (!h2 || a3.isDirtyData) {
                const f2 = k2.colorAxis && k2.colorAxis[0];
                e2 = a3.getContext();
                if ((g2 = a3.canvas) && e2 && f2) {
                  const m2 = g2.width = ~~((w - t2) / z2) + 1, l3 = g2.height = ~~((y3 - x2) / A2) + 1, r2 = m2 * l3, p2 = new Uint8ClampedArray(4 * r2), q3 = m2 - (b2 && 1 || 0), D = l3 - 1;
                  b2 = (a4) => {
                    a4 = f2.toColor(a4.value || 0, E(a4)).split(")")[0].split("(")[1].split(",").map((a5) => E(parseFloat(a5), parseInt(a5, 10)));
                    a4[3] = 255 * E(a4[3], 1);
                    return a4;
                  };
                  const B2 = v ? (a4) => q3 - a4 : (a4) => a4, G2 = u ? (a4) => D - a4 : (a4) => a4, C3 = (a4, b3) => Math.ceil(m2 * G2(~~((D - 0) / (y3 - x2) * (y3 - b3 - x2))) + B2(~~((q3 - 0) / (w - t2) * (a4 - t2))));
                  a3.buildKDTree();
                  a3.directTouch = false;
                  for (let a4 = 0; a4 < r2; a4++) {
                    const d3 = n2[~~((c2 - 0) / (p2.length - 4) * a4 * 4)], e3 = new Uint8ClampedArray(b2(d3));
                    p2.set(e3, 4 * C3(d3.x, d3.y));
                  }
                  e2.putImageData(new ImageData(p2, m2, l3), 0, 0);
                  h2 ? h2.attr(Object.assign(Object.assign({}, d2), { href: g2.toDataURL() })) : a3.image = k2.renderer.image(g2.toDataURL()).attr(d2).add(a3.group);
                }
              } else
                h2.width === d2.width && h2.height === d2.height || h2.attr(d2);
            } else if (c2.enabled || a3._hasPointMarkers)
              x.prototype.drawPoints.call(a3), a3.points.forEach((b3) => {
                b3.graphic && (b3.graphic[a3.chart.styledMode ? "css" : "animate"](a3.colorAttribs(b3)), null === b3.value && b3.graphic.addClass("highcharts-null-point"));
              });
          }
          getContext() {
            const { canvas: a3, context: b2 } = this;
            if (a3 && b2)
              b2.clearRect(0, 0, a3.width, a3.height);
            else
              return this.canvas = g.createElement("canvas"), this.context = this.canvas.getContext("2d") || void 0;
            return b2;
          }
          getExtremes() {
            const { dataMin: a3, dataMax: c2 } = x.prototype.getExtremes.call(this, this.valueData);
            b(a3) && (this.valueMin = a3);
            b(c2) && (this.valueMax = c2);
            return x.prototype.getExtremes.call(this);
          }
          getValidPoints(a3, b2) {
            return x.prototype.getValidPoints.call(
              this,
              a3,
              b2,
              true
            );
          }
          hasData() {
            return !!this.processedXData.length;
          }
          init() {
            super.init.apply(this, arguments);
            const a3 = this.options;
            a3.pointRange = E(a3.pointRange, a3.colsize || 1);
            this.yAxis.axisPointRange = a3.rowsize || 1;
            z.ellipse = z.circle;
            a3.marker && b(a3.borderRadius) && (a3.marker.r = a3.borderRadius);
          }
          markerAttribs(a3, b2) {
            const c2 = a3.shapeArgs || {};
            if (a3.hasImage)
              return { x: a3.plotX, y: a3.plotY };
            if (b2 && "normal" !== b2) {
              var d2 = a3.options.marker || {};
              a3 = this.options.marker || {};
              a3 = a3.states && a3.states[b2] || {};
              d2 = d2.states && d2.states[b2] || {};
              b2 = (d2.width || a3.width || c2.width || 0) + (d2.widthPlus || a3.widthPlus || 0);
              a3 = (d2.height || a3.height || c2.height || 0) + (d2.heightPlus || a3.heightPlus || 0);
              return { x: (c2.x || 0) + ((c2.width || 0) - b2) / 2, y: (c2.y || 0) + ((c2.height || 0) - a3) / 2, width: b2, height: a3 };
            }
            return c2;
          }
          pointAttribs(b2, c2) {
            const e2 = x.prototype.pointAttribs.call(this, b2, c2), f2 = this.options || {};
            var g2 = this.chart.options.plotOptions || {}, h2 = g2.series || {};
            const k2 = g2.heatmap || {};
            g2 = b2 && b2.options.borderColor || f2.borderColor || k2.borderColor || h2.borderColor;
            h2 = b2 && b2.options.borderWidth || f2.borderWidth || k2.borderWidth || h2.borderWidth || e2["stroke-width"];
            e2.stroke = b2 && b2.marker && b2.marker.lineColor || f2.marker && f2.marker.lineColor || g2 || this.color;
            e2["stroke-width"] = h2;
            c2 && "normal" !== c2 && (b2 = d(f2.states && f2.states[c2], f2.marker && f2.marker.states && f2.marker.states[c2], b2 && b2.options.states && b2.options.states[c2] || {}), e2.fill = b2.color || a2.parse(e2.fill).brighten(b2.brightness || 0).get(), e2.stroke = b2.lineColor || e2.stroke);
            return e2;
          }
          translate() {
            const { borderRadius: a3, marker: c2 } = this.options, f2 = c2 && c2.symbol || "rect", g2 = z[f2] ? f2 : "rect", h2 = -1 !== ["circle", "square"].indexOf(g2);
            this.generatePoints();
            this.points.forEach(function(c3) {
              const e2 = c3.getCellAttributes();
              let k2 = Math.min(e2.x1, e2.x2);
              var l2 = Math.min(e2.y1, e2.y2);
              let m = Math.max(Math.abs(e2.x2 - e2.x1), 0), n2 = Math.max(Math.abs(e2.y2 - e2.y1), 0);
              c3.hasImage = 0 === (c3.marker && c3.marker.symbol || f2 || "").indexOf("url");
              h2 && (l2 = Math.abs(m - n2), k2 = Math.min(e2.x1, e2.x2) + (m < n2 ? 0 : l2 / 2), l2 = Math.min(e2.y1, e2.y2) + (m < n2 ? l2 / 2 : 0), m = n2 = Math.min(m, n2));
              c3.hasImage && (c3.marker = { width: m, height: n2 });
              c3.plotX = c3.clientX = (e2.x1 + e2.x2) / 2;
              c3.plotY = (e2.y1 + e2.y2) / 2;
              c3.shapeType = "path";
              c3.shapeArgs = d(true, {
                x: k2,
                y: l2,
                width: m,
                height: n2
              }, { d: z[g2](k2, l2, m, n2, { r: b(a3) ? a3 : 0 }) });
            });
            e(this, "afterTranslate");
          }
        }
        C.defaultOptions = d(h.defaultOptions, {
          animation: false,
          borderRadius: 0,
          borderWidth: 0,
          interpolation: false,
          nullColor: "#f7f7f7",
          dataLabels: { formatter: function() {
            const { numberFormatter: a3 } = this.series.chart, { value: c2 } = this.point;
            return b(c2) ? a3(c2, -1) : "";
          }, inside: true, verticalAlign: "middle", crop: false, overflow: "allow", padding: 0 },
          marker: { symbol: "rect", radius: 0, lineColor: void 0, states: { hover: { lineWidthPlus: 0 }, select: {} } },
          clip: true,
          pointRange: null,
          tooltip: { pointFormat: "{point.x}, {point.y}: {point.value}<br/>" },
          states: { hover: { halo: false, brightness: 0.2 } },
          legendSymbol: "rectangle"
        });
        c(C.prototype, { axisTypes: n.seriesMembers.axisTypes, colorKey: n.seriesMembers.colorKey, directTouch: true, getExtremesFromAll: true, parallelArrays: n.seriesMembers.parallelArrays, pointArrayMap: ["y", "value"], pointClass: y2, specialGroup: "group", trackerGroups: n.seriesMembers.trackerGroups, alignDataLabel: t.prototype.alignDataLabel, colorAttribs: n.seriesMembers.colorAttribs, getSymbol: x.prototype.getSymbol });
        n.compose(C);
        k.registerSeriesType(
          "heatmap",
          C
        );
        "";
        "";
        return C;
      });
      y(a, "masters/modules/map.src.js", [a["Core/Globals.js"], a["Core/Axis/Color/ColorAxis.js"], a["Series/MapBubble/MapBubbleSeries.js"], a["Core/Chart/MapChart.js"], a["Maps/MapView.js"], a["Maps/Projection.js"]], function(a2, n, q, y2, k, l) {
        a2.ColorAxis = n;
        a2.MapChart = y2;
        a2.mapChart = a2.Map = y2.mapChart;
        a2.MapView = k;
        a2.maps = y2.maps;
        a2.Projection = l;
        n.compose(a2.Chart, a2.Fx, a2.Legend, a2.Series);
        q.compose(a2.Axis, a2.Chart, a2.Legend, a2.Series);
      });
    });
  }
});
export default require_map();
//# sourceMappingURL=highcharts_modules_map.js.map
